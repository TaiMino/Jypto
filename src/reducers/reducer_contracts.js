export default function() {
  return [
    {
      "contractId": 1,
      "title": "EOS Token",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "EOS",
      "code": "contract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n\tuint\t \t  wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n        }\r\n\r\n        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) constant returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    function DSAuth() {\r\n        owner = msg.sender;\r\n        LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        assert(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    modifier authorized(bytes4 sig) {\r\n        assert(isAuthorized(msg.sender, sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n\r\n    function assert(bool x) internal {\r\n        if (!x) throw;\r\n    }\r\n}\r\n\r\ncontract DSStop is DSAuth, DSNote {\r\n\r\n    bool public stopped;\r\n\r\n    modifier stoppable {\r\n        assert (!stopped);\r\n        _;\r\n    }\r\n    function stop() auth note {\r\n        stopped = true;\r\n    }\r\n    function start() auth note {\r\n        stopped = false;\r\n    }\r\n\r\n}\r\n\r\ncontract DSMath {\r\n    \r\n    \/*\r\n    standard uint256 functions\r\n     *\/\r\n\r\n    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x + y) >= x);\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x - y) <= x);\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        assert((z = x * y) >= x);\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        z = x \/ y;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    \/*\r\n    uint128 functions (h is for half)\r\n     *\/\r\n\r\n\r\n    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        assert((z = x + y) >= x);\r\n    }\r\n\r\n    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        assert((z = x - y) <= x);\r\n    }\r\n\r\n    function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        assert((z = x * y) >= x);\r\n    }\r\n\r\n    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = x \/ y;\r\n    }\r\n\r\n    function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n\r\n    \/*\r\n    int256 functions\r\n     *\/\r\n\r\n    function imin(int256 x, int256 y) constant internal returns (int256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int256 x, int256 y) constant internal returns (int256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    \/*\r\n    WAD math\r\n     *\/\r\n\r\n    uint128 constant WAD = 10 ** 18;\r\n\r\n    function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hadd(x, y);\r\n    }\r\n\r\n    function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hsub(x, y);\r\n    }\r\n\r\n    function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = cast((uint256(x) * y + WAD \/ 2) \/ WAD);\r\n    }\r\n\r\n    function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = cast((uint256(x) * WAD + y \/ 2) \/ y);\r\n    }\r\n\r\n    function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hmin(x, y);\r\n    }\r\n    function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hmax(x, y);\r\n    }\r\n\r\n    \/*\r\n    RAY math\r\n     *\/\r\n\r\n    uint128 constant RAY = 10 ** 27;\r\n\r\n    function radd(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hadd(x, y);\r\n    }\r\n\r\n    function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hsub(x, y);\r\n    }\r\n\r\n    function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = cast((uint256(x) * y + RAY \/ 2) \/ RAY);\r\n    }\r\n\r\n    function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\r\n        z = cast((uint256(x) * RAY + y \/ 2) \/ y);\r\n    }\r\n\r\n    function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\r\n        \/\/ This famous algorithm is called \"exponentiation by squaring\"\r\n        \/\/ and calculates x^n with x as fixed-point and n as regular unsigned.\r\n        \/\/\r\n        \/\/ It's O(log n), instead of O(n) for naive repeated multiplication.\r\n        \/\/\r\n        \/\/ These facts are why it works:\r\n        \/\/\r\n        \/\/  If n is even, then x^n = (x^2)^(n\/2).\r\n        \/\/  If n is odd,  then x^n = x * x^(n-1),\r\n        \/\/   and applying the equation for even x gives\r\n        \/\/    x^n = x * (x^2)^((n-1) \/ 2).\r\n        \/\/\r\n        \/\/  Also, EVM division is flooring and\r\n        \/\/    floor[(n-1) \/ 2] = floor[n \/ 2].\r\n\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n \/= 2; n != 0; n \/= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n\r\n    function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hmin(x, y);\r\n    }\r\n    function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\r\n        return hmax(x, y);\r\n    }\r\n\r\n    function cast(uint256 x) constant internal returns (uint128 z) {\r\n        assert((z = uint128(x)) == x);\r\n    }\r\n\r\n}\r\n\r\ncontract ERC20 {\r\n    function totalSupply() constant returns (uint supply);\r\n    function balanceOf( address who ) constant returns (uint value);\r\n    function allowance( address owner, address spender ) constant returns (uint _allowance);\r\n\r\n    function transfer( address to, uint value) returns (bool ok);\r\n    function transferFrom( address from, address to, uint value) returns (bool ok);\r\n    function approve( address spender, uint value ) returns (bool ok);\r\n\r\n    event Transfer( address indexed from, address indexed to, uint value);\r\n    event Approval( address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract DSTokenBase is ERC20, DSMath {\r\n    uint256                                            _supply;\r\n    mapping (address => uint256)                       _balances;\r\n    mapping (address => mapping (address => uint256))  _approvals;\r\n    \r\n    function DSTokenBase(uint256 supply) {\r\n        _balances[msg.sender] = supply;\r\n        _supply = supply;\r\n    }\r\n    \r\n    function totalSupply() constant returns (uint256) {\r\n        return _supply;\r\n    }\r\n    function balanceOf(address src) constant returns (uint256) {\r\n        return _balances[src];\r\n    }\r\n    function allowance(address src, address guy) constant returns (uint256) {\r\n        return _approvals[src][guy];\r\n    }\r\n    \r\n    function transfer(address dst, uint wad) returns (bool) {\r\n        assert(_balances[msg.sender] >= wad);\r\n        \r\n        _balances[msg.sender] = sub(_balances[msg.sender], wad);\r\n        _balances[dst] = add(_balances[dst], wad);\r\n        \r\n        Transfer(msg.sender, dst, wad);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address src, address dst, uint wad) returns (bool) {\r\n        assert(_balances[src] >= wad);\r\n        assert(_approvals[src][msg.sender] >= wad);\r\n        \r\n        _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\r\n        _balances[src] = sub(_balances[src], wad);\r\n        _balances[dst] = add(_balances[dst], wad);\r\n        \r\n        Transfer(src, dst, wad);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function approve(address guy, uint256 wad) returns (bool) {\r\n        _approvals[msg.sender][guy] = wad;\r\n        \r\n        Approval(msg.sender, guy, wad);\r\n        \r\n        return true;\r\n    }\r\n\r\n}\r\n\r\ncontract DSToken is DSTokenBase(0), DSStop {\r\n\r\n    bytes32  public  symbol;\r\n    uint256  public  decimals = 18; \/\/ standard token precision. override to customize\r\n\r\n    function DSToken(bytes32 symbol_) {\r\n        symbol = symbol_;\r\n    }\r\n\r\n    function transfer(address dst, uint wad) stoppable note returns (bool) {\r\n        return super.transfer(dst, wad);\r\n    }\r\n    function transferFrom(\r\n        address src, address dst, uint wad\r\n    ) stoppable note returns (bool) {\r\n        return super.transferFrom(src, dst, wad);\r\n    }\r\n    function approve(address guy, uint wad) stoppable note returns (bool) {\r\n        return super.approve(guy, wad);\r\n    }\r\n\r\n    function push(address dst, uint128 wad) returns (bool) {\r\n        return transfer(dst, wad);\r\n    }\r\n    function pull(address src, uint128 wad) returns (bool) {\r\n        return transferFrom(src, msg.sender, wad);\r\n    }\r\n\r\n    function mint(uint128 wad) auth stoppable note {\r\n        _balances[msg.sender] = add(_balances[msg.sender], wad);\r\n        _supply = add(_supply, wad);\r\n    }\r\n    function burn(uint128 wad) auth stoppable note {\r\n        _balances[msg.sender] = sub(_balances[msg.sender], wad);\r\n        _supply = sub(_supply, wad);\r\n    }\r\n\r\n    \/\/ Optional token name\r\n\r\n    bytes32   public  name = \"\";\r\n    \r\n    function setName(bytes32 name_) auth {\r\n        name = name_;\r\n    }\r\n\r\n}",
      "officialLinks": {
        "Reddit": "",
        "Telegram": "https:\/\/t.me\/joinchat\/AAAAAEQbOeucnaMWN0A9dQ",
        "Website": "https:\/\/eos.io\/",
        "Email": "mailto:eos@block.one",
        "Twitter": "https:\/\/twitter.com\/eos_io"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x86fa049857e0209aa7d9e616f7eb3b3b78ecfdb0#code"
    }, {
      "contractId": 2,
      "title": "TronToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Tronix",
      "code": "pragma solidity ^0.4.11;\r\n\r\ncontract TronToken {\r\n\r\n    string public name = \"Tronix\";      \/\/  token name\r\n    string public symbol = \"TRX\";           \/\/  token symbol\r\n    uint256 public decimals = 6;            \/\/  token digit\r\n\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    uint256 public totalSupply = 0;\r\n    bool public stopped = false;\r\n\r\n    uint256 constant valueFounder = 100000000000000000;\r\n    address owner = 0x0;\r\n\r\n    modifier isOwner {\r\n        assert(owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier isRunning {\r\n        assert (!stopped);\r\n        _;\r\n    }\r\n\r\n    modifier validAddress {\r\n        assert(0x0 != msg.sender);\r\n        _;\r\n    }\r\n\r\n    function TronToken(address _addressFounder) {\r\n        owner = msg.sender;\r\n        totalSupply = valueFounder;\r\n        balanceOf[_addressFounder] = valueFounder;\r\n        Transfer(0x0, _addressFounder, valueFounder);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) isRunning validAddress returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value);\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\r\n        balanceOf[msg.sender] -= _value;\r\n        balanceOf[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) isRunning validAddress returns (bool success) {\r\n        require(balanceOf[_from] >= _value);\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\r\n        require(allowance[_from][msg.sender] >= _value);\r\n        balanceOf[_to] += _value;\r\n        balanceOf[_from] -= _value;\r\n        allowance[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) isRunning validAddress returns (bool success) {\r\n        require(_value == 0 || allowance[msg.sender][_spender] == 0);\r\n        allowance[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function stop() isOwner {\r\n        stopped = true;\r\n    }\r\n\r\n    function start() isOwner {\r\n        stopped = false;\r\n    }\r\n\r\n    function setName(string _name) isOwner {\r\n        name = _name;\r\n    }\r\n\r\n    function burn(uint256 _value) {\r\n        require(balanceOf[msg.sender] >= _value);\r\n        balanceOf[msg.sender] -= _value;\r\n        balanceOf[0x0] += _value;\r\n        Transfer(msg.sender, 0x0, _value);\r\n    }\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}",
      "officialLinks": {
        "Reddit": "",
        "Telegram": "https:\/\/t.me\/joinchat\/GIjGvkK7dhnO8gapCPfqew",
        "Website": "https:\/\/tron.network\/",
        "Email": "mailto:service@tronlab.com",
        "Twitter": "https:\/\/twitter.com\/tronfoundation"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xf230b790e05390fc8295f4d3f60332c93bed42e2#code"
    }, {
      "contractId": 3,
      "title": "OMGToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "OmiseGo",
      "code": "pragma solidity ^0.4.11;\r\n\r\n\r\n\/**\r\n * Math operations with safety checks\r\n *\/\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\n    uint c = a \/ b;\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n *\/\r\ncontract ERC20Basic {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function transfer(address to, uint value);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\n\r\n\/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n *\/\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint;\r\n\r\n  mapping(address => uint) balances;\r\n\r\n  \/**\r\n   * @dev Fix for the ERC20 short address attack.\r\n   *\/\r\n  modifier onlyPayloadSize(uint size) {\r\n     if(msg.data.length < size + 4) {\r\n       throw;\r\n     }\r\n     _;\r\n  }\r\n\r\n  \/**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  *\/\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n  }\r\n\r\n  \/**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint representing the amount owned by the passed address.\r\n  *\/\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n\r\n\/**\r\n * @title ERC20 interface\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n *\/\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n  function transferFrom(address from, address to, uint value);\r\n  function approve(address spender, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n\/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implemantation of the basic standart token.\r\n * @dev https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n * @dev Based on code by FirstBlood: https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\n *\/\r\ncontract StandardToken is BasicToken, ERC20 {\r\n\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n\r\n  \/**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint the amout of tokens to be transfered\r\n   *\/\r\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    \/\/ Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    \/\/ if (_value > _allowance) throw;\r\n\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n  }\r\n\r\n  \/**\r\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   *\/\r\n  function approve(address _spender, uint _value) {\r\n\r\n    \/\/ To change the approve amount you first have to reduce the addresses`\r\n    \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    \/\/  already 0 to mitigate the race condition described here:\r\n    \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n  }\r\n\r\n  \/**\r\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint specifing the amount of tokens still avaible for the spender.\r\n   *\/\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n\r\n\/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n *\/\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  \/**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   *\/\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  \/**\r\n   * @dev Throws if called by any account other than the owner.\r\n   *\/\r\n  modifier onlyOwner() {\r\n    if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n\r\n  \/**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   *\/\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n\/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * @dev Issue: * https:\/\/github.com\/OpenZeppelin\/zeppelin-solidity\/issues\/120\r\n * Based on code by TokenMarketNet: https:\/\/github.com\/TokenMarketNet\/ico\/blob\/master\/contracts\/MintableToken.sol\r\n *\/\r\n\r\ncontract MintableToken is StandardToken, Ownable {\r\n  event Mint(address indexed to, uint value);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n  uint public totalSupply = 0;\r\n\r\n\r\n  modifier canMint() {\r\n    if(mintingFinished) throw;\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will recieve the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   *\/\r\n  function mint(address _to, uint _amount) onlyOwner canMint returns (bool) {\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   *\/\r\n  function finishMinting() onlyOwner returns (bool) {\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\n\/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n *\/\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  \/**\r\n   * @dev modifier to allow actions only when the contract IS paused\r\n   *\/\r\n  modifier whenNotPaused() {\r\n    if (paused) throw;\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev modifier to allow actions only when the contract IS NOT paused\r\n   *\/\r\n  modifier whenPaused {\r\n    if (!paused) throw;\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   *\/\r\n  function pause() onlyOwner whenNotPaused returns (bool) {\r\n    paused = true;\r\n    Pause();\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   *\/\r\n  function unpause() onlyOwner whenPaused returns (bool) {\r\n    paused = false;\r\n    Unpause();\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\n\/**\r\n * Pausable token\r\n *\r\n * Simple ERC20 Token example, with pausable token creation\r\n **\/\r\n\r\ncontract PausableToken is StandardToken, Pausable {\r\n\r\n  function transfer(address _to, uint _value) whenNotPaused {\r\n    super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) whenNotPaused {\r\n    super.transferFrom(_from, _to, _value);\r\n  }\r\n}\r\n\r\n\r\n\/**\r\n * @title TokenTimelock\r\n * @dev TokenTimelock is a token holder contract that will allow a\r\n * beneficiary to extract the tokens after a time has passed\r\n *\/\r\ncontract TokenTimelock {\r\n\r\n  \/\/ ERC20 basic token contract being held\r\n  ERC20Basic token;\r\n\r\n  \/\/ beneficiary of tokens after they are released\r\n  address beneficiary;\r\n\r\n  \/\/ timestamp where token release is enabled\r\n  uint releaseTime;\r\n\r\n  function TokenTimelock(ERC20Basic _token, address _beneficiary, uint _releaseTime) {\r\n    require(_releaseTime > now);\r\n    token = _token;\r\n    beneficiary = _beneficiary;\r\n    releaseTime = _releaseTime;\r\n  }\r\n\r\n  \/**\r\n   * @dev beneficiary claims tokens held by time lock\r\n   *\/\r\n  function claim() {\r\n    require(msg.sender == beneficiary);\r\n    require(now >= releaseTime);\r\n\r\n    uint amount = token.balanceOf(this);\r\n    require(amount > 0);\r\n\r\n    token.transfer(beneficiary, amount);\r\n  }\r\n}\r\n\r\n\r\n\/**\r\n * @title OMGToken\r\n * @dev Omise Go Token contract\r\n *\/\r\ncontract OMGToken is PausableToken, MintableToken {\r\n  using SafeMath for uint256;\r\n\r\n  string public name = \"OMGToken\";\r\n  string public symbol = \"OMG\";\r\n  uint public decimals = 18;\r\n\r\n  \/**\r\n   * @dev mint timelocked tokens\r\n   *\/\r\n  function mintTimelocked(address _to, uint256 _amount, uint256 _releaseTime)\r\n    onlyOwner canMint returns (TokenTimelock) {\r\n\r\n    TokenTimelock timelock = new TokenTimelock(this, _to, _releaseTime);\r\n    mint(timelock, _amount);\r\n\r\n    return timelock;\r\n  }\r\n\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/omise_go\/",
        "Telegram": "",
        "Website": "https:\/\/omisego.network\/",
        "Email": "mailto:omg@omise.co",
        "Twitter": "https:\/\/twitter.com\/omise_go"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xd26114cd6ee289accf82350c8d8487fedb8a0c07#code"
    }, {
      "contractId": 4,
      "title": "GolemNetworkToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Golem",
      "code": "pragma solidity ^0.4.4;\r\n\r\n\r\n\/\/\/ @title Golem Network Token (GNT) - crowdfunding code for Golem Project\r\ncontract GolemNetworkToken {\r\n    string public constant name = \"Golem Network Token\";\r\n    string public constant symbol = \"GNT\";\r\n    uint8 public constant decimals = 18;  \/\/ 18 decimal places, the same as ETH.\r\n\r\n    uint256 public constant tokenCreationRate = 1000;\r\n\r\n    \/\/ The funding cap in weis.\r\n    uint256 public constant tokenCreationCap = 820000 ether * tokenCreationRate;\r\n    uint256 public constant tokenCreationMin = 150000 ether * tokenCreationRate;\r\n\r\n    uint256 public fundingStartBlock;\r\n    uint256 public fundingEndBlock;\r\n\r\n    \/\/ The flag indicates if the GNT contract is in Funding state.\r\n    bool public funding = true;\r\n\r\n    \/\/ Receives ETH and its own GNT endowment.\r\n    address public golemFactory;\r\n\r\n    \/\/ Has control over token migration to next version of token.\r\n    address public migrationMaster;\r\n\r\n    GNTAllocation lockedAllocation;\r\n\r\n    \/\/ The current total token supply.\r\n    uint256 totalTokens;\r\n\r\n    mapping (address => uint256) balances;\r\n\r\n    address public migrationAgent;\r\n    uint256 public totalMigrated;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\r\n    event Refund(address indexed _from, uint256 _value);\r\n\r\n    function GolemNetworkToken(address _golemFactory,\r\n                               address _migrationMaster,\r\n                               uint256 _fundingStartBlock,\r\n                               uint256 _fundingEndBlock) {\r\n\r\n        if (_golemFactory == 0) throw;\r\n        if (_migrationMaster == 0) throw;\r\n        if (_fundingStartBlock <= block.number) throw;\r\n        if (_fundingEndBlock   <= _fundingStartBlock) throw;\r\n\r\n        lockedAllocation = new GNTAllocation(_golemFactory);\r\n        migrationMaster = _migrationMaster;\r\n        golemFactory = _golemFactory;\r\n        fundingStartBlock = _fundingStartBlock;\r\n        fundingEndBlock = _fundingEndBlock;\r\n    }\r\n\r\n    \/\/\/ @notice Transfer `_value` GNT tokens from sender's account\r\n    \/\/\/ `msg.sender` to provided account address `_to`.\r\n    \/\/\/ @notice This function is disabled during the funding.\r\n    \/\/\/ @dev Required state: Operational\r\n    \/\/\/ @param _to The address of the tokens recipient\r\n    \/\/\/ @param _value The amount of token to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool) {\r\n        \/\/ Abort if not in Operational state.\r\n        if (funding) throw;\r\n\r\n        var senderBalance = balances[msg.sender];\r\n        if (senderBalance >= _value && _value > 0) {\r\n            senderBalance -= _value;\r\n            balances[msg.sender] = senderBalance;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function totalSupply() external constant returns (uint256) {\r\n        return totalTokens;\r\n    }\r\n\r\n    function balanceOf(address _owner) external constant returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    \/\/ Token migration support:\r\n\r\n    \/\/\/ @notice Migrate tokens to the new token contract.\r\n    \/\/\/ @dev Required state: Operational Migration\r\n    \/\/\/ @param _value The amount of token to be migrated\r\n    function migrate(uint256 _value) external {\r\n        \/\/ Abort if not in Operational Migration state.\r\n        if (funding) throw;\r\n        if (migrationAgent == 0) throw;\r\n\r\n        \/\/ Validate input value.\r\n        if (_value == 0) throw;\r\n        if (_value > balances[msg.sender]) throw;\r\n\r\n        balances[msg.sender] -= _value;\r\n        totalTokens -= _value;\r\n        totalMigrated += _value;\r\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\r\n        Migrate(msg.sender, migrationAgent, _value);\r\n    }\r\n\r\n    \/\/\/ @notice Set address of migration target contract and enable migration\r\n\t\/\/\/ process.\r\n    \/\/\/ @dev Required state: Operational Normal\r\n    \/\/\/ @dev State transition: -> Operational Migration\r\n    \/\/\/ @param _agent The address of the MigrationAgent contract\r\n    function setMigrationAgent(address _agent) external {\r\n        \/\/ Abort if not in Operational Normal state.\r\n        if (funding) throw;\r\n        if (migrationAgent != 0) throw;\r\n        if (msg.sender != migrationMaster) throw;\r\n        migrationAgent = _agent;\r\n    }\r\n\r\n    function setMigrationMaster(address _master) external {\r\n        if (msg.sender != migrationMaster) throw;\r\n        if (_master == 0) throw;\r\n        migrationMaster = _master;\r\n    }\r\n\r\n    \/\/ Crowdfunding:\r\n\r\n    \/\/\/ @notice Create tokens when funding is active.\r\n    \/\/\/ @dev Required state: Funding Active\r\n    \/\/\/ @dev State transition: -> Funding Success (only if cap reached)\r\n    function create() payable external {\r\n        \/\/ Abort if not in Funding Active state.\r\n        \/\/ The checks are split (instead of using or operator) because it is\r\n        \/\/ cheaper this way.\r\n        if (!funding) throw;\r\n        if (block.number < fundingStartBlock) throw;\r\n        if (block.number > fundingEndBlock) throw;\r\n\r\n        \/\/ Do not allow creating 0 or more than the cap tokens.\r\n        if (msg.value == 0) throw;\r\n        if (msg.value > (tokenCreationCap - totalTokens) \/ tokenCreationRate)\r\n            throw;\r\n\r\n        var numTokens = msg.value * tokenCreationRate;\r\n        totalTokens += numTokens;\r\n\r\n        \/\/ Assign new tokens to the sender\r\n        balances[msg.sender] += numTokens;\r\n\r\n        \/\/ Log token creation event\r\n        Transfer(0, msg.sender, numTokens);\r\n    }\r\n\r\n    \/\/\/ @notice Finalize crowdfunding\r\n    \/\/\/ @dev If cap was reached or crowdfunding has ended then:\r\n    \/\/\/ create GNT for the Golem Factory and developer,\r\n    \/\/\/ transfer ETH to the Golem Factory address.\r\n    \/\/\/ @dev Required state: Funding Success\r\n    \/\/\/ @dev State transition: -> Operational Normal\r\n    function finalize() external {\r\n        \/\/ Abort if not in Funding Success state.\r\n        if (!funding) throw;\r\n        if ((block.number <= fundingEndBlock ||\r\n             totalTokens < tokenCreationMin) &&\r\n            totalTokens < tokenCreationCap) throw;\r\n\r\n        \/\/ Switch to Operational state. This is the only place this can happen.\r\n        funding = false;\r\n\r\n        \/\/ Create additional GNT for the Golem Factory and developers as\r\n        \/\/ the 18% of total number of tokens.\r\n        \/\/ All additional tokens are transfered to the account controller by\r\n        \/\/ GNTAllocation contract which will not allow using them for 6 months.\r\n        uint256 percentOfTotal = 18;\r\n        uint256 additionalTokens =\r\n            totalTokens * percentOfTotal \/ (100 - percentOfTotal);\r\n        totalTokens += additionalTokens;\r\n        balances[lockedAllocation] += additionalTokens;\r\n        Transfer(0, lockedAllocation, additionalTokens);\r\n\r\n        \/\/ Transfer ETH to the Golem Factory address.\r\n        if (!golemFactory.send(this.balance)) throw;\r\n    }\r\n\r\n    \/\/\/ @notice Get back the ether sent during the funding in case the funding\r\n    \/\/\/ has not reached the minimum level.\r\n    \/\/\/ @dev Required state: Funding Failure\r\n    function refund() external {\r\n        \/\/ Abort if not in Funding Failure state.\r\n        if (!funding) throw;\r\n        if (block.number <= fundingEndBlock) throw;\r\n        if (totalTokens >= tokenCreationMin) throw;\r\n\r\n        var gntValue = balances[msg.sender];\r\n        if (gntValue == 0) throw;\r\n        balances[msg.sender] = 0;\r\n        totalTokens -= gntValue;\r\n\r\n        var ethValue = gntValue \/ tokenCreationRate;\r\n        Refund(msg.sender, ethValue);\r\n        if (!msg.sender.send(ethValue)) throw;\r\n    }\r\n}\r\n\r\n\r\n\/\/\/ @title Migration Agent interface\r\ncontract MigrationAgent {\r\n    function migrateFrom(address _from, uint256 _value);\r\n}\r\n\r\n\r\n\/\/\/ @title GNT Allocation - Time-locked vault of tokens allocated\r\n\/\/\/ to developers and Golem Factory\r\ncontract GNTAllocation {\r\n    \/\/ Total number of allocations to distribute additional tokens among\r\n    \/\/ developers and the Golem Factory. The Golem Factory has right to 20000\r\n    \/\/ allocations, developers to 10000 allocations, divides among individual\r\n    \/\/ developers by numbers specified in  `allocations` table.\r\n    uint256 constant totalAllocations = 30000;\r\n\r\n    \/\/ Addresses of developer and the Golem Factory to allocations mapping.\r\n    mapping (address => uint256) allocations;\r\n\r\n    GolemNetworkToken gnt;\r\n    uint256 unlockedAt;\r\n\r\n    uint256 tokensCreated = 0;\r\n\r\n    function GNTAllocation(address _golemFactory) internal {\r\n        gnt = GolemNetworkToken(msg.sender);\r\n        unlockedAt = now + 6 * 30 days;\r\n\r\n        \/\/ For the Golem Factory:\r\n        allocations[_golemFactory] = 20000; \/\/ 12\/18 pp of 30000 allocations.\r\n\r\n        \/\/ For developers:\r\n        allocations[0x9d3F257827B17161a098d380822fa2614FF540c8] = 2500; \/\/ 25.0% of developers' allocations (10000).\r\n        allocations[0xd7406E50b73972Fa4aa533a881af68B623Ba3F66] =  730; \/\/  7.3% of developers' allocations.\r\n        allocations[0xd15356D05A7990dE7eC94304B0fD538e550c09C0] =  730;\r\n        allocations[0x3971D17B62b825b151760E2451F818BfB64489A7] =  730;\r\n        allocations[0x95e337d09f1bc67681b1cab7ed1125ea2bae5ca8] =  730;\r\n        allocations[0x0025C58dB686b8CEce05CB8c50C1858b63Aa396E] =  730;\r\n        allocations[0xB127FC62dE6ca30aAc9D551591daEDdeBB2eFD7A] =  630; \/\/  6.3% of developers' allocations.\r\n        allocations[0x21AF2E2c240a71E9fB84e90d71c2B2AddE0D0e81] =  630;\r\n        allocations[0x682AA1C3b3E102ACB9c97B861d595F9fbfF0f1B8] =  630;\r\n        allocations[0x6edd429c77803606cBd6Bb501CC701a6CAD6be01] =  630;\r\n        allocations[0x5E455624372FE11b39464e93d41D1F6578c3D9f6] =  310; \/\/  3.1% of developers' allocations.\r\n        allocations[0xB7c7EaD515Ca275d53e30B39D8EBEdb3F19dA244] =  138; \/\/  1.38% of developers' allocations.\r\n        allocations[0xD513b1c3fe31F3Fe0b1E42aa8F55e903F19f1730] =  135; \/\/  1.35% of developers' allocations.\r\n        allocations[0x70cac7f8E404EEFce6526823452e428b5Ab09b00] =  100; \/\/  1.0% of developers' allocations.\r\n        allocations[0xe0d5861e7be0fac6c85ecde6e8bf76b046a96149] =  100;\r\n        allocations[0x17488694D2feE4377Ec718836bb9d4910E81D9Cf] =  100;\r\n        allocations[0xb481372086dEc3ca2FCCD3EB2f462c9C893Ef3C5] =  100;\r\n        allocations[0xFB6D91E69CD7990651f26a3aa9f8d5a89159fC92] =   70; \/\/  0.7% of developers' allocations.\r\n        allocations[0xE2ABdAe2980a1447F445cb962f9c0bef1B63EE13] =   70;\r\n        allocations[0x729A5c0232712caAf365fDd03c39cb361Bd41b1C] =   70;\r\n        allocations[0x12FBD8fef4903f62e30dD79AC7F439F573E02697] =   70;\r\n        allocations[0x657013005e5cFAF76f75d03b465cE085d402469A] =   42; \/\/  0.42% of developers' allocations.\r\n        allocations[0xD0AF9f75EA618163944585bF56aCA98204d0AB66] =   25; \/\/  0.25% of developers' allocations.\r\n    }\r\n\r\n    \/\/\/ @notice Allow developer to unlock allocated tokens by transferring them\r\n    \/\/\/ from GNTAllocation to developer's address.\r\n    function unlock() external {\r\n        if (now < unlockedAt) throw;\r\n\r\n        \/\/ During first unlock attempt fetch total number of locked tokens.\r\n        if (tokensCreated == 0)\r\n            tokensCreated = gnt.balanceOf(this);\r\n\r\n        var allocation = allocations[msg.sender];\r\n        allocations[msg.sender] = 0;\r\n        var toTransfer = tokensCreated * allocation \/ totalAllocations;\r\n\r\n        \/\/ Will fail if allocation (and therefore toTransfer) is 0.\r\n        if (!gnt.transfer(msg.sender, toTransfer)) throw;\r\n    }\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/GolemProject\/",
        "Telegram": "",
        "Website": "https:\/\/golem.network\/",
        "Email": "mailto:contact@golemproject.net",
        "Twitter": "https:\/\/twitter.com\/golemproject"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xa74476443119a942de498590fe1f2454d7d4ac0d#code"
    }, {
      "contractId": 5,
      "title": "SNT",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "StatusNetwork",
      "code": "pragma solidity ^0.4.11;\r\n\r\n\r\n\/\/\/ @dev `Owned` is a base level contract that assigns an `owner` that can be\r\n\/\/\/  later changed\r\ncontract Owned {\r\n\r\n    \/\/\/ @dev `owner` is the only address that can call a function with this\r\n    \/\/\/ modifier\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    address public owner;\r\n\r\n    \/\/\/ @notice The Constructor assigns the message sender to be `owner`\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    address public newOwner;\r\n\r\n    \/\/\/ @notice `owner` can step down and assign some other address to this role\r\n    \/\/\/ @param _newOwner The address of the new owner. 0x0 can be used to create\r\n    \/\/\/  an unowned neutral vault, however that cannot be undone\r\n    function changeOwner(address _newOwner) onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n\r\n    function acceptOwnership() {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\n\/\/ Abstract contract for the full ERC 20 Token standard\r\n\/\/ https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n\r\ncontract ERC20Token {\r\n    \/* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    *\/\r\n    \/\/\/ total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    \/\/\/ @param _owner The address from which the balance will be retrieved\r\n    \/\/\/ @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    \/\/\/ @notice send `_value` token to `_to` from `msg.sender`\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _value The amount of token to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    \/\/\/ @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    \/\/\/ @param _from The address of the sender\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _value The amount of token to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    \/\/\/ @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @param _value The amount of tokens to be approved for transfer\r\n    \/\/\/ @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    \/\/\/ @param _owner The address of the account owning tokens\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n\r\n\/**\r\n * Math operations with safety checks\r\n *\/\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\n    uint c = a \/ b;\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n\r\n\/*\r\n    Copyright 2017, Jordi Baylina\r\n\r\n    This program is free software: you can redistribute it and\/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\r\n *\/\r\n\r\n\/\/\/ @title DynamicCeiling Contract\r\n\/\/\/ @author Jordi Baylina\r\n\/\/\/ @dev This contract calculates the ceiling from a series of curves.\r\n\/\/\/  These curves are committed first and revealed later.\r\n\/\/\/  All the curves must be in increasing order and the last curve is marked\r\n\/\/\/  as the last one.\r\n\/\/\/  This contract allows to hide and reveal the ceiling at will of the owner.\r\n\r\n\r\n\r\ncontract DynamicCeiling is Owned {\r\n    using SafeMath for uint256;\r\n\r\n    struct Curve {\r\n        bytes32 hash;\r\n        \/\/ Absolute limit for this curve\r\n        uint256 limit;\r\n        \/\/ The funds remaining to be collected are divided by `slopeFactor` smooth ceiling\r\n        \/\/ with a long tail where big and small buyers can take part.\r\n        uint256 slopeFactor;\r\n        \/\/ This keeps the curve flat at this number, until funds to be collected is less than this\r\n        uint256 collectMinimum;\r\n    }\r\n\r\n    address public contribution;\r\n\r\n    Curve[] public curves;\r\n    uint256 public currentIndex;\r\n    uint256 public revealedCurves;\r\n    bool public allRevealed;\r\n\r\n    \/\/\/ @dev `contribution` is the only address that can call a function with this\r\n    \/\/\/ modifier\r\n    modifier onlyContribution {\r\n        require(msg.sender == contribution);\r\n        _;\r\n    }\r\n\r\n    function DynamicCeiling(address _owner, address _contribution) {\r\n        owner = _owner;\r\n        contribution = _contribution;\r\n    }\r\n\r\n    \/\/\/ @notice This should be called by the creator of the contract to commit\r\n    \/\/\/  all the curves.\r\n    \/\/\/ @param _curveHashes Array of hashes of each curve. Each hash is calculated\r\n    \/\/\/  by the `calculateHash` method. More hashes than actual curves can be\r\n    \/\/\/  committed in order to hide also the number of curves.\r\n    \/\/\/  The remaining hashes can be just random numbers.\r\n    function setHiddenCurves(bytes32[] _curveHashes) public onlyOwner {\r\n        require(curves.length == 0);\r\n\r\n        curves.length = _curveHashes.length;\r\n        for (uint256 i = 0; i < _curveHashes.length; i = i.add(1)) {\r\n            curves[i].hash = _curveHashes[i];\r\n        }\r\n    }\r\n\r\n\r\n    \/\/\/ @notice Anybody can reveal the next curve if he knows it.\r\n    \/\/\/ @param _limit Ceiling cap.\r\n    \/\/\/  (must be greater or equal to the previous one).\r\n    \/\/\/ @param _last `true` if it's the last curve.\r\n    \/\/\/ @param _salt Random number used to commit the curve\r\n    function revealCurve(uint256 _limit, uint256 _slopeFactor, uint256 _collectMinimum,\r\n                         bool _last, bytes32 _salt) public {\r\n        require(!allRevealed);\r\n\r\n        require(curves[revealedCurves].hash == calculateHash(_limit, _slopeFactor, _collectMinimum,\r\n                                                             _last, _salt));\r\n\r\n        require(_limit != 0 && _slopeFactor != 0 && _collectMinimum != 0);\r\n        if (revealedCurves > 0) {\r\n            require(_limit >= curves[revealedCurves.sub(1)].limit);\r\n        }\r\n\r\n        curves[revealedCurves].limit = _limit;\r\n        curves[revealedCurves].slopeFactor = _slopeFactor;\r\n        curves[revealedCurves].collectMinimum = _collectMinimum;\r\n        revealedCurves = revealedCurves.add(1);\r\n\r\n        if (_last) allRevealed = true;\r\n    }\r\n\r\n    \/\/\/ @notice Reveal multiple curves at once\r\n    function revealMulti(uint256[] _limits, uint256[] _slopeFactors, uint256[] _collectMinimums,\r\n                         bool[] _lasts, bytes32[] _salts) public {\r\n        \/\/ Do not allow none and needs to be same length for all parameters\r\n        require(_limits.length != 0 &&\r\n                _limits.length == _slopeFactors.length &&\r\n                _limits.length == _collectMinimums.length &&\r\n                _limits.length == _lasts.length &&\r\n                _limits.length == _salts.length);\r\n\r\n        for (uint256 i = 0; i < _limits.length; i = i.add(1)) {\r\n            revealCurve(_limits[i], _slopeFactors[i], _collectMinimums[i],\r\n                        _lasts[i], _salts[i]);\r\n        }\r\n    }\r\n\r\n    \/\/\/ @notice Move to curve, used as a failsafe\r\n    function moveTo(uint256 _index) public onlyOwner {\r\n        require(_index < revealedCurves &&       \/\/ No more curves\r\n                _index == currentIndex.add(1));  \/\/ Only move one index at a time\r\n        currentIndex = _index;\r\n    }\r\n\r\n    \/\/\/ @return Return the funds to collect for the current point on the curve\r\n    \/\/\/  (or 0 if no curves revealed yet)\r\n    function toCollect(uint256 collected) public onlyContribution returns (uint256) {\r\n        if (revealedCurves == 0) return 0;\r\n\r\n        \/\/ Move to the next curve\r\n        if (collected >= curves[currentIndex].limit) {  \/\/ Catches `limit == 0`\r\n            uint256 nextIndex = currentIndex.add(1);\r\n            if (nextIndex >= revealedCurves) return 0;  \/\/ No more curves\r\n            currentIndex = nextIndex;\r\n            if (collected >= curves[currentIndex].limit) return 0;  \/\/ Catches `limit == 0`\r\n        }\r\n\r\n        \/\/ Everything left to collect from this limit\r\n        uint256 difference = curves[currentIndex].limit.sub(collected);\r\n\r\n        \/\/ Current point on the curve\r\n        uint256 collect = difference.div(curves[currentIndex].slopeFactor);\r\n\r\n        \/\/ Prevents paying too much fees vs to be collected; breaks long tail\r\n        if (collect <= curves[currentIndex].collectMinimum) {\r\n            if (difference > curves[currentIndex].collectMinimum) {\r\n                return curves[currentIndex].collectMinimum;\r\n            } else {\r\n                return difference;\r\n            }\r\n        } else {\r\n            return collect;\r\n        }\r\n    }\r\n\r\n    \/\/\/ @notice Calculates the hash of a curve.\r\n    \/\/\/ @param _limit Ceiling cap.\r\n    \/\/\/ @param _last `true` if it's the last curve.\r\n    \/\/\/ @param _salt Random number that will be needed to reveal this curve.\r\n    \/\/\/ @return The calculated hash of this curve to be used in the `setHiddenCurves` method\r\n    function calculateHash(uint256 _limit, uint256 _slopeFactor, uint256 _collectMinimum,\r\n                           bool _last, bytes32 _salt) public constant returns (bytes32) {\r\n        return keccak256(_limit, _slopeFactor, _collectMinimum, _last, _salt);\r\n    }\r\n\r\n    \/\/\/ @return Return the total number of curves committed\r\n    \/\/\/  (can be larger than the number of actual curves on the curve to hide\r\n    \/\/\/  the real number of curves)\r\n    function nCurves() public constant returns (uint256) {\r\n        return curves.length;\r\n    }\r\n\r\n}\r\n\r\n\r\n\/*\r\n    Copyright 2016, Jordi Baylina\r\n\r\n    This program is free software: you can redistribute it and\/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\r\n *\/\r\n\r\n\/\/\/ @title MiniMeToken Contract\r\n\/\/\/ @author Jordi Baylina\r\n\/\/\/ @dev This token contract's goal is to make it easy for anyone to clone this\r\n\/\/\/  token using the token distribution at a given block, this will allow DAO's\r\n\/\/\/  and DApps to upgrade their features in a decentralized manner without\r\n\/\/\/  affecting the original token\r\n\/\/\/ @dev It is ERC20 compliant, but still needs to under go further testing.\r\n\r\n\r\n\/\/\/ @dev The token controller contract must implement these functions\r\ncontract TokenController {\r\n    \/\/\/ @notice Called when `_owner` sends ether to the MiniMe Token contract\r\n    \/\/\/ @param _owner The address that sent the ether to create tokens\r\n    \/\/\/ @return True if the ether is accepted, false if it throws\r\n    function proxyPayment(address _owner) payable returns(bool);\r\n\r\n    \/\/\/ @notice Notifies the controller about a token transfer allowing the\r\n    \/\/\/  controller to react if desired\r\n    \/\/\/ @param _from The origin of the transfer\r\n    \/\/\/ @param _to The destination of the transfer\r\n    \/\/\/ @param _amount The amount of the transfer\r\n    \/\/\/ @return False if the controller does not authorize the transfer\r\n    function onTransfer(address _from, address _to, uint _amount) returns(bool);\r\n\r\n    \/\/\/ @notice Notifies the controller about an approval allowing the\r\n    \/\/\/  controller to react if desired\r\n    \/\/\/ @param _owner The address that calls `approve()`\r\n    \/\/\/ @param _spender The spender in the `approve()` call\r\n    \/\/\/ @param _amount The amount in the `approve()` call\r\n    \/\/\/ @return False if the controller does not authorize the approval\r\n    function onApprove(address _owner, address _spender, uint _amount)\r\n        returns(bool);\r\n}\r\n\r\ncontract Controlled {\r\n    \/\/\/ @notice The address of the controller is the only address that can call\r\n    \/\/\/  a function with this modifier\r\n    modifier onlyController { if (msg.sender != controller) throw; _; }\r\n\r\n    address public controller;\r\n\r\n    function Controlled() { controller = msg.sender;}\r\n\r\n    \/\/\/ @notice Changes the controller of the contract\r\n    \/\/\/ @param _newController The new controller of the contract\r\n    function changeController(address _newController) onlyController {\r\n        controller = _newController;\r\n    }\r\n}\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 _amount, address _token, bytes _data);\r\n}\r\n\r\n\/\/\/ @dev The actual token contract, the default controller is the msg.sender\r\n\/\/\/  that deploys the contract, so usually this token will be deployed by a\r\n\/\/\/  token controller contract, which Giveth will call a \"Campaign\"\r\ncontract MiniMeToken is Controlled {\r\n\r\n    string public name;                \/\/The Token's name: e.g. DigixDAO Tokens\r\n    uint8 public decimals;             \/\/Number of decimals of the smallest unit\r\n    string public symbol;              \/\/An identifier: e.g. REP\r\n    string public version = 'MMT_0.1'; \/\/An arbitrary versioning scheme\r\n\r\n\r\n    \/\/\/ @dev `Checkpoint` is the structure that attaches a block number to a\r\n    \/\/\/  given value, the block number attached is the one that last changed the\r\n    \/\/\/  value\r\n    struct  Checkpoint {\r\n\r\n        \/\/ `fromBlock` is the block number that the value was generated from\r\n        uint128 fromBlock;\r\n\r\n        \/\/ `value` is the amount of tokens at a specific block number\r\n        uint128 value;\r\n    }\r\n\r\n    \/\/ `parentToken` is the Token address that was cloned to produce this token;\r\n    \/\/  it will be 0x0 for a token that was not cloned\r\n    MiniMeToken public parentToken;\r\n\r\n    \/\/ `parentSnapShotBlock` is the block number from the Parent Token that was\r\n    \/\/  used to determine the initial distribution of the Clone Token\r\n    uint public parentSnapShotBlock;\r\n\r\n    \/\/ `creationBlock` is the block number that the Clone Token was created\r\n    uint public creationBlock;\r\n\r\n    \/\/ `balances` is the map that tracks the balance of each address, in this\r\n    \/\/  contract when the balance changes the block number that the change\r\n    \/\/  occurred is also included in the map\r\n    mapping (address => Checkpoint[]) balances;\r\n\r\n    \/\/ `allowed` tracks any extra transfer rights as in all ERC20 tokens\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    \/\/ Tracks the history of the `totalSupply` of the token\r\n    Checkpoint[] totalSupplyHistory;\r\n\r\n    \/\/ Flag that determines if the token is transferable or not.\r\n    bool public transfersEnabled;\r\n\r\n    \/\/ The factory used to create new clone tokens\r\n    MiniMeTokenFactory public tokenFactory;\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Constructor\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice Constructor to create a MiniMeToken\r\n    \/\/\/ @param _tokenFactory The address of the MiniMeTokenFactory contract that\r\n    \/\/\/  will create the Clone token contracts, the token factory needs to be\r\n    \/\/\/  deployed first\r\n    \/\/\/ @param _parentToken Address of the parent token, set to 0x0 if it is a\r\n    \/\/\/  new token\r\n    \/\/\/ @param _parentSnapShotBlock Block of the parent token that will\r\n    \/\/\/  determine the initial distribution of the clone token, set to 0 if it\r\n    \/\/\/  is a new token\r\n    \/\/\/ @param _tokenName Name of the new token\r\n    \/\/\/ @param _decimalUnits Number of decimals of the new token\r\n    \/\/\/ @param _tokenSymbol Token Symbol for the new token\r\n    \/\/\/ @param _transfersEnabled If true, tokens will be able to be transferred\r\n    function MiniMeToken(\r\n        address _tokenFactory,\r\n        address _parentToken,\r\n        uint _parentSnapShotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    ) {\r\n        tokenFactory = MiniMeTokenFactory(_tokenFactory);\r\n        name = _tokenName;                                 \/\/ Set the name\r\n        decimals = _decimalUnits;                          \/\/ Set the decimals\r\n        symbol = _tokenSymbol;                             \/\/ Set the symbol\r\n        parentToken = MiniMeToken(_parentToken);\r\n        parentSnapShotBlock = _parentSnapShotBlock;\r\n        transfersEnabled = _transfersEnabled;\r\n        creationBlock = getBlockNumber();\r\n    }\r\n\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ ERC20 Methods\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice Send `_amount` tokens to `_to` from `msg.sender`\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _amount The amount of tokens to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _amount) returns (bool success) {\r\n        if (!transfersEnabled) throw;\r\n        return doTransfer(msg.sender, _to, _amount);\r\n    }\r\n\r\n    \/\/\/ @notice Send `_amount` tokens to `_to` from `_from` on the condition it\r\n    \/\/\/  is approved by `_from`\r\n    \/\/\/ @param _from The address holding the tokens being transferred\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _amount The amount of tokens to be transferred\r\n    \/\/\/ @return True if the transfer was successful\r\n    function transferFrom(address _from, address _to, uint256 _amount\r\n    ) returns (bool success) {\r\n\r\n        \/\/ The controller of this contract can move tokens around at will,\r\n        \/\/  this is important to recognize! Confirm that you trust the\r\n        \/\/  controller of this contract, which in most situations should be\r\n        \/\/  another open source smart contract or 0x0\r\n        if (msg.sender != controller) {\r\n            if (!transfersEnabled) throw;\r\n\r\n            \/\/ The standard ERC 20 transferFrom functionality\r\n            if (allowed[_from][msg.sender] < _amount) return false;\r\n            allowed[_from][msg.sender] -= _amount;\r\n        }\r\n        return doTransfer(_from, _to, _amount);\r\n    }\r\n\r\n    \/\/\/ @dev This is the actual transfer function in the token contract, it can\r\n    \/\/\/  only be called by other functions in this contract.\r\n    \/\/\/ @param _from The address holding the tokens being transferred\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _amount The amount of tokens to be transferred\r\n    \/\/\/ @return True if the transfer was successful\r\n    function doTransfer(address _from, address _to, uint _amount\r\n    ) internal returns(bool) {\r\n\r\n           if (_amount == 0) {\r\n               return true;\r\n           }\r\n\r\n           if (parentSnapShotBlock >= getBlockNumber()) throw;\r\n\r\n           \/\/ Do not allow transfer to 0x0 or the token contract itself\r\n           if ((_to == 0) || (_to == address(this))) throw;\r\n\r\n           \/\/ If the amount being transfered is more than the balance of the\r\n           \/\/  account the transfer returns false\r\n           var previousBalanceFrom = balanceOfAt(_from, getBlockNumber());\r\n           if (previousBalanceFrom < _amount) {\r\n               return false;\r\n           }\r\n\r\n           \/\/ Alerts the token controller of the transfer\r\n           if (isContract(controller)) {\r\n               if (!TokenController(controller).onTransfer(_from, _to, _amount))\r\n               throw;\r\n           }\r\n\r\n           \/\/ First update the balance array with the new value for the address\r\n           \/\/  sending the tokens\r\n           updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\r\n\r\n           \/\/ Then update the balance array with the new value for the address\r\n           \/\/  receiving the tokens\r\n           var previousBalanceTo = balanceOfAt(_to, getBlockNumber());\r\n           if (previousBalanceTo + _amount < previousBalanceTo) throw; \/\/ Check for overflow\r\n           updateValueAtNow(balances[_to], previousBalanceTo + _amount);\r\n\r\n           \/\/ An event to make the transfer easy to find on the blockchain\r\n           Transfer(_from, _to, _amount);\r\n\r\n           return true;\r\n    }\r\n\r\n    \/\/\/ @param _owner The address that's balance is being requested\r\n    \/\/\/ @return The balance of `_owner` at the current block\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balanceOfAt(_owner, getBlockNumber());\r\n    }\r\n\r\n    \/\/\/ @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\r\n    \/\/\/  its behalf. This is a modified version of the ERC20 approve function\r\n    \/\/\/  to be a little bit safer\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @param _amount The amount of tokens to be approved for transfer\r\n    \/\/\/ @return True if the approval was successful\r\n    function approve(address _spender, uint256 _amount) returns (bool success) {\r\n        if (!transfersEnabled) throw;\r\n\r\n        \/\/ To change the approve amount you first have to reduce the addresses`\r\n        \/\/  allowance to zero by calling `approve(_spender,0)` if it is not\r\n        \/\/  already 0 to mitigate the race condition described here:\r\n        \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\n        if ((_amount!=0) && (allowed[msg.sender][_spender] !=0)) throw;\r\n\r\n        \/\/ Alerts the token controller of the approve function call\r\n        if (isContract(controller)) {\r\n            if (!TokenController(controller).onApprove(msg.sender, _spender, _amount))\r\n                throw;\r\n        }\r\n\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    \/\/\/ @dev This function makes it easy to read the `allowed[]` map\r\n    \/\/\/ @param _owner The address of the account that owns the token\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @return Amount of remaining tokens of _owner that _spender is allowed\r\n    \/\/\/  to spend\r\n    function allowance(address _owner, address _spender\r\n    ) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    \/\/\/ @notice `msg.sender` approves `_spender` to send `_amount` tokens on\r\n    \/\/\/  its behalf, and then a function is triggered in the contract that is\r\n    \/\/\/  being approved, `_spender`. This allows users to use their tokens to\r\n    \/\/\/  interact with contracts in one function call instead of two\r\n    \/\/\/ @param _spender The address of the contract able to transfer the tokens\r\n    \/\/\/ @param _amount The amount of tokens to be approved for transfer\r\n    \/\/\/ @return True if the function call was successful\r\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\r\n    ) returns (bool success) {\r\n        if (!approve(_spender, _amount)) throw;\r\n\r\n        ApproveAndCallFallBack(_spender).receiveApproval(\r\n            msg.sender,\r\n            _amount,\r\n            this,\r\n            _extraData\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    \/\/\/ @dev This function makes it easy to get the total number of tokens\r\n    \/\/\/ @return The total number of tokens\r\n    function totalSupply() constant returns (uint) {\r\n        return totalSupplyAt(getBlockNumber());\r\n    }\r\n\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Query balance and totalSupply in History\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @dev Queries the balance of `_owner` at a specific `_blockNumber`\r\n    \/\/\/ @param _owner The address from which the balance will be retrieved\r\n    \/\/\/ @param _blockNumber The block number when the balance is queried\r\n    \/\/\/ @return The balance at `_blockNumber`\r\n    function balanceOfAt(address _owner, uint _blockNumber) constant\r\n        returns (uint) {\r\n\r\n        \/\/ These next few lines are used when the balance of the token is\r\n        \/\/  requested before a check point was ever created for this token, it\r\n        \/\/  requires that the `parentToken.balanceOfAt` be queried at the\r\n        \/\/  genesis block for that token as this contains initial balance of\r\n        \/\/  this token\r\n        if ((balances[_owner].length == 0)\r\n            || (balances[_owner][0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                \/\/ Has no parent\r\n                return 0;\r\n            }\r\n\r\n        \/\/ This will return the expected balance during normal situations\r\n        } else {\r\n            return getValueAt(balances[_owner], _blockNumber);\r\n        }\r\n    }\r\n\r\n    \/\/\/ @notice Total amount of tokens at a specific `_blockNumber`.\r\n    \/\/\/ @param _blockNumber The block number when the totalSupply is queried\r\n    \/\/\/ @return The total amount of tokens at `_blockNumber`\r\n    function totalSupplyAt(uint _blockNumber) constant returns(uint) {\r\n\r\n        \/\/ These next few lines are used when the totalSupply of the token is\r\n        \/\/  requested before a check point was ever created for this token, it\r\n        \/\/  requires that the `parentToken.totalSupplyAt` be queried at the\r\n        \/\/  genesis block for this token as that contains totalSupply of this\r\n        \/\/  token at this block number.\r\n        if ((totalSupplyHistory.length == 0)\r\n            || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                return 0;\r\n            }\r\n\r\n        \/\/ This will return the expected totalSupply during normal situations\r\n        } else {\r\n            return getValueAt(totalSupplyHistory, _blockNumber);\r\n        }\r\n    }\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Clone Token Method\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice Creates a new clone token with the initial distribution being\r\n    \/\/\/  this token at `_snapshotBlock`\r\n    \/\/\/ @param _cloneTokenName Name of the clone token\r\n    \/\/\/ @param _cloneDecimalUnits Number of decimals of the smallest unit\r\n    \/\/\/ @param _cloneTokenSymbol Symbol of the clone token\r\n    \/\/\/ @param _snapshotBlock Block when the distribution of the parent token is\r\n    \/\/\/  copied to set the initial distribution of the new clone token;\r\n    \/\/\/  if the block is zero than the actual block, the current block is used\r\n    \/\/\/ @param _transfersEnabled True if transfers are allowed in the clone\r\n    \/\/\/ @return The address of the new MiniMeToken Contract\r\n    function createCloneToken(\r\n        string _cloneTokenName,\r\n        uint8 _cloneDecimalUnits,\r\n        string _cloneTokenSymbol,\r\n        uint _snapshotBlock,\r\n        bool _transfersEnabled\r\n        ) returns(address) {\r\n        if (_snapshotBlock == 0) _snapshotBlock = getBlockNumber();\r\n        MiniMeToken cloneToken = tokenFactory.createCloneToken(\r\n            this,\r\n            _snapshotBlock,\r\n            _cloneTokenName,\r\n            _cloneDecimalUnits,\r\n            _cloneTokenSymbol,\r\n            _transfersEnabled\r\n            );\r\n\r\n        cloneToken.changeController(msg.sender);\r\n\r\n        \/\/ An event to make the token easy to find on the blockchain\r\n        NewCloneToken(address(cloneToken), _snapshotBlock);\r\n        return address(cloneToken);\r\n    }\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Generate and destroy tokens\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice Generates `_amount` tokens that are assigned to `_owner`\r\n    \/\/\/ @param _owner The address that will be assigned the new tokens\r\n    \/\/\/ @param _amount The quantity of tokens generated\r\n    \/\/\/ @return True if the tokens are generated correctly\r\n    function generateTokens(address _owner, uint _amount\r\n    ) onlyController returns (bool) {\r\n        uint curTotalSupply = getValueAt(totalSupplyHistory, getBlockNumber());\r\n        if (curTotalSupply + _amount < curTotalSupply) throw; \/\/ Check for overflow\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\r\n        var previousBalanceTo = balanceOf(_owner);\r\n        if (previousBalanceTo + _amount < previousBalanceTo) throw; \/\/ Check for overflow\r\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\r\n        Transfer(0, _owner, _amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    \/\/\/ @notice Burns `_amount` tokens from `_owner`\r\n    \/\/\/ @param _owner The address that will lose the tokens\r\n    \/\/\/ @param _amount The quantity of tokens to burn\r\n    \/\/\/ @return True if the tokens are burned correctly\r\n    function destroyTokens(address _owner, uint _amount\r\n    ) onlyController returns (bool) {\r\n        uint curTotalSupply = getValueAt(totalSupplyHistory, getBlockNumber());\r\n        if (curTotalSupply < _amount) throw;\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\r\n        var previousBalanceFrom = balanceOf(_owner);\r\n        if (previousBalanceFrom < _amount) throw;\r\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\r\n        Transfer(_owner, 0, _amount);\r\n        return true;\r\n    }\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Enable tokens transfers\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n\r\n    \/\/\/ @notice Enables token holders to transfer their tokens freely if true\r\n    \/\/\/ @param _transfersEnabled True if transfers are allowed in the clone\r\n    function enableTransfers(bool _transfersEnabled) onlyController {\r\n        transfersEnabled = _transfersEnabled;\r\n    }\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Internal helper functions to query and set a value in a snapshot array\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @dev `getValueAt` retrieves the number of tokens at a given block number\r\n    \/\/\/ @param checkpoints The history of values being queried\r\n    \/\/\/ @param _block The block number to retrieve the value at\r\n    \/\/\/ @return The number of tokens being queried\r\n    function getValueAt(Checkpoint[] storage checkpoints, uint _block\r\n    ) constant internal returns (uint) {\r\n        if (checkpoints.length == 0) return 0;\r\n\r\n        \/\/ Shortcut for the actual value\r\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\r\n            return checkpoints[checkpoints.length-1].value;\r\n        if (_block < checkpoints[0].fromBlock) return 0;\r\n\r\n        \/\/ Binary search of the value in the array\r\n        uint min = 0;\r\n        uint max = checkpoints.length-1;\r\n        while (max > min) {\r\n            uint mid = (max + min + 1)\/ 2;\r\n            if (checkpoints[mid].fromBlock<=_block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }\r\n        }\r\n        return checkpoints[min].value;\r\n    }\r\n\r\n    \/\/\/ @dev `updateValueAtNow` used to update the `balances` map and the\r\n    \/\/\/  `totalSupplyHistory`\r\n    \/\/\/ @param checkpoints The history of data being updated\r\n    \/\/\/ @param _value The new number of tokens\r\n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\r\n    ) internal  {\r\n        if ((checkpoints.length == 0)\r\n        || (checkpoints[checkpoints.length -1].fromBlock < getBlockNumber())) {\r\n               Checkpoint newCheckPoint = checkpoints[ checkpoints.length++ ];\r\n               newCheckPoint.fromBlock =  uint128(getBlockNumber());\r\n               newCheckPoint.value = uint128(_value);\r\n           } else {\r\n               Checkpoint oldCheckPoint = checkpoints[checkpoints.length-1];\r\n               oldCheckPoint.value = uint128(_value);\r\n           }\r\n    }\r\n\r\n    \/\/\/ @dev Internal function to determine if an address is a contract\r\n    \/\/\/ @param _addr The address being queried\r\n    \/\/\/ @return True if `_addr` is a contract\r\n    function isContract(address _addr) constant internal returns(bool) {\r\n        uint size;\r\n        if (_addr == 0) return false;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size>0;\r\n    }\r\n\r\n    \/\/\/ @dev Helper function to return a min betwen the two uints\r\n    function min(uint a, uint b) internal returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    \/\/\/ @notice The fallback function: If the contract's controller has not been\r\n    \/\/\/  set to 0, then the `proxyPayment` method is called which relays the\r\n    \/\/\/  ether and creates tokens as described in the token controller contract\r\n    function ()  payable {\r\n        if (isContract(controller)) {\r\n            if (! TokenController(controller).proxyPayment.value(msg.value)(msg.sender))\r\n                throw;\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n\r\n\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Testing specific methods\r\n\/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice This function is overridden by the test Mocks.\r\n    function getBlockNumber() internal constant returns (uint256) {\r\n        return block.number;\r\n    }\r\n\r\n\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Safety Methods\r\n\/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice This method can be used by the controller to extract mistakenly\r\n    \/\/\/  sent tokens to this contract.\r\n    \/\/\/ @param _token The address of the token contract that you want to recover\r\n    \/\/\/  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token) onlyController {\r\n        if (_token == 0x0) {\r\n            controller.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        ERC20Token token = ERC20Token(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(controller, balance);\r\n        ClaimedTokens(_token, controller, balance);\r\n    }\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Events\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _amount\r\n        );\r\n\r\n}\r\n\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ MiniMeTokenFactory\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n\/\/\/ @dev This contract is used to generate clone contracts from a contract.\r\n\/\/\/  In solidity this is the way to create a contract from a contract of the\r\n\/\/\/  same class\r\ncontract MiniMeTokenFactory {\r\n\r\n    \/\/\/ @notice Update the DApp by creating a new token with new functionalities\r\n    \/\/\/  the msg.sender becomes the controller of this clone token\r\n    \/\/\/ @param _parentToken Address of the token being cloned\r\n    \/\/\/ @param _snapshotBlock Block of the parent token that will\r\n    \/\/\/  determine the initial distribution of the clone token\r\n    \/\/\/ @param _tokenName Name of the new token\r\n    \/\/\/ @param _decimalUnits Number of decimals of the new token\r\n    \/\/\/ @param _tokenSymbol Token Symbol for the new token\r\n    \/\/\/ @param _transfersEnabled If true, tokens will be able to be transferred\r\n    \/\/\/ @return The address of the new token contract\r\n    function createCloneToken(\r\n        address _parentToken,\r\n        uint _snapshotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    ) returns (MiniMeToken) {\r\n        MiniMeToken newToken = new MiniMeToken(\r\n            this,\r\n            _parentToken,\r\n            _snapshotBlock,\r\n            _tokenName,\r\n            _decimalUnits,\r\n            _tokenSymbol,\r\n            _transfersEnabled\r\n            );\r\n\r\n        newToken.changeController(msg.sender);\r\n        return newToken;\r\n    }\r\n}\r\n\r\n\r\n\/*\r\n    Copyright 2017, Jarrad Hope (Status Research & Development GmbH)\r\n*\/\r\n\r\n\r\ncontract SNT is MiniMeToken {\r\n    \/\/ @dev SNT constructor just parametrizes the MiniMeIrrevocableVestedToken constructor\r\n    function SNT(address _tokenFactory)\r\n            MiniMeToken(\r\n                _tokenFactory,\r\n                0x0,                     \/\/ no parent token\r\n                0,                       \/\/ no snapshot block number from parent\r\n                \"Status Network Token\",  \/\/ Token name\r\n                18,                      \/\/ Decimals\r\n                \"SNT\",                   \/\/ Symbol\r\n                true                     \/\/ Enable transfers\r\n            ) {}\r\n}\r\n\r\n\r\n\/*\r\n    Copyright 2017, Jordi Baylina\r\n\r\n    This program is free software: you can redistribute it and\/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\r\n *\/\r\n\r\n\/\/\/ @title StatusContribution Contract\r\n\/\/\/ @author Jordi Baylina\r\n\/\/\/ @dev This contract will be the SNT controller during the contribution period.\r\n\/\/\/  This contract will determine the rules during this period.\r\n\/\/\/  Final users will generally not interact directly with this contract. ETH will\r\n\/\/\/  be sent to the SNT token contract. The ETH is sent to this contract and from here,\r\n\/\/\/  ETH is sent to the contribution walled and SNTs are mined according to the defined\r\n\/\/\/  rules.\r\n\r\n\r\ncontract StatusContribution is Owned, TokenController {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant public failSafeLimit = 300000 ether;\r\n    uint256 constant public maxGuaranteedLimit = 30000 ether;\r\n    uint256 constant public exchangeRate = 10000;\r\n    uint256 constant public maxGasPrice = 50000000000;\r\n    uint256 constant public maxCallFrequency = 100;\r\n\r\n    MiniMeToken public SGT;\r\n    MiniMeToken public SNT;\r\n    uint256 public startBlock;\r\n    uint256 public endBlock;\r\n\r\n    address public destEthDevs;\r\n\r\n    address public destTokensDevs;\r\n    address public destTokensReserve;\r\n    uint256 public maxSGTSupply;\r\n    address public destTokensSgt;\r\n    DynamicCeiling public dynamicCeiling;\r\n\r\n    address public sntController;\r\n\r\n    mapping (address => uint256) public guaranteedBuyersLimit;\r\n    mapping (address => uint256) public guaranteedBuyersBought;\r\n\r\n    uint256 public totalGuaranteedCollected;\r\n    uint256 public totalNormalCollected;\r\n\r\n    uint256 public finalizedBlock;\r\n    uint256 public finalizedTime;\r\n\r\n    mapping (address => uint256) public lastCallBlock;\r\n\r\n    bool public paused;\r\n\r\n    modifier initialized() {\r\n        require(address(SNT) != 0x0);\r\n        _;\r\n    }\r\n\r\n    modifier contributionOpen() {\r\n        require(getBlockNumber() >= startBlock &&\r\n                getBlockNumber() <= endBlock &&\r\n                finalizedBlock == 0 &&\r\n                address(SNT) != 0x0);\r\n        _;\r\n    }\r\n\r\n    modifier notPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    function StatusContribution() {\r\n        paused = false;\r\n    }\r\n\r\n\r\n    \/\/\/ @notice This method should be called by the owner before the contribution\r\n    \/\/\/  period starts This initializes most of the parameters\r\n    \/\/\/ @param _snt Address of the SNT token contract\r\n    \/\/\/ @param _sntController Token controller for the SNT that will be transferred after\r\n    \/\/\/  the contribution finalizes.\r\n    \/\/\/ @param _startBlock Block when the contribution period starts\r\n    \/\/\/ @param _endBlock The last block that the contribution period is active\r\n    \/\/\/ @param _dynamicCeiling Address of the contract that controls the ceiling\r\n    \/\/\/ @param _destEthDevs Destination address where the contribution ether is sent\r\n    \/\/\/ @param _destTokensReserve Address where the tokens for the reserve are sent\r\n    \/\/\/ @param _destTokensSgt Address of the exchanger SGT-SNT where the SNT are sent\r\n    \/\/\/  to be distributed to the SGT holders.\r\n    \/\/\/ @param _destTokensDevs Address where the tokens for the dev are sent\r\n    \/\/\/ @param _sgt Address of the SGT token contract\r\n    \/\/\/ @param _maxSGTSupply Quantity of SGT tokens that would represent 10% of status.\r\n    function initialize(\r\n        address _snt,\r\n        address _sntController,\r\n\r\n        uint256 _startBlock,\r\n        uint256 _endBlock,\r\n\r\n        address _dynamicCeiling,\r\n\r\n        address _destEthDevs,\r\n\r\n        address _destTokensReserve,\r\n        address _destTokensSgt,\r\n        address _destTokensDevs,\r\n\r\n        address _sgt,\r\n        uint256 _maxSGTSupply\r\n    ) public onlyOwner {\r\n        \/\/ Initialize only once\r\n        require(address(SNT) == 0x0);\r\n\r\n        SNT = MiniMeToken(_snt);\r\n        require(SNT.totalSupply() == 0);\r\n        require(SNT.controller() == address(this));\r\n        require(SNT.decimals() == 18);  \/\/ Same amount of decimals as ETH\r\n\r\n        require(_sntController != 0x0);\r\n        sntController = _sntController;\r\n\r\n        require(_startBlock >= getBlockNumber());\r\n        require(_startBlock < _endBlock);\r\n        startBlock = _startBlock;\r\n        endBlock = _endBlock;\r\n\r\n        require(_dynamicCeiling != 0x0);\r\n        dynamicCeiling = DynamicCeiling(_dynamicCeiling);\r\n\r\n        require(_destEthDevs != 0x0);\r\n        destEthDevs = _destEthDevs;\r\n\r\n        require(_destTokensReserve != 0x0);\r\n        destTokensReserve = _destTokensReserve;\r\n\r\n        require(_destTokensSgt != 0x0);\r\n        destTokensSgt = _destTokensSgt;\r\n\r\n        require(_destTokensDevs != 0x0);\r\n        destTokensDevs = _destTokensDevs;\r\n\r\n        require(_sgt != 0x0);\r\n        SGT = MiniMeToken(_sgt);\r\n\r\n        require(_maxSGTSupply >= MiniMeToken(SGT).totalSupply());\r\n        maxSGTSupply = _maxSGTSupply;\r\n    }\r\n\r\n    \/\/\/ @notice Sets the limit for a guaranteed address. All the guaranteed addresses\r\n    \/\/\/  will be able to get SNTs during the contribution period with his own\r\n    \/\/\/  specific limit.\r\n    \/\/\/  This method should be called by the owner after the initialization\r\n    \/\/\/  and before the contribution starts.\r\n    \/\/\/ @param _th Guaranteed address\r\n    \/\/\/ @param _limit Limit for the guaranteed address.\r\n    function setGuaranteedAddress(address _th, uint256 _limit) public initialized onlyOwner {\r\n        require(getBlockNumber() < startBlock);\r\n        require(_limit > 0 && _limit <= maxGuaranteedLimit);\r\n        guaranteedBuyersLimit[_th] = _limit;\r\n        GuaranteedAddress(_th, _limit);\r\n    }\r\n\r\n    \/\/\/ @notice If anybody sends Ether directly to this contract, consider he is\r\n    \/\/\/  getting SNTs.\r\n    function () public payable notPaused {\r\n        proxyPayment(msg.sender);\r\n    }\r\n\r\n\r\n    \/\/\/\/\/\/\/\/\/\/\r\n    \/\/ MiniMe Controller functions\r\n    \/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice This method will generally be called by the SNT token contract to\r\n    \/\/\/  acquire SNTs. Or directly from third parties that want to acquire SNTs in\r\n    \/\/\/  behalf of a token holder.\r\n    \/\/\/ @param _th SNT holder where the SNTs will be minted.\r\n    function proxyPayment(address _th) public payable notPaused initialized contributionOpen returns (bool) {\r\n        require(_th != 0x0);\r\n        if (guaranteedBuyersLimit[_th] > 0) {\r\n            buyGuaranteed(_th);\r\n        } else {\r\n            buyNormal(_th);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function onTransfer(address, address, uint256) public returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    function onApprove(address, address, uint256) public returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    function buyNormal(address _th) internal {\r\n        require(tx.gasprice <= maxGasPrice);\r\n\r\n        \/\/ Antispam mechanism\r\n        address caller;\r\n        if (msg.sender == address(SNT)) {\r\n            caller = _th;\r\n        } else {\r\n            caller = msg.sender;\r\n        }\r\n\r\n        \/\/ Do not allow contracts to game the system\r\n        require(!isContract(caller));\r\n\r\n        require(getBlockNumber().sub(lastCallBlock[caller]) >= maxCallFrequency);\r\n        lastCallBlock[caller] = getBlockNumber();\r\n\r\n        uint256 toCollect = dynamicCeiling.toCollect(totalNormalCollected);\r\n\r\n        uint256 toFund;\r\n        if (msg.value <= toCollect) {\r\n            toFund = msg.value;\r\n        } else {\r\n            toFund = toCollect;\r\n        }\r\n\r\n        totalNormalCollected = totalNormalCollected.add(toFund);\r\n        doBuy(_th, toFund, false);\r\n    }\r\n\r\n    function buyGuaranteed(address _th) internal {\r\n        uint256 toCollect = guaranteedBuyersLimit[_th];\r\n\r\n        uint256 toFund;\r\n        if (guaranteedBuyersBought[_th].add(msg.value) > toCollect) {\r\n            toFund = toCollect.sub(guaranteedBuyersBought[_th]);\r\n        } else {\r\n            toFund = msg.value;\r\n        }\r\n\r\n        guaranteedBuyersBought[_th] = guaranteedBuyersBought[_th].add(toFund);\r\n        totalGuaranteedCollected = totalGuaranteedCollected.add(toFund);\r\n        doBuy(_th, toFund, true);\r\n    }\r\n\r\n    function doBuy(address _th, uint256 _toFund, bool _guaranteed) internal {\r\n        assert(msg.value >= _toFund);  \/\/ Not needed, but double check.\r\n        assert(totalCollected() <= failSafeLimit);\r\n\r\n        if (_toFund > 0) {\r\n            uint256 tokensGenerated = _toFund.mul(exchangeRate);\r\n            assert(SNT.generateTokens(_th, tokensGenerated));\r\n            destEthDevs.transfer(_toFund);\r\n            NewSale(_th, _toFund, tokensGenerated, _guaranteed);\r\n        }\r\n\r\n        uint256 toReturn = msg.value.sub(_toFund);\r\n        if (toReturn > 0) {\r\n            \/\/ If the call comes from the Token controller,\r\n            \/\/ then we return it to the token Holder.\r\n            \/\/ Otherwise we return to the sender.\r\n            if (msg.sender == address(SNT)) {\r\n                _th.transfer(toReturn);\r\n            } else {\r\n                msg.sender.transfer(toReturn);\r\n            }\r\n        }\r\n    }\r\n\r\n    \/\/ NOTE on Percentage format\r\n    \/\/ Right now, Solidity does not support decimal numbers. (This will change very soon)\r\n    \/\/  So in this contract we use a representation of a percentage that consist in\r\n    \/\/  expressing the percentage in \"x per 10**18\"\r\n    \/\/ This format has a precision of 16 digits for a percent.\r\n    \/\/ Examples:\r\n    \/\/  3%   =   3*(10**16)\r\n    \/\/  100% = 100*(10**16) = 10**18\r\n    \/\/\r\n    \/\/ To get a percentage of a value we do it by first multiplying it by the percentage in  (x per 10^18)\r\n    \/\/  and then divide it by 10**18\r\n    \/\/\r\n    \/\/              Y * X(in x per 10**18)\r\n    \/\/  X% of Y = -------------------------\r\n    \/\/               100(in x per 10**18)\r\n    \/\/\r\n\r\n\r\n    \/\/\/ @notice This method will can be called by the owner before the contribution period\r\n    \/\/\/  end or by anybody after the `endBlock`. This method finalizes the contribution period\r\n    \/\/\/  by creating the remaining tokens and transferring the controller to the configured\r\n    \/\/\/  controller.\r\n    function finalize() public initialized {\r\n        require(getBlockNumber() >= startBlock);\r\n        require(msg.sender == owner || getBlockNumber() > endBlock);\r\n        require(finalizedBlock == 0);\r\n\r\n        \/\/ Do not allow termination until all curves revealed.\r\n        require(dynamicCeiling.allRevealed());\r\n\r\n        \/\/ Allow premature finalization if final limit is reached\r\n        if (getBlockNumber() <= endBlock) {\r\n            var (,lastLimit,,) = dynamicCeiling.curves(dynamicCeiling.revealedCurves().sub(1));\r\n            require(totalNormalCollected >= lastLimit);\r\n        }\r\n\r\n        finalizedBlock = getBlockNumber();\r\n        finalizedTime = now;\r\n\r\n        uint256 percentageToSgt;\r\n        if (SGT.totalSupply() >= maxSGTSupply) {\r\n            percentageToSgt = percent(10);  \/\/ 10%\r\n        } else {\r\n\r\n            \/\/\r\n            \/\/                           SGT.totalSupply()\r\n            \/\/  percentageToSgt = 10% * -------------------\r\n            \/\/                             maxSGTSupply\r\n            \/\/\r\n            percentageToSgt = percent(10).mul(SGT.totalSupply()).div(maxSGTSupply);\r\n        }\r\n\r\n        uint256 percentageToDevs = percent(20);  \/\/ 20%\r\n\r\n\r\n        \/\/\r\n        \/\/  % To Contributors = 41% + (10% - % to SGT holders)\r\n        \/\/\r\n        uint256 percentageToContributors = percent(41).add(percent(10).sub(percentageToSgt));\r\n\r\n        uint256 percentageToReserve = percent(29);\r\n\r\n\r\n        \/\/ SNT.totalSupply() -> Tokens minted during the contribution\r\n        \/\/  totalTokens  -> Total tokens that should be after the allocation\r\n        \/\/                   of devTokens, sgtTokens and reserve\r\n        \/\/  percentageToContributors -> Which percentage should go to the\r\n        \/\/                               contribution participants\r\n        \/\/                               (x per 10**18 format)\r\n        \/\/  percent(100) -> 100% in (x per 10**18 format)\r\n        \/\/\r\n        \/\/                       percentageToContributors\r\n        \/\/  SNT.totalSupply() = -------------------------- * totalTokens  =>\r\n        \/\/                             percent(100)\r\n        \/\/\r\n        \/\/\r\n        \/\/                            percent(100)\r\n        \/\/  =>  totalTokens = ---------------------------- * SNT.totalSupply()\r\n        \/\/                      percentageToContributors\r\n        \/\/\r\n        uint256 totalTokens = SNT.totalSupply().mul(percent(100)).div(percentageToContributors);\r\n\r\n\r\n        \/\/ Generate tokens for SGT Holders.\r\n\r\n        \/\/\r\n        \/\/                    percentageToReserve\r\n        \/\/  reserveTokens = ----------------------- * totalTokens\r\n        \/\/                      percentage(100)\r\n        \/\/\r\n        assert(SNT.generateTokens(\r\n            destTokensReserve,\r\n            totalTokens.mul(percentageToReserve).div(percent(100))));\r\n\r\n        \/\/\r\n        \/\/                  percentageToSgt\r\n        \/\/  sgtTokens = ----------------------- * totalTokens\r\n        \/\/                   percentage(100)\r\n        \/\/\r\n        assert(SNT.generateTokens(\r\n            destTokensSgt,\r\n            totalTokens.mul(percentageToSgt).div(percent(100))));\r\n\r\n\r\n        \/\/\r\n        \/\/                   percentageToDevs\r\n        \/\/  devTokens = ----------------------- * totalTokens\r\n        \/\/                   percentage(100)\r\n        \/\/\r\n        assert(SNT.generateTokens(\r\n            destTokensDevs,\r\n            totalTokens.mul(percentageToDevs).div(percent(100))));\r\n\r\n        SNT.changeController(sntController);\r\n\r\n        Finalized();\r\n    }\r\n\r\n    function percent(uint256 p) internal returns (uint256) {\r\n        return p.mul(10**16);\r\n    }\r\n\r\n    \/\/\/ @dev Internal function to determine if an address is a contract\r\n    \/\/\/ @param _addr The address being queried\r\n    \/\/\/ @return True if `_addr` is a contract\r\n    function isContract(address _addr) constant internal returns (bool) {\r\n        if (_addr == 0) return false;\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return (size > 0);\r\n    }\r\n\r\n\r\n    \/\/\/\/\/\/\/\/\/\/\r\n    \/\/ Constant functions\r\n    \/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @return Total tokens issued in weis.\r\n    function tokensIssued() public constant returns (uint256) {\r\n        return SNT.totalSupply();\r\n    }\r\n\r\n    \/\/\/ @return Total Ether collected.\r\n    function totalCollected() public constant returns (uint256) {\r\n        return totalNormalCollected.add(totalGuaranteedCollected);\r\n    }\r\n\r\n\r\n    \/\/\/\/\/\/\/\/\/\/\r\n    \/\/ Testing specific methods\r\n    \/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice This function is overridden by the test Mocks.\r\n    function getBlockNumber() internal constant returns (uint256) {\r\n        return block.number;\r\n    }\r\n\r\n\r\n    \/\/\/\/\/\/\/\/\/\/\r\n    \/\/ Safety Methods\r\n    \/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice This method can be used by the controller to extract mistakenly\r\n    \/\/\/  sent tokens to this contract.\r\n    \/\/\/ @param _token The address of the token contract that you want to recover\r\n    \/\/\/  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token) public onlyOwner {\r\n        if (SNT.controller() == address(this)) {\r\n            SNT.claimTokens(_token);\r\n        }\r\n        if (_token == 0x0) {\r\n            owner.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        ERC20Token token = ERC20Token(_token);\r\n        uint256 balance = token.balanceOf(this);\r\n        token.transfer(owner, balance);\r\n        ClaimedTokens(_token, owner, balance);\r\n    }\r\n\r\n\r\n    \/\/\/ @notice Pauses the contribution if there is any issue\r\n    function pauseContribution() onlyOwner {\r\n        paused = true;\r\n    }\r\n\r\n    \/\/\/ @notice Resumes the contribution\r\n    function resumeContribution() onlyOwner {\r\n        paused = false;\r\n    }\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint256 _amount);\r\n    event NewSale(address indexed _th, uint256 _amount, uint256 _tokens, bool _guaranteed);\r\n    event GuaranteedAddress(address indexed _th, uint256 _limit);\r\n    event Finalized();\r\n}\r\n\r\n\r\n\/*\r\n    Copyright 2017, Jordi Baylina\r\n\r\n    This program is free software: you can redistribute it and\/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\r\n *\/\r\n\r\n\/\/\/ @title ContributionWallet Contract\r\n\/\/\/ @author Jordi Baylina\r\n\/\/\/ @dev This contract will be hold the Ether during the contribution period.\r\n\/\/\/  The idea of this contract is to avoid recycling Ether during the contribution\r\n\/\/\/  period. So all the ETH collected will be locked here until the contribution\r\n\/\/\/  period ends\r\n\r\n\/\/ @dev Contract to hold sale raised funds during the sale period.\r\n\/\/ Prevents attack in which the Aragon Multisig sends raised ether\r\n\/\/ to the sale contract to mint tokens to itself, and getting the\r\n\/\/ funds back immediately.\r\n\r\n\r\n\r\ncontract ContributionWallet {\r\n\r\n    \/\/ Public variables\r\n    address public multisig;\r\n    uint256 public endBlock;\r\n    StatusContribution public contribution;\r\n\r\n    \/\/ @dev Constructor initializes public variables\r\n    \/\/ @param _multisig The address of the multisig that will receive the funds\r\n    \/\/ @param _endBlock Block after which the multisig can request the funds\r\n    \/\/ @param _contribution Address of the StatusContribution contract\r\n    function ContributionWallet(address _multisig, uint256 _endBlock, address _contribution) {\r\n        require(_multisig != 0x0);\r\n        require(_contribution != 0x0);\r\n        require(_endBlock != 0 && _endBlock <= 4000000);\r\n        multisig = _multisig;\r\n        endBlock = _endBlock;\r\n        contribution = StatusContribution(_contribution);\r\n    }\r\n\r\n    \/\/ @dev Receive all sent funds without any further logic\r\n    function () public payable {}\r\n\r\n    \/\/ @dev Withdraw function sends all the funds to the wallet if conditions are correct\r\n    function withdraw() public {\r\n        require(msg.sender == multisig);              \/\/ Only the multisig can request it\r\n        require(block.number > endBlock ||            \/\/ Allow after end block\r\n                contribution.finalizedBlock() != 0);  \/\/ Allow when sale is finalized\r\n        multisig.transfer(this.balance);\r\n    }\r\n\r\n}\r\n\r\n\r\n\/*\r\n    Copyright 2017, Jordi Baylina\r\n\r\n    This program is free software: you can redistribute it and\/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\r\n *\/\r\n\r\n\/\/\/ @title DevTokensHolder Contract\r\n\/\/\/ @author Jordi Baylina\r\n\/\/\/ @dev This contract will hold the tokens of the developers.\r\n\/\/\/  Tokens will not be able to be collected until 6 months after the contribution\r\n\/\/\/  period ends. And it will be increasing linearly until 2 years.\r\n\r\n\r\n\/\/  collectable tokens\r\n\/\/   |                         _\/--------   vestedTokens rect\r\n\/\/   |                       _\/\r\n\/\/   |                     _\/\r\n\/\/   |                   _\/\r\n\/\/   |                 _\/\r\n\/\/   |               _\/\r\n\/\/   |             _\/\r\n\/\/   |           _\/\r\n\/\/   |          |\r\n\/\/   |        . |\r\n\/\/   |      .   |\r\n\/\/   |    .     |\r\n\/\/   +===+======+--------------+----------> time\r\n\/\/     Contrib   6 Months       24 Months\r\n\/\/       End\r\n\r\n\r\n\r\ncontract DevTokensHolder is Owned {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 collectedTokens;\r\n    StatusContribution contribution;\r\n    MiniMeToken snt;\r\n\r\n    function DevTokensHolder(address _owner, address _contribution, address _snt) {\r\n        owner = _owner;\r\n        contribution = StatusContribution(_contribution);\r\n        snt = MiniMeToken(_snt);\r\n    }\r\n\r\n\r\n    \/\/\/ @notice The Dev (Owner) will call this method to extract the tokens\r\n    function collectTokens() public onlyOwner {\r\n        uint256 balance = snt.balanceOf(address(this));\r\n        uint256 total = collectedTokens.add(balance);\r\n\r\n        uint256 finalizedTime = contribution.finalizedTime();\r\n\r\n        require(finalizedTime > 0 && getTime() > finalizedTime.add(months(6)));\r\n\r\n        uint256 canExtract = total.mul(getTime().sub(finalizedTime)).div(months(24));\r\n\r\n        canExtract = canExtract.sub(collectedTokens);\r\n\r\n        if (canExtract > balance) {\r\n            canExtract = balance;\r\n        }\r\n\r\n        collectedTokens = collectedTokens.add(canExtract);\r\n        assert(snt.transfer(owner, canExtract));\r\n\r\n        TokensWithdrawn(owner, canExtract);\r\n    }\r\n\r\n    function months(uint256 m) internal returns (uint256) {\r\n        return m.mul(30 days);\r\n    }\r\n\r\n    function getTime() internal returns (uint256) {\r\n        return now;\r\n    }\r\n\r\n\r\n    \/\/\/\/\/\/\/\/\/\/\r\n    \/\/ Safety Methods\r\n    \/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice This method can be used by the controller to extract mistakenly\r\n    \/\/\/  sent tokens to this contract.\r\n    \/\/\/ @param _token The address of the token contract that you want to recover\r\n    \/\/\/  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token) public onlyOwner {\r\n        require(_token != address(snt));\r\n        if (_token == 0x0) {\r\n            owner.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        ERC20Token token = ERC20Token(_token);\r\n        uint256 balance = token.balanceOf(this);\r\n        token.transfer(owner, balance);\r\n        ClaimedTokens(_token, owner, balance);\r\n    }\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint256 _amount);\r\n    event TokensWithdrawn(address indexed _holder, uint256 _amount);\r\n}\r\n\r\n\r\n\/*\r\n    Copyright 2017, Jordi Baylina\r\n\r\n    This program is free software: you can redistribute it and\/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\r\n *\/\r\n\r\n\/\/\/ @title SGTExchanger Contract\r\n\/\/\/ @author Jordi Baylina\r\n\/\/\/ @dev This contract will be used to distribute SNT between SGT holders.\r\n\/\/\/  SGT token is not transferable, and we just keep an accounting between all tokens\r\n\/\/\/  deposited and the tokens collected.\r\n\/\/\/  The controllerShip of SGT should be transferred to this contract before the\r\n\/\/\/  contribution period starts.\r\n\r\n\r\ncontract SGTExchanger is TokenController, Owned {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) public collected;\r\n    uint256 public totalCollected;\r\n    MiniMeToken public sgt;\r\n    MiniMeToken public snt;\r\n    StatusContribution public statusContribution;\r\n\r\n    function SGTExchanger(address _sgt, address _snt, address _statusContribution) {\r\n        sgt = MiniMeToken(_sgt);\r\n        snt = MiniMeToken(_snt);\r\n        statusContribution = StatusContribution(_statusContribution);\r\n    }\r\n\r\n    \/\/\/ @notice This method should be called by the SGT holders to collect their\r\n    \/\/\/  corresponding SNTs\r\n    function collect() public {\r\n        uint256 finalizedBlock = statusContribution.finalizedBlock();\r\n\r\n        require(finalizedBlock != 0);\r\n        require(getBlockNumber() > finalizedBlock);\r\n\r\n        uint256 total = totalCollected.add(snt.balanceOf(address(this)));\r\n\r\n        uint256 balance = sgt.balanceOfAt(msg.sender, finalizedBlock);\r\n\r\n        \/\/ First calculate how much correspond to him\r\n        uint256 amount = total.mul(balance).div(sgt.totalSupplyAt(finalizedBlock));\r\n\r\n        \/\/ And then subtract the amount already collected\r\n        amount = amount.sub(collected[msg.sender]);\r\n\r\n        require(amount > 0);  \/\/ Notify the user that there are no tokens to exchange\r\n\r\n        totalCollected = totalCollected.add(amount);\r\n        collected[msg.sender] = collected[msg.sender].add(amount);\r\n\r\n        assert(snt.transfer(msg.sender, amount));\r\n\r\n        TokensCollected(msg.sender, amount);\r\n    }\r\n\r\n    function proxyPayment(address) public payable returns (bool) {\r\n        throw;\r\n    }\r\n\r\n    function onTransfer(address, address, uint256) public returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    function onApprove(address, address, uint256) public returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    \/\/\/\/\/\/\/\/\/\/\r\n    \/\/ Testing specific methods\r\n    \/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice This function is overridden by the test Mocks.\r\n    function getBlockNumber() internal constant returns (uint256) {\r\n        return block.number;\r\n    }\r\n\r\n    \/\/\/\/\/\/\/\/\/\/\r\n    \/\/ Safety Method\r\n    \/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice This method can be used by the controller to extract mistakenly\r\n    \/\/\/  sent tokens to this contract.\r\n    \/\/\/ @param _token The address of the token contract that you want to recover\r\n    \/\/\/  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token) public onlyOwner {\r\n        require(_token != address(snt));\r\n        if (_token == 0x0) {\r\n            owner.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        ERC20Token token = ERC20Token(_token);\r\n        uint256 balance = token.balanceOf(this);\r\n        token.transfer(owner, balance);\r\n        ClaimedTokens(_token, owner, balance);\r\n    }\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint256 _amount);\r\n    event TokensCollected(address indexed _holder, uint256 _amount);\r\n\r\n}\r\n\r\n\/*\r\n    Copyright 2017, Jordi Baylina\r\n\r\n    This program is free software: you can redistribute it and\/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\r\n *\/\r\n\r\n\/\/\/ @title SNTPlaceholder Contract\r\n\/\/\/ @author Jordi Baylina\r\n\/\/\/ @dev The SNTPlaceholder contract will take control over the SNT after the contribution\r\n\/\/\/  is finalized and before the Status Network is deployed.\r\n\/\/\/  The contract allows for SNT transfers and transferFrom and implements the\r\n\/\/\/  logic for transferring control of the token to the network when the offering\r\n\/\/\/  asks it to do so.\r\n\r\n\r\ncontract SNTPlaceHolder is TokenController, Owned {\r\n    using SafeMath for uint256;\r\n\r\n    MiniMeToken public snt;\r\n    StatusContribution public contribution;\r\n    uint256 public activationTime;\r\n    address public sgtExchanger;\r\n\r\n    \/\/\/ @notice Constructor\r\n    \/\/\/ @param _owner Trusted owner for this contract.\r\n    \/\/\/ @param _snt SNT token contract address\r\n    \/\/\/ @param _contribution StatusContribution contract address\r\n    \/\/\/ @param _sgtExchanger SGT-SNT Exchange address. (During the first week\r\n    \/\/\/  only this exchanger will be able to move tokens)\r\n    function SNTPlaceHolder(address _owner, address _snt, address _contribution, address _sgtExchanger) {\r\n        owner = _owner;\r\n        snt = MiniMeToken(_snt);\r\n        contribution = StatusContribution(_contribution);\r\n        sgtExchanger = _sgtExchanger;\r\n    }\r\n\r\n    \/\/\/ @notice The owner of this contract can change the controller of the SNT token\r\n    \/\/\/  Please, be sure that the owner is a trusted agent or 0x0 address.\r\n    \/\/\/ @param _newController The address of the new controller\r\n\r\n    function changeController(address _newController) public onlyOwner {\r\n        snt.changeController(_newController);\r\n        ControllerChanged(_newController);\r\n    }\r\n\r\n\r\n    \/\/\/\/\/\/\/\/\/\/\r\n    \/\/ MiniMe Controller Interface functions\r\n    \/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/ In between the offering and the network. Default settings for allowing token transfers.\r\n    function proxyPayment(address) public payable returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    function onTransfer(address _from, address, uint256) public returns (bool) {\r\n        return transferable(_from);\r\n    }\r\n\r\n    function onApprove(address _from, address, uint256) public returns (bool) {\r\n        return transferable(_from);\r\n    }\r\n\r\n    function transferable(address _from) internal returns (bool) {\r\n        \/\/ Allow the exchanger to work from the beginning\r\n        if (activationTime == 0) {\r\n            uint256 f = contribution.finalizedTime();\r\n            if (f > 0) {\r\n                activationTime = f.add(1 weeks);\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n        return (getTime() > activationTime) || (_from == sgtExchanger);\r\n    }\r\n\r\n\r\n    \/\/\/\/\/\/\/\/\/\/\r\n    \/\/ Testing specific methods\r\n    \/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice This function is overrided by the test Mocks.\r\n    function getTime() internal returns (uint256) {\r\n        return now;\r\n    }\r\n\r\n\r\n    \/\/\/\/\/\/\/\/\/\/\r\n    \/\/ Safety Methods\r\n    \/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice This method can be used by the controller to extract mistakenly\r\n    \/\/\/  sent tokens to this contract.\r\n    \/\/\/ @param _token The address of the token contract that you want to recover\r\n    \/\/\/  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token) public onlyOwner {\r\n        if (snt.controller() == address(this)) {\r\n            snt.claimTokens(_token);\r\n        }\r\n        if (_token == 0x0) {\r\n            owner.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        ERC20Token token = ERC20Token(_token);\r\n        uint256 balance = token.balanceOf(this);\r\n        token.transfer(owner, balance);\r\n        ClaimedTokens(_token, owner, balance);\r\n    }\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint256 _amount);\r\n    event ControllerChanged(address indexed _newController);\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/statusim\/",
        "Telegram": "",
        "Website": "https:\/\/status.im\/",
        "Email": "",
        "Twitter": "https:\/\/twitter.com\/ethstatus"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x744d70fdbe2ba4cf95131626614a1763df805b9e#code"
    }, {
      "contractId": 6,
      "title": "PayToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "TenXPay",
      "code": "pragma solidity 0.4.11;\r\n\r\n\r\n\/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control \r\n * functions, this simplifies the implementation of \"user permissions\". \r\n *\/\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  \/** \r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   *\/\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  \/**\r\n   * @dev Throws if called by any account other than the owner. \r\n   *\/\r\n  modifier onlyOwner() {\r\n    if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n\r\n  \/**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to. \r\n   *\/\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\/**\r\n * @title Authorizable\r\n * @dev Allows to authorize access to certain function calls\r\n * \r\n * ABI\r\n * [{\"constant\":true,\"inputs\":[{\"name\":\"authorizerIndex\",\"type\":\"uint256\"}],\"name\":\"getAuthorizer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addAuthorized\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"}]\r\n *\/\r\ncontract Authorizable {\r\n\r\n  address[] authorizers;\r\n  mapping(address => uint) authorizerIndex;\r\n\r\n  \/**\r\n   * @dev Throws if called by any account tat is not authorized. \r\n   *\/\r\n  modifier onlyAuthorized {\r\n    require(isAuthorized(msg.sender));\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev Contructor that authorizes the msg.sender. \r\n   *\/\r\n  function Authorizable() {\r\n    authorizers.length = 2;\r\n    authorizers[1] = msg.sender;\r\n    authorizerIndex[msg.sender] = 1;\r\n  }\r\n\r\n  \/**\r\n   * @dev Function to get a specific authorizer\r\n   * @param authorizerIndex index of the authorizer to be retrieved.\r\n   * @return The address of the authorizer.\r\n   *\/\r\n  function getAuthorizer(uint authorizerIndex) external constant returns(address) {\r\n    return address(authorizers[authorizerIndex + 1]);\r\n  }\r\n\r\n  \/**\r\n   * @dev Function to check if an address is authorized\r\n   * @param _addr the address to check if it is authorized.\r\n   * @return boolean flag if address is authorized.\r\n   *\/\r\n  function isAuthorized(address _addr) constant returns(bool) {\r\n    return authorizerIndex[_addr] > 0;\r\n  }\r\n\r\n  \/**\r\n   * @dev Function to add a new authorizer\r\n   * @param _addr the address to add as a new authorizer.\r\n   *\/\r\n  function addAuthorized(address _addr) external onlyAuthorized {\r\n    authorizerIndex[_addr] = authorizers.length;\r\n    authorizers.length++;\r\n    authorizers[authorizers.length - 1] = _addr;\r\n  }\r\n\r\n}\r\n\r\n\/**\r\n * @title ExchangeRate\r\n * @dev Allows updating and retrieveing of Conversion Rates for PAY tokens\r\n *\r\n * ABI\r\n * [{\"constant\":false,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"updateRate\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"data\",\"type\":\"uint256[]\"}],\"name\":\"updateRates\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"getRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"rates\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"symbol\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"RateUpdated\",\"type\":\"event\"}]\r\n *\/\r\ncontract ExchangeRate is Ownable {\r\n\r\n  event RateUpdated(uint timestamp, bytes32 symbol, uint rate);\r\n\r\n  mapping(bytes32 => uint) public rates;\r\n\r\n  \/**\r\n   * @dev Allows the current owner to update a single rate.\r\n   * @param _symbol The symbol to be updated. \r\n   * @param _rate the rate for the symbol. \r\n   *\/\r\n  function updateRate(string _symbol, uint _rate) public onlyOwner {\r\n    rates[sha3(_symbol)] = _rate;\r\n    RateUpdated(now, sha3(_symbol), _rate);\r\n  }\r\n\r\n  \/**\r\n   * @dev Allows the current owner to update multiple rates.\r\n   * @param data an array that alternates sha3 hashes of the symbol and the corresponding rate . \r\n   *\/\r\n  function updateRates(uint[] data) public onlyOwner {\r\n    if (data.length % 2 > 0)\r\n      throw;\r\n    uint i = 0;\r\n    while (i < data.length \/ 2) {\r\n      bytes32 symbol = bytes32(data[i * 2]);\r\n      uint rate = data[i * 2 + 1];\r\n      rates[symbol] = rate;\r\n      RateUpdated(now, symbol, rate);\r\n      i++;\r\n    }\r\n  }\r\n\r\n  \/**\r\n   * @dev Allows the anyone to read the current rate.\r\n   * @param _symbol the symbol to be retrieved. \r\n   *\/\r\n  function getRate(string _symbol) public constant returns(uint) {\r\n    return rates[sha3(_symbol)];\r\n  }\r\n\r\n}\r\n\r\n\/**\r\n * Math operations with safety checks\r\n *\/\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\n    uint c = a \/ b;\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n *\/\r\ncontract ERC20Basic {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function transfer(address to, uint value);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\n\r\n\r\n\r\n\/**\r\n * @title ERC20 interface\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n *\/\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n  function transferFrom(address from, address to, uint value);\r\n  function approve(address spender, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n\r\n\r\n\/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances. \r\n *\/\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint;\r\n\r\n  mapping(address => uint) balances;\r\n\r\n  \/**\r\n   * @dev Fix for the ERC20 short address attack.\r\n   *\/\r\n  modifier onlyPayloadSize(uint size) {\r\n     if(msg.data.length < size + 4) {\r\n       throw;\r\n     }\r\n     _;\r\n  }\r\n\r\n  \/**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  *\/\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n  }\r\n\r\n  \/**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of. \r\n  * @return An uint representing the amount owned by the passed address.\r\n  *\/\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implemantation of the basic standart token.\r\n * @dev https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n * @dev Based on code by FirstBlood: https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\n *\/\r\ncontract StandardToken is BasicToken, ERC20 {\r\n\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n\r\n  \/**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint the amout of tokens to be transfered\r\n   *\/\r\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    \/\/ Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    \/\/ if (_value > _allowance) throw;\r\n\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n  }\r\n\r\n  \/**\r\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   *\/\r\n  function approve(address _spender, uint _value) {\r\n\r\n    \/\/ To change the approve amount you first have to reduce the addresses`\r\n    \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    \/\/  already 0 to mitigate the race condition described here:\r\n    \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n  }\r\n\r\n  \/**\r\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint specifing the amount of tokens still avaible for the spender.\r\n   *\/\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * @dev Issue: * https:\/\/github.com\/OpenZeppelin\/zeppelin-solidity\/issues\/120\r\n * Based on code by TokenMarketNet: https:\/\/github.com\/TokenMarketNet\/ico\/blob\/master\/contracts\/MintableToken.sol\r\n *\/\r\n\r\ncontract MintableToken is StandardToken, Ownable {\r\n  event Mint(address indexed to, uint value);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n  uint public totalSupply = 0;\r\n\r\n\r\n  modifier canMint() {\r\n    if(mintingFinished) throw;\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will recieve the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   *\/\r\n  function mint(address _to, uint _amount) onlyOwner canMint returns (bool) {\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   *\/\r\n  function finishMinting() onlyOwner returns (bool) {\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\n\/**\r\n * @title PayToken\r\n * @dev The main PAY token contract\r\n * \r\n * ABI \r\n * [{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startTrading\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradingStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]\r\n *\/\r\ncontract PayToken is MintableToken {\r\n\r\n  string public name = \"TenX Pay Token\";\r\n  string public symbol = \"PAY\";\r\n  uint public decimals = 18;\r\n\r\n  bool public tradingStarted = false;\r\n\r\n  \/**\r\n   * @dev modifier that throws if trading has not started yet\r\n   *\/\r\n  modifier hasStartedTrading() {\r\n    require(tradingStarted);\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev Allows the owner to enable the trading. This can not be undone\r\n   *\/\r\n  function startTrading() onlyOwner {\r\n    tradingStarted = true;\r\n  }\r\n\r\n  \/**\r\n   * @dev Allows anyone to transfer the PAY tokens once trading has started\r\n   * @param _to the recipient address of the tokens. \r\n   * @param _value number of tokens to be transfered. \r\n   *\/\r\n  function transfer(address _to, uint _value) hasStartedTrading {\r\n    super.transfer(_to, _value);\r\n  }\r\n\r\n   \/**\r\n   * @dev Allows anyone to transfer the PAY tokens once trading has started\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint the amout of tokens to be transfered\r\n   *\/\r\n  function transferFrom(address _from, address _to, uint _value) hasStartedTrading {\r\n    super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n}\r\n\r\n\r\n\/**\r\n * @title MainSale\r\n * @dev The main PAY token sale contract\r\n * \r\n * ABI\r\n * [{\"constant\":false,\"inputs\":[{\"name\":\"_multisigVault\",\"type\":\"address\"}],\"name\":\"setMultisigVault\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"authorizerIndex\",\"type\":\"uint256\"}],\"name\":\"getAuthorizer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"altDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"authorizedCreateTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeRate\",\"type\":\"address\"}],\"name\":\"setExchangeRate\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"retrieveTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"totalAltDeposits\",\"type\":\"uint256\"}],\"name\":\"setAltDeposit\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"createTokens\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addAuthorized\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multisigVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hardcap\",\"type\":\"uint256\"}],\"name\":\"setHardCap\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_start\",\"type\":\"uint256\"}],\"name\":\"setStart\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ether_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pay_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"exchangerate\",\"type\":\"uint256\"}],\"name\":\"TokenSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pay_amount\",\"type\":\"uint256\"}],\"name\":\"AuthorizedCreate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MainSaleClosed\",\"type\":\"event\"}]\r\n *\/\r\ncontract MainSale is Ownable, Authorizable {\r\n  using SafeMath for uint;\r\n  event TokenSold(address recipient, uint ether_amount, uint pay_amount, uint exchangerate);\r\n  event AuthorizedCreate(address recipient, uint pay_amount);\r\n  event MainSaleClosed();\r\n\r\n  PayToken public token = new PayToken();\r\n\r\n  address public multisigVault;\r\n\r\n  uint hardcap = 200000 ether;\r\n  ExchangeRate public exchangeRate;\r\n\r\n  uint public altDeposits = 0;\r\n  uint public start = 1498302000; \/\/new Date(\"Jun 24 2017 11:00:00 GMT\").getTime() \/ 1000\r\n\r\n  \/**\r\n   * @dev modifier to allow token creation only when the sale IS ON\r\n   *\/\r\n  modifier saleIsOn() {\r\n    require(now > start && now < start + 28 days);\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev modifier to allow token creation only when the hardcap has not been reached\r\n   *\/\r\n  modifier isUnderHardCap() {\r\n    require(multisigVault.balance + altDeposits <= hardcap);\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev Allows anyone to create tokens by depositing ether.\r\n   * @param recipient the recipient to receive tokens. \r\n   *\/\r\n  function createTokens(address recipient) public isUnderHardCap saleIsOn payable {\r\n    uint rate = exchangeRate.getRate(\"ETH\");\r\n    uint tokens = rate.mul(msg.value).div(1 ether);\r\n    token.mint(recipient, tokens);\r\n    require(multisigVault.send(msg.value));\r\n    TokenSold(recipient, msg.value, tokens, rate);\r\n  }\r\n\r\n\r\n  \/**\r\n   * @dev Allows to set the toal alt deposit measured in ETH to make sure the hardcap includes other deposits\r\n   * @param totalAltDeposits total amount ETH equivalent\r\n   *\/\r\n  function setAltDeposit(uint totalAltDeposits) public onlyOwner {\r\n    altDeposits = totalAltDeposits;\r\n  }\r\n\r\n  \/**\r\n   * @dev Allows authorized acces to create tokens. This is used for Bitcoin and ERC20 deposits\r\n   * @param recipient the recipient to receive tokens.\r\n   * @param tokens number of tokens to be created. \r\n   *\/\r\n  function authorizedCreateTokens(address recipient, uint tokens) public onlyAuthorized {\r\n    token.mint(recipient, tokens);\r\n    AuthorizedCreate(recipient, tokens);\r\n  }\r\n\r\n  \/**\r\n   * @dev Allows the owner to set the hardcap.\r\n   * @param _hardcap the new hardcap\r\n   *\/\r\n  function setHardCap(uint _hardcap) public onlyOwner {\r\n    hardcap = _hardcap;\r\n  }\r\n\r\n  \/**\r\n   * @dev Allows the owner to set the starting time.\r\n   * @param _start the new _start\r\n   *\/\r\n  function setStart(uint _start) public onlyOwner {\r\n    start = _start;\r\n  }\r\n\r\n  \/**\r\n   * @dev Allows the owner to set the multisig contract.\r\n   * @param _multisigVault the multisig contract address\r\n   *\/\r\n  function setMultisigVault(address _multisigVault) public onlyOwner {\r\n    if (_multisigVault != address(0)) {\r\n      multisigVault = _multisigVault;\r\n    }\r\n  }\r\n\r\n  \/**\r\n   * @dev Allows the owner to set the exchangerate contract.\r\n   * @param _exchangeRate the exchangerate address\r\n   *\/\r\n  function setExchangeRate(address _exchangeRate) public onlyOwner {\r\n    exchangeRate = ExchangeRate(_exchangeRate);\r\n  }\r\n\r\n  \/**\r\n   * @dev Allows the owner to finish the minting. This will create the \r\n   * restricted tokens and then close the minting.\r\n   * Then the ownership of the PAY token contract is transfered \r\n   * to this owner.\r\n   *\/\r\n  function finishMinting() public onlyOwner {\r\n    uint issuedTokenSupply = token.totalSupply();\r\n    uint restrictedTokens = issuedTokenSupply.mul(49).div(51);\r\n    token.mint(multisigVault, restrictedTokens);\r\n    token.finishMinting();\r\n    token.transferOwnership(owner);\r\n    MainSaleClosed();\r\n  }\r\n\r\n  \/**\r\n   * @dev Allows the owner to transfer ERC20 tokens to the multi sig vault\r\n   * @param _token the contract address of the ERC20 contract\r\n   *\/\r\n  function retrieveTokens(address _token) public onlyOwner {\r\n    ERC20 token = ERC20(_token);\r\n    token.transfer(multisigVault, token.balanceOf(this));\r\n  }\r\n\r\n  \/**\r\n   * @dev Fallback function which receives ether and created the appropriate number of tokens for the \r\n   * msg.sender.\r\n   *\/\r\n  function() external payable {\r\n    createTokens(msg.sender);\r\n  }\r\n\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/TenX\/",
        "Telegram": "",
        "Website": "http:\/\/www.tenx.tech\/",
        "Email": "mailto:team@tenx.tech",
        "Twitter": "https:\/\/twitter.com\/tenxwallet"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xb97048628db6b661d4c2aa833e95dbe1a905b280#code"
    }, {
      "contractId": 7,
      "title": "Qtum Token",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Qtum",
      "code": "\/\/ Abstract contract for the full ERC 20 Token standard\r\n\/\/ https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\npragma solidity ^0.4.8;\r\n\r\ncontract Token {\r\n    \/* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    *\/\r\n    \/\/\/ total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    \/\/\/ @param _owner The address from which the balance will be retrieved\r\n    \/\/\/ @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    \/\/\/ @notice send `_value` token to `_to` from `msg.sender`\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _value The amount of token to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    \/\/\/ @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    \/\/\/ @param _from The address of the sender\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _value The amount of token to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    \/\/\/ @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @param _value The amount of tokens to be approved for transfer\r\n    \/\/\/ @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    \/\/\/ @param _owner The address of the account owning tokens\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\/*\r\nYou should inherit from StandardToken or, for a token like you would want to\r\ndeploy in something like Mist, see HumanStandardToken.sol.\r\n(This implements ONLY the standard functions and NOTHING else.\r\nIf you deploy this, you won't have anything useful.)\r\n\r\nImplements ERC 20 Token standard: https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n.*\/\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        \/\/Default assumes totalSupply can't be over max (2^256 - 1).\r\n        \/\/If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        \/\/Replace the if with this one instead.\r\n        \/\/if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        \/\/same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        \/\/if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}\r\n\r\ncontract HumanStandardToken is StandardToken {\r\n\r\n    function () {\r\n        \/\/if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    \/* Public variables of the token *\/\r\n\r\n    \/*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets\/interfaces might not even bother to look at this information.\r\n    *\/\r\n    string public name;                   \/\/fancy name: eg Simon Bucks\r\n    uint8 public decimals;                \/\/How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 \/\/An identifier: eg SBX\r\n    string public version = 'H0.1';       \/\/human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n    function HumanStandardToken(\r\n        uint256 _initialAmount,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol\r\n        ) {\r\n        balances[msg.sender] = _initialAmount;               \/\/ Give the creator all initial tokens\r\n        totalSupply = _initialAmount;                        \/\/ Update total supply\r\n        name = _tokenName;                                   \/\/ Set the name for display purposes\r\n        decimals = _decimalUnits;                            \/\/ Amount of decimals for display purposes\r\n        symbol = _tokenSymbol;                               \/\/ Set the symbol for display purposes\r\n    }\r\n\r\n    \/* Approves and then calls the receiving contract *\/\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        \/\/call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        \/\/receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        \/\/it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}",
      "officialLinks": {
        "Reddit": "",
        "Telegram": "",
        "Website": "https:\/\/qtum.org\/",
        "Email": "mailto:foundation@qtum.org",
        "Twitter": "https:\/\/twitter.com\/QtumOfficial"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x9a642d6b3368ddc662CA244bAdf32cDA716005BC#code"
    }, {
      "contractId": 8,
      "title": "Storj Token",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Storj",
      "code": "\/*\r\n * ERC20 interface\r\n * see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n *\/\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n\r\n\/**\r\n * Math operations with safety checks\r\n *\/\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a \/ b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n\/**\r\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\r\n *\r\n * Based on code by FirstBlood:\r\n * https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\n *\/\r\ncontract StandardToken is ERC20, SafeMath {\r\n\r\n  mapping(address => uint) balances;\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  \/\/ Interface marker\r\n  bool public constant isToken = true;\r\n\r\n  \/**\r\n   *\r\n   * Fix for the ERC20 short address attack\r\n   *\r\n   * http:\/\/vessenes.com\/the-erc20-short-address-attack-explained\/\r\n   *\/\r\n  modifier onlyPayloadSize(uint size) {\r\n     if(msg.data.length < size + 4) {\r\n       throw;\r\n     }\r\n     _;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value)  returns (bool success) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    \/\/ Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met\r\n    \/\/ if (_value > _allowance) throw;\r\n\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n\r\n    \/\/ To change the approve amount you first have to reduce the addresses`\r\n    \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    \/\/  already 0 to mitigate the race condition described here:\r\n    \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\/**\r\n * A trait that allows any token owner to decrease the token supply.\r\n *\r\n * We add a Burned event to differentiate from normal transfers.\r\n * However, we still try to support some legacy Ethereum ecocsystem,\r\n * as ERC-20 has not standardized on the burn event yet.\r\n *\r\n *\/\r\ncontract BurnableToken is StandardToken {\r\n\r\n  address public constant BURN_ADDRESS = 0;\r\n\r\n  \/** How many tokens we burned *\/\r\n  event Burned(address burner, uint burnedAmount);\r\n\r\n  \/**\r\n   * Burn extra tokens from a balance.\r\n   *\r\n   *\/\r\n  function burn(uint burnAmount) {\r\n    address burner = msg.sender;\r\n    balances[burner] = safeSub(balances[burner], burnAmount);\r\n    totalSupply = safeSub(totalSupply, burnAmount);\r\n    Burned(burner, burnAmount);\r\n\r\n    \/\/ Keep token balance tracking services happy by sending the burned amount to\r\n    \/\/ \"burn address\", so that it will show up as a ERC-20 transaction\r\n    \/\/ in etherscan, etc. as there is no standarized burn event yet\r\n    Transfer(burner, BURN_ADDRESS, burnAmount);\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\/**\r\n * Upgrade agent interface inspired by Lunyr.\r\n *\r\n * Upgrade agent transfers tokens to a new contract.\r\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\r\n *\/\r\ncontract UpgradeAgent {\r\n\r\n  uint public originalSupply;\r\n\r\n  \/** Interface marker *\/\r\n  function isUpgradeAgent() public constant returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  function upgradeFrom(address _from, uint256 _value) public;\r\n\r\n}\r\n\r\n\r\n\/**\r\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\r\n *\r\n * First envisioned by Golem and Lunyr projects.\r\n *\/\r\ncontract UpgradeableToken is StandardToken {\r\n\r\n  \/** Contract \/ person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. *\/\r\n  address public upgradeMaster;\r\n\r\n  \/** The next contract where the tokens will be migrated. *\/\r\n  UpgradeAgent public upgradeAgent;\r\n\r\n  \/** How many tokens we have upgraded by now. *\/\r\n  uint256 public totalUpgraded;\r\n\r\n  \/**\r\n   * Upgrade states.\r\n   *\r\n   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\r\n   * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet\r\n   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet\r\n   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\r\n   *\r\n   *\/\r\n  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\r\n\r\n  \/**\r\n   * Somebody has upgraded some of his tokens.\r\n   *\/\r\n  event Upgrade(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n  \/**\r\n   * New upgrade agent available.\r\n   *\/\r\n  event UpgradeAgentSet(address agent);\r\n\r\n  \/**\r\n   * Do not allow construction without upgrade master set.\r\n   *\/\r\n  function UpgradeableToken(address _upgradeMaster) {\r\n    upgradeMaster = _upgradeMaster;\r\n  }\r\n\r\n  \/**\r\n   * Allow the token holder to upgrade some of their tokens to a new contract.\r\n   *\/\r\n  function upgrade(uint256 value) public {\r\n\r\n      UpgradeState state = getUpgradeState();\r\n      if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\r\n        \/\/ Called in a bad state\r\n        throw;\r\n      }\r\n\r\n      \/\/ Validate input value.\r\n      if (value == 0) throw;\r\n\r\n      balances[msg.sender] = safeSub(balances[msg.sender], value);\r\n\r\n      \/\/ Take tokens out from circulation\r\n      totalSupply = safeSub(totalSupply, value);\r\n      totalUpgraded = safeAdd(totalUpgraded, value);\r\n\r\n      \/\/ Upgrade agent reissues the tokens\r\n      upgradeAgent.upgradeFrom(msg.sender, value);\r\n      Upgrade(msg.sender, upgradeAgent, value);\r\n  }\r\n\r\n  \/**\r\n   * Set an upgrade agent that handles\r\n   *\/\r\n  function setUpgradeAgent(address agent) external {\r\n\r\n      if(!canUpgrade()) {\r\n        \/\/ The token is not yet in a state that we could think upgrading\r\n        throw;\r\n      }\r\n\r\n      if (agent == 0x0) throw;\r\n      \/\/ Only a master can designate the next agent\r\n      if (msg.sender != upgradeMaster) throw;\r\n      \/\/ Upgrade has already begun for an agent\r\n      if (getUpgradeState() == UpgradeState.Upgrading) throw;\r\n\r\n      upgradeAgent = UpgradeAgent(agent);\r\n\r\n      \/\/ Bad interface\r\n      if(!upgradeAgent.isUpgradeAgent()) throw;\r\n      \/\/ Make sure that token supplies match in source and target\r\n      if (upgradeAgent.originalSupply() != totalSupply) throw;\r\n\r\n      UpgradeAgentSet(upgradeAgent);\r\n  }\r\n\r\n  \/**\r\n   * Get the state of the token upgrade.\r\n   *\/\r\n  function getUpgradeState() public constant returns(UpgradeState) {\r\n    if(!canUpgrade()) return UpgradeState.NotAllowed;\r\n    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\r\n    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\r\n    else return UpgradeState.Upgrading;\r\n  }\r\n\r\n  \/**\r\n   * Change the upgrade master.\r\n   *\r\n   * This allows us to set a new owner for the upgrade mechanism.\r\n   *\/\r\n  function setUpgradeMaster(address master) public {\r\n      if (master == 0x0) throw;\r\n      if (msg.sender != upgradeMaster) throw;\r\n      upgradeMaster = master;\r\n  }\r\n\r\n  \/**\r\n   * Child contract can enable to provide the condition when the upgrade can begun.\r\n   *\/\r\n  function canUpgrade() public constant returns(bool) {\r\n     return true;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\/**\r\n * Centrally issued Ethereum token.\r\n *\r\n * We mix in burnable and upgradeable traits.\r\n *\r\n * Token supply is created in the token contract creation and allocated to owner.\r\n * The owner can then transfer from its supply to crowdsale participants.\r\n * The owner, or anybody, can burn any excessive tokens they are holding.\r\n *\r\n *\/\r\ncontract CentrallyIssuedToken is BurnableToken, UpgradeableToken {\r\n\r\n  string public name;\r\n  string public symbol;\r\n  uint public decimals;\r\n\r\n  function CentrallyIssuedToken(address _owner, string _name, string _symbol, uint _totalSupply, uint _decimals)  UpgradeableToken(_owner) {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    totalSupply = _totalSupply;\r\n    decimals = _decimals;\r\n\r\n    \/\/ Allocate initial balance to the owner\r\n    balances[_owner] = _totalSupply;\r\n  }\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/storj\/",
        "Telegram": "",
        "Website": "https:\/\/storj.io\/",
        "Email": "https:\/\/storj.io\/contact.html",
        "Twitter": "https:\/\/twitter.com\/storjproject"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xb64ef51c888972c908cfacf59b47c1afbc0ab8ac#code"
    }, {
      "contractId": 9,
      "title": "BAToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "BAT",
      "code": "pragma solidity ^0.4.10;\r\n\r\n\/* taking ideas from FirstBlood token *\/\r\ncontract SafeMath {\r\n\r\n    \/* function assert(bool assertion) internal { *\/\r\n    \/*   if (!assertion) { *\/\r\n    \/*     throw; *\/\r\n    \/*   } *\/\r\n    \/* }      \/\/ assert no longer needed once solidity is on 0.4.10 *\/\r\n\r\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\r\n      uint256 z = x + y;\r\n      assert((z >= x) && (z >= y));\r\n      return z;\r\n    }\r\n\r\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\r\n      assert(x >= y);\r\n      uint256 z = x - y;\r\n      return z;\r\n    }\r\n\r\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\r\n      uint256 z = x * y;\r\n      assert((x == 0)||(z\/x == y));\r\n      return z;\r\n    }\r\n\r\n}\r\n\r\ncontract Token {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n\/*  ERC 20 token *\/\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n      if (balances[msg.sender] >= _value && _value > 0) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}\r\n\r\ncontract BAToken is StandardToken, SafeMath {\r\n\r\n    \/\/ metadata\r\n    string public constant name = \"Basic Attention Token\";\r\n    string public constant symbol = \"BAT\";\r\n    uint256 public constant decimals = 18;\r\n    string public version = \"1.0\";\r\n\r\n    \/\/ contracts\r\n    address public ethFundDeposit;      \/\/ deposit address for ETH for Brave International\r\n    address public batFundDeposit;      \/\/ deposit address for Brave International use and BAT User Fund\r\n\r\n    \/\/ crowdsale parameters\r\n    bool public isFinalized;              \/\/ switched to true in operational state\r\n    uint256 public fundingStartBlock;\r\n    uint256 public fundingEndBlock;\r\n    uint256 public constant batFund = 500 * (10**6) * 10**decimals;   \/\/ 500m BAT reserved for Brave Intl use\r\n    uint256 public constant tokenExchangeRate = 6400; \/\/ 6400 BAT tokens per 1 ETH\r\n    uint256 public constant tokenCreationCap =  1500 * (10**6) * 10**decimals;\r\n    uint256 public constant tokenCreationMin =  675 * (10**6) * 10**decimals;\r\n\r\n\r\n    \/\/ events\r\n    event LogRefund(address indexed _to, uint256 _value);\r\n    event CreateBAT(address indexed _to, uint256 _value);\r\n\r\n    \/\/ constructor\r\n    function BAToken(\r\n        address _ethFundDeposit,\r\n        address _batFundDeposit,\r\n        uint256 _fundingStartBlock,\r\n        uint256 _fundingEndBlock)\r\n    {\r\n      isFinalized = false;                   \/\/controls pre through crowdsale state\r\n      ethFundDeposit = _ethFundDeposit;\r\n      batFundDeposit = _batFundDeposit;\r\n      fundingStartBlock = _fundingStartBlock;\r\n      fundingEndBlock = _fundingEndBlock;\r\n      totalSupply = batFund;\r\n      balances[batFundDeposit] = batFund;    \/\/ Deposit Brave Intl share\r\n      CreateBAT(batFundDeposit, batFund);  \/\/ logs Brave Intl fund\r\n    }\r\n\r\n    \/\/\/ @dev Accepts ether and creates new BAT tokens.\r\n    function createTokens() payable external {\r\n      if (isFinalized) throw;\r\n      if (block.number < fundingStartBlock) throw;\r\n      if (block.number > fundingEndBlock) throw;\r\n      if (msg.value == 0) throw;\r\n\r\n      uint256 tokens = safeMult(msg.value, tokenExchangeRate); \/\/ check that we're not over totals\r\n      uint256 checkedSupply = safeAdd(totalSupply, tokens);\r\n\r\n      \/\/ return money if something goes wrong\r\n      if (tokenCreationCap < checkedSupply) throw;  \/\/ odd fractions won't be found\r\n\r\n      totalSupply = checkedSupply;\r\n      balances[msg.sender] += tokens;  \/\/ safeAdd not needed; bad semantics to use here\r\n      CreateBAT(msg.sender, tokens);  \/\/ logs token creation\r\n    }\r\n\r\n    \/\/\/ @dev Ends the funding period and sends the ETH home\r\n    function finalize() external {\r\n      if (isFinalized) throw;\r\n      if (msg.sender != ethFundDeposit) throw; \/\/ locks finalize to the ultimate ETH owner\r\n      if(totalSupply < tokenCreationMin) throw;      \/\/ have to sell minimum to move to operational\r\n      if(block.number <= fundingEndBlock && totalSupply != tokenCreationCap) throw;\r\n      \/\/ move to operational\r\n      isFinalized = true;\r\n      if(!ethFundDeposit.send(this.balance)) throw;  \/\/ send the eth to Brave International\r\n    }\r\n\r\n    \/\/\/ @dev Allows contributors to recover their ether in the case of a failed funding campaign.\r\n    function refund() external {\r\n      if(isFinalized) throw;                       \/\/ prevents refund if operational\r\n      if (block.number <= fundingEndBlock) throw; \/\/ prevents refund until sale period is over\r\n      if(totalSupply >= tokenCreationMin) throw;  \/\/ no refunds if we sold enough\r\n      if(msg.sender == batFundDeposit) throw;    \/\/ Brave Intl not entitled to a refund\r\n      uint256 batVal = balances[msg.sender];\r\n      if (batVal == 0) throw;\r\n      balances[msg.sender] = 0;\r\n      totalSupply = safeSubtract(totalSupply, batVal); \/\/ extra safe\r\n      uint256 ethVal = batVal \/ tokenExchangeRate;     \/\/ should be safe; previous throws covers edges\r\n      LogRefund(msg.sender, ethVal);               \/\/ log it \r\n      if (!msg.sender.send(ethVal)) throw;       \/\/ if you're using a contract; make sure it works with .send gas limits\r\n    }\r\n\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/BATProject\/",
        "Telegram": "",
        "Website": "https:\/\/basicattentiontoken.org\/",
        "Email": "mailto:https:\/\/medium.com\/@attentiontoken",
        "Twitter": "https:\/\/twitter.com\/@attentiontoken"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x0D8775F648430679A709E98d2b0Cb6250d2887EF#code"
    }, {
      "contractId": 10,
      "title": "Salt",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Salt",
      "code": "pragma solidity ^0.4.8;\r\n\r\n\r\ncontract Token {\r\n    uint256 public totalSupply;\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}\r\n\r\ncontract Salt is StandardToken {\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    string public version = '1.0';\r\n\r\n    function Salt() {\r\n        balances[msg.sender] = 12000000000000000;               \/\/ Give the creator all initial tokens\r\n        totalSupply = 12000000000000000;                        \/\/ Update total supply\r\n        name = 'Salt';                                   \/\/ Set the name for display purposes\r\n        decimals = 8;                            \/\/ Amount of decimals for display purposes\r\n        symbol = 'SALT';                               \/\/ Set the symbol for display purposes\r\n    }\r\n}",
      "officialLinks": {
        "Reddit": "",
        "Telegram": "https:\/\/t.me\/joinchat\/BmtZ5kKgf4ekiNLggHRDmQ",
        "Website": "https:\/\/saltlending.com\/",
        "Email": "mailto:support@saltlending.com",
        "Twitter": "https:\/\/twitter.com\/SALTLending"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x4156D3342D5c385a87D264F90653733592000581#code"
    }, {
      "contractId": 11,
      "title": " Civic Token",
      "category": "ERC20",
      "tag": "ERC20",
      "author": " Civic",
      "code": "\/*\r\n * ERC20 interface\r\n * see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n *\/\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\/**\r\n * Math operations with safety checks\r\n *\/\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a \/ b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n\/**\r\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\r\n *\r\n * Based on code by FirstBlood:\r\n * https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\n *\/\r\ncontract StandardToken is ERC20, SafeMath {\r\n\r\n  \/* Actual balances of token holders *\/\r\n  mapping(address => uint) balances;\r\n\r\n  \/* approve() allowances *\/\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  \/* Interface declaration *\/\r\n  function isToken() public constant returns (bool weAre) {\r\n    return true;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) returns (bool success) {\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n    uint _allowance = allowed[_from][msg.sender];\r\n\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n\r\n    \/\/ To change the approve amount you first have to reduce the addresses`\r\n    \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    \/\/  already 0 to mitigate the race condition described here:\r\n    \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n\r\n\/**\r\n * Upgrade agent interface inspired by Lunyr.\r\n *\r\n * Upgrade agent transfers tokens to a new version of a token contract.\r\n * Upgrade agent can be set on a token by the upgrade master.\r\n *\r\n * Steps are\r\n * - Upgradeabletoken.upgradeMaster calls UpgradeableToken.setUpgradeAgent()\r\n * - Individual token holders can now call UpgradeableToken.upgrade()\r\n *   -> This results to call UpgradeAgent.upgradeFrom() that issues new tokens\r\n *   -> UpgradeableToken.upgrade() reduces the original total supply based on amount of upgraded tokens\r\n *\r\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\r\n *\/\r\ncontract UpgradeAgent {\r\n\r\n  uint public originalSupply;\r\n\r\n  \/** Interface marker *\/\r\n  function isUpgradeAgent() public constant returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   * Upgrade amount of tokens to a new version.\r\n   *\r\n   * Only callable by UpgradeableToken.\r\n   *\r\n   * @param _tokenHolder Address that wants to upgrade its tokens\r\n   * @param _amount Number of tokens to upgrade. The address may consider to hold back some amount of tokens in the old version.\r\n   *\/\r\n  function upgradeFrom(address _tokenHolder, uint256 _amount) external;\r\n}\r\n\r\n\r\n\/**\r\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\r\n *\r\n * First envisioned by Golem and Lunyr projects.\r\n *\/\r\ncontract UpgradeableToken is StandardToken {\r\n\r\n  \/** Contract \/ person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. *\/\r\n  address public upgradeMaster;\r\n\r\n  \/** The next contract where the tokens will be migrated. *\/\r\n  UpgradeAgent public upgradeAgent;\r\n\r\n  \/** How many tokens we have upgraded by now. *\/\r\n  uint256 public totalUpgraded;\r\n\r\n  \/**\r\n   * Upgrade states.\r\n   *\r\n   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\r\n   * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet\r\n   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet\r\n   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\r\n   *\r\n   *\/\r\n  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\r\n\r\n  \/**\r\n   * Somebody has upgraded some of his tokens.\r\n   *\/\r\n  event Upgrade(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n  \/**\r\n   * New upgrade agent available.\r\n   *\/\r\n  event UpgradeAgentSet(address agent);\r\n\r\n  \/**\r\n   * Upgrade master updated.\r\n   *\/\r\n  event NewUpgradeMaster(address upgradeMaster);\r\n\r\n  \/**\r\n   * Do not allow construction without upgrade master set.\r\n   *\/\r\n  function UpgradeableToken(address _upgradeMaster) {\r\n    upgradeMaster = _upgradeMaster;\r\n    NewUpgradeMaster(upgradeMaster);\r\n  }\r\n\r\n  \/**\r\n   * Allow the token holder to upgrade some of their tokens to a new contract.\r\n   *\/\r\n  function upgrade(uint256 value) public {\r\n\r\n      UpgradeState state = getUpgradeState();\r\n      if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\r\n        \/\/ Called in a bad state\r\n        throw;\r\n      }\r\n\r\n      \/\/ Validate input value.\r\n      if (value == 0) throw;\r\n\r\n      balances[msg.sender] = safeSub(balances[msg.sender], value);\r\n\r\n      \/\/ Take tokens out from circulation\r\n      totalSupply = safeSub(totalSupply, value);\r\n      totalUpgraded = safeAdd(totalUpgraded, value);\r\n\r\n      \/\/ Upgrade agent reissues the tokens\r\n      upgradeAgent.upgradeFrom(msg.sender, value);\r\n      Upgrade(msg.sender, upgradeAgent, value);\r\n  }\r\n\r\n  \/**\r\n   * Set an upgrade agent that handles\r\n   *\/\r\n  function setUpgradeAgent(address agent) external {\r\n\r\n      if(!canUpgrade()) {\r\n        \/\/ The token is not yet in a state that we could think upgrading\r\n        throw;\r\n      }\r\n\r\n      if (agent == 0x0) throw;\r\n      \/\/ Only a master can designate the next agent\r\n      if (msg.sender != upgradeMaster) throw;\r\n      \/\/ Upgrade has already begun for an agent\r\n      if (getUpgradeState() == UpgradeState.Upgrading) throw;\r\n\r\n      upgradeAgent = UpgradeAgent(agent);\r\n\r\n      \/\/ Bad interface\r\n      if(!upgradeAgent.isUpgradeAgent()) throw;\r\n      \/\/ Make sure that token supplies match in source and target\r\n      if (upgradeAgent.originalSupply() != totalSupply) throw;\r\n\r\n      UpgradeAgentSet(upgradeAgent);\r\n  }\r\n\r\n  \/**\r\n   * Get the state of the token upgrade.\r\n   *\/\r\n  function getUpgradeState() public constant returns(UpgradeState) {\r\n    if(!canUpgrade()) return UpgradeState.NotAllowed;\r\n    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\r\n    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\r\n    else return UpgradeState.Upgrading;\r\n  }\r\n\r\n  \/**\r\n   * Change the upgrade master.\r\n   *\r\n   * This allows us to set a new owner for the upgrade mechanism.\r\n   *\/\r\n  function setUpgradeMaster(address master) public {\r\n      if (master == 0x0) throw;\r\n      if (msg.sender != upgradeMaster) throw;\r\n      upgradeMaster = master;\r\n      NewUpgradeMaster(upgradeMaster);\r\n  }\r\n\r\n  \/**\r\n   * Child contract can enable to provide the condition when the upgrade can begun.\r\n   *\/\r\n  function canUpgrade() public constant returns(bool) {\r\n     return true;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\/**\r\n * Centrally issued Ethereum token.\r\n *\r\n * We mix in burnable and upgradeable traits.\r\n *\r\n * Token supply is created in the token contract creation and allocated to owner.\r\n * The owner can then transfer from its supply to crowdsale participants.\r\n * The owner, or anybody, can burn any excessive tokens they are holding.\r\n *\r\n *\/\r\ncontract CentrallyIssuedToken is UpgradeableToken {\r\n\r\n  string public name;\r\n  string public symbol;\r\n  uint public decimals;\r\n\r\n  \/** Name and symbol were updated. *\/\r\n  event UpdatedTokenInformation(string newName, string newSymbol);\r\n\r\n  function CentrallyIssuedToken(address _owner, string _name, string _symbol, uint _totalSupply, uint _decimals)  UpgradeableToken(_owner) {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    totalSupply = _totalSupply;\r\n    decimals = _decimals;\r\n\r\n    \/\/ Allocate initial balance to the owner\r\n    balances[_owner] = _totalSupply;\r\n  }\r\n\r\n  \/**\r\n   * Owner can update token information here.\r\n   *\r\n   * It is often useful to conceal the actual token association, until\r\n   * the token operations, like central issuance or reissuance have been completed.\r\n   * In this case the initial token can be supplied with empty name and symbol information.\r\n   *\r\n   * This function allows the token owner to rename the token after the operations\r\n   * have been completed and then point the audience to use the token contract.\r\n   *\/\r\n  function setTokenInformation(string _name, string _symbol) {\r\n\r\n    if(msg.sender != upgradeMaster) {\r\n      throw;\r\n    }\r\n\r\n    if(bytes(name).length > 0 || bytes(symbol).length > 0) {\r\n      \/\/ Information already set\r\n      \/\/ Allow owner to set this information only once\r\n      throw;\r\n    }\r\n\r\n    name = _name;\r\n    symbol = _symbol;\r\n    UpdatedTokenInformation(name, symbol);\r\n  }\r\n\r\n}",
      "officialLinks": {
        "Reddit": "",
        "Telegram": "https:\/\/t.me\/civicplatform",
        "Website": "https:\/\/www.civic.com\/",
        "Email": "",
        "Twitter": "https:\/\/twitter.com\/civickey"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x41e5560054824ea6b0732e656e3ad64e20e94e45#code"
    }, {
      "contractId": 12,
      "title": "ZRXToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "ZRX",
      "code": "\/*\r\n\r\n  Copyright 2017 ZeroEx Intl.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n    http:\/\/www.apache.org\/licenses\/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*\/\r\n\r\npragma solidity 0.4.11;\r\n\r\ncontract Token {\r\n\r\n    \/\/\/ @return total amount of tokens\r\n    function totalSupply() constant returns (uint supply) {}\r\n\r\n    \/\/\/ @param _owner The address from which the balance will be retrieved\r\n    \/\/\/ @return The balance\r\n    function balanceOf(address _owner) constant returns (uint balance) {}\r\n\r\n    \/\/\/ @notice send `_value` token to `_to` from `msg.sender`\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _value The amount of token to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint _value) returns (bool success) {}\r\n\r\n    \/\/\/ @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    \/\/\/ @param _from The address of the sender\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _value The amount of token to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\r\n\r\n    \/\/\/ @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @param _value The amount of wei to be approved for transfer\r\n    \/\/\/ @return Whether the approval was successful or not\r\n    function approve(address _spender, uint _value) returns (bool success) {}\r\n\r\n    \/\/\/ @param _owner The address of the account owning tokens\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint _value) returns (bool) {\r\n        \/\/Default assumes totalSupply can't be over max (2^256 - 1).\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n    uint public totalSupply;\r\n}\r\n\r\ncontract UnlimitedAllowanceToken is StandardToken {\r\n\r\n    uint constant MAX_UINT = 2**256 - 1;\r\n    \r\n    \/\/\/ @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited allowance.\r\n    \/\/\/ @param _from Address to transfer from.\r\n    \/\/\/ @param _to Address to transfer to.\r\n    \/\/\/ @param _value Amount to transfer.\r\n    \/\/\/ @return Success of transfer.\r\n    function transferFrom(address _from, address _to, uint _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint allowance = allowed[_from][msg.sender];\r\n        if (balances[_from] >= _value\r\n            && allowance >= _value\r\n            && balances[_to] + _value >= balances[_to]\r\n        ) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            if (allowance < MAX_UINT) {\r\n                allowed[_from][msg.sender] -= _value;\r\n            }\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\ncontract ZRXToken is UnlimitedAllowanceToken {\r\n\r\n    uint8 constant public decimals = 18;\r\n    uint public totalSupply = 10**27; \/\/ 1 billion tokens, 18 decimal places\r\n    string constant public name = \"0x Protocol Token\";\r\n    string constant public symbol = \"ZRX\";\r\n\r\n    function ZRXToken() {\r\n        balances[msg.sender] = totalSupply;\r\n    }\r\n}",
      "officialLinks": {
        "Reddit": "",
        "Telegram": "",
        "Website": "https:\/\/0xproject.com\/",
        "Email": "",
        "Twitter": "https:\/\/twitter.com\/0xproject"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xe41d2489571d322189246dafa5ebde1f4699f498#code"
    }, {
      "contractId": 13,
      "title": "RepToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "REP",
      "code": "pragma solidity ^0.4.11;\r\n\r\n\/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n *\/\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\n    uint256 c = a \/ b;\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/179\r\n *\/\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) constant returns (uint256);\r\n  function transfer(address to, uint256 value) returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n\/**\r\n * @title ERC20 interface\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n *\/\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) returns (bool);\r\n  function approve(address spender, uint256 value) returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n *\/\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  \/**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  *\/\r\n  function transfer(address _to, uint256 _value) returns (bool) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  *\/\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n\r\n\/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n * @dev Based on code by FirstBlood: https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\n *\/\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  \/**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amout of tokens to be transfered\r\n   *\/\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    \/\/ Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    \/\/ require (_value <= _allowance);\r\n\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   *\/\r\n  function approve(address _spender, uint256 _value) returns (bool) {\r\n\r\n    \/\/ To change the approve amount you first have to reduce the addresses`\r\n    \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    \/\/  already 0 to mitigate the race condition described here:\r\n    \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifing the amount of tokens still avaible for the spender.\r\n   *\/\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n\r\n\/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n *\/\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  \/**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   *\/\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  \/**\r\n   * @dev Throws if called by any account other than the owner.\r\n   *\/\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  \/**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   *\/\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n\/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n *\/\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  \/**\r\n   * @dev modifier to allow actions only when the contract IS paused\r\n   *\/\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev modifier to allow actions only when the contract IS NOT paused\r\n   *\/\r\n  modifier whenPaused {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   *\/\r\n  function pause() onlyOwner whenNotPaused returns (bool) {\r\n    paused = true;\r\n    Pause();\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   *\/\r\n  function unpause() onlyOwner whenPaused returns (bool) {\r\n    paused = false;\r\n    Unpause();\r\n    return true;\r\n  }\r\n}\r\n\r\n\/**\r\n * Pausable token\r\n *\r\n * Simple ERC20 Token example, with pausable token creation\r\n **\/\r\n\r\ncontract PausableToken is StandardToken, Pausable {\r\n\r\n  function transfer(address _to, uint _value) whenNotPaused returns (bool) {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) whenNotPaused returns (bool) {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n}\r\n\r\n\r\ncontract Initializable {\r\n  bool public initialized = false;\r\n\r\n  modifier afterInitialized {\r\n    require(initialized);\r\n    _;\r\n  }\r\n\r\n  modifier beforeInitialized {\r\n    require(!initialized);\r\n    _;\r\n  }\r\n\r\n  function endInitialization() internal beforeInitialized returns (bool) {\r\n    initialized = true;\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\n\/**\r\n * @title REP2 Token\r\n * @dev REP2 Mintable Token with migration from legacy contract\r\n *\/\r\ncontract RepToken is Initializable, PausableToken {\r\n  ERC20Basic public legacyRepContract;\r\n  uint256 public targetSupply;\r\n\r\n  string public constant name = \"Reputation\";\r\n  string public constant symbol = \"REP\";\r\n  uint256 public constant decimals = 18;\r\n\r\n  event Migrated(address indexed holder, uint256 amount);\r\n\r\n  \/**\r\n    * @dev Creates a new RepToken instance\r\n    * @param _legacyRepContract Address of the legacy ERC20Basic REP contract to migrate balances from\r\n    *\/\r\n  function RepToken(address _legacyRepContract, uint256 _amountUsedToFreeze, address _accountToSendFrozenRepTo) {\r\n    require(_legacyRepContract != 0);\r\n    legacyRepContract = ERC20Basic(_legacyRepContract);\r\n    targetSupply = legacyRepContract.totalSupply();\r\n    balances[_accountToSendFrozenRepTo] = _amountUsedToFreeze;\r\n    totalSupply = _amountUsedToFreeze;\r\n    pause();\r\n  }\r\n\r\n  \/**\r\n    * @dev Copies the balance of a batch of addresses from the legacy contract\r\n    * @param _holders Array of addresses to migrate balance\r\n    * @return True if operation was completed\r\n    *\/\r\n  function migrateBalances(address[] _holders) onlyOwner beforeInitialized returns (bool) {\r\n    for (uint256 i = 0; i < _holders.length; i++) {\r\n      migrateBalance(_holders[i]);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n    * @dev Copies the balance of a single addresses from the legacy contract\r\n    * @param _holder Address to migrate balance\r\n    * @return True if balance was copied, false if was already copied or address had no balance\r\n    *\/\r\n  function migrateBalance(address _holder) onlyOwner beforeInitialized returns (bool) {\r\n    if (balances[_holder] > 0) {\r\n      return false; \/\/ Already copied, move on\r\n    }\r\n\r\n    uint256 amount = legacyRepContract.balanceOf(_holder);\r\n    if (amount == 0) {\r\n      return false; \/\/ Has no balance in legacy contract, move on\r\n    }\r\n\r\n    balances[_holder] = amount;\r\n    totalSupply = totalSupply.add(amount);\r\n    Migrated(_holder, amount);\r\n\r\n    if (targetSupply == totalSupply) {\r\n      endInitialization();\r\n    }\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n    * @dev Unpauses the contract with the caveat added that it can only happen after initialization.\r\n    *\/\r\n  function unpause() onlyOwner whenPaused afterInitialized returns (bool) {\r\n    super.unpause();\r\n    return true;\r\n  }\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/augur",
        "Telegram": "",
        "Website": "https:\/\/www.augur.net\/",
        "Email": "mailto:team@augur.net",
        "Twitter": "https:\/\/twitter.com\/AugurProject"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xe94327d07fc17907b4db788e5adf2ed424addff6#code"
    }, {
      "contractId": 14,
      "title": "District0xNetworkToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "district0x",
      "code": "pragma solidity ^0.4.11;\r\n\r\n\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\n    uint c = a \/ b;\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n\r\n    \/\/\/ @dev `owner` is the only address that can call a function with this\r\n    \/\/\/ modifier\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    address public owner;\r\n\r\n    \/\/\/ @notice The Constructor assigns the message sender to be `owner`\r\n    function Ownable() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    address public newOwner;\r\n\r\n    \/\/\/ @notice `owner` can step down and assign some other address to this role\r\n    \/\/\/ @param _newOwner The address of the new owner.\r\n    function changeOwner(address _newOwner) onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n\r\n    function acceptOwnership() {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n  bool public stopped;\r\n  event onEmergencyChanged(bool isStopped);\r\n\r\n  modifier stopInEmergency {\r\n    if (stopped) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  modifier onlyInEmergency {\r\n    if (!stopped) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  \/\/ called by the owner on emergency, triggers stopped state\r\n  function emergencyStop() external onlyOwner {\r\n    stopped = true;\r\n    onEmergencyChanged(stopped);\r\n  }\r\n\r\n  \/\/ called by the owner on end of emergency, returns to normal state\r\n  function release() external onlyOwner onlyInEmergency {\r\n    stopped = false;\r\n    onEmergencyChanged(stopped);\r\n  }\r\n\r\n}\r\n\r\ncontract ERC20Basic {\r\n  function totalSupply() constant returns (uint);\r\n  function balanceOf(address who) constant returns (uint);\r\n  function transfer(address to, uint value) returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n\r\n  mapping(address => uint) balances;\r\n\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n  function transferFrom(address from, address to, uint value) returns (bool);\r\n  function approve(address spender, uint value) returns (bool);\r\n  function approveAndCall(address spender, uint256 value, bytes extraData) returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n  function doTransfer(address _from, address _to, uint _amount) internal returns(bool);\r\n}\r\n\r\ncontract GrantsControlled {\r\n    modifier onlyGrantsController { if (msg.sender != grantsController) throw; _; }\r\n\r\n    address public grantsController;\r\n\r\n    function GrantsControlled() { grantsController = msg.sender;}\r\n\r\n    function changeGrantsController(address _newController) onlyGrantsController {\r\n        grantsController = _newController;\r\n    }\r\n}\r\n\r\ncontract LimitedTransferToken is ERC20 {\r\n  \/\/ Checks whether it can transfer or otherwise throws.\r\n  modifier canTransfer(address _sender, uint _value) {\r\n   if (_value > transferableTokens(_sender, uint64(now))) throw;\r\n   _;\r\n  }\r\n\r\n  \/\/ Checks modifier and allows transfer if tokens are not locked.\r\n  function transfer(address _to, uint _value) canTransfer(msg.sender, _value) returns (bool) {\r\n   return super.transfer(_to, _value);\r\n  }\r\n\r\n  \/\/ Checks modifier and allows transfer if tokens are not locked.\r\n  function transferFrom(address _from, address _to, uint _value) canTransfer(_from, _value) returns (bool) {\r\n   return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n  \/\/ Default transferable tokens function returns all tokens for a holder (no limit).\r\n  function transferableTokens(address holder, uint64 time) constant public returns (uint256) {\r\n    return balanceOf(holder);\r\n  }\r\n}\r\n\r\ncontract Controlled {\r\n    \/\/\/ @notice The address of the controller is the only address that can call\r\n    \/\/\/  a function with this modifier\r\n    modifier onlyController { if (msg.sender != controller) throw; _; }\r\n\r\n    address public controller;\r\n\r\n    function Controlled() { controller = msg.sender;}\r\n\r\n    \/\/\/ @notice Changes the controller of the contract\r\n    \/\/\/ @param _newController The new controller of the contract\r\n    function changeController(address _newController) onlyController {\r\n        controller = _newController;\r\n    }\r\n}\r\n\r\ncontract MiniMeToken is ERC20, Controlled {\r\n    using SafeMath for uint;\r\n\r\n    string public name;                \/\/The Token's name: e.g. DigixDAO Tokens\r\n    uint8 public decimals;             \/\/Number of decimals of the smallest unit\r\n    string public symbol;              \/\/An identifier: e.g. REP\r\n    string public version = 'MMT_0.1'; \/\/An arbitrary versioning scheme\r\n\r\n\r\n    \/\/\/ @dev `Checkpoint` is the structure that attaches a block number to a\r\n    \/\/\/  given value, the block number attached is the one that last changed the\r\n    \/\/\/  value\r\n    struct  Checkpoint {\r\n\r\n        \/\/ `fromBlock` is the block number that the value was generated from\r\n        uint128 fromBlock;\r\n\r\n        \/\/ `value` is the amount of tokens at a specific block number\r\n        uint128 value;\r\n    }\r\n\r\n    \/\/ `parentToken` is the Token address that was cloned to produce this token;\r\n    \/\/  it will be 0x0 for a token that was not cloned\r\n    MiniMeToken public parentToken;\r\n\r\n    \/\/ `parentSnapShotBlock` is the block number from the Parent Token that was\r\n    \/\/  used to determine the initial distribution of the Clone Token\r\n    uint public parentSnapShotBlock;\r\n\r\n    \/\/ `creationBlock` is the block number that the Clone Token was created\r\n    uint public creationBlock;\r\n\r\n    \/\/ `balances` is the map that tracks the balance of each address, in this\r\n    \/\/  contract when the balance changes the block number that the change\r\n    \/\/  occurred is also included in the map\r\n    mapping (address => Checkpoint[]) balances;\r\n\r\n    \/\/ `allowed` tracks any extra transfer rights as in all ERC20 tokens\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    \/\/ Tracks the history of the `totalSupply` of the token\r\n    Checkpoint[] totalSupplyHistory;\r\n\r\n    \/\/ Flag that determines if the token is transferable or not.\r\n    bool public transfersEnabled;\r\n\r\n    \/\/ The factory used to create new clone tokens\r\n    MiniMeTokenFactory public tokenFactory;\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Constructor\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice Constructor to create a MiniMeToken\r\n    \/\/\/ @param _tokenFactory The address of the MiniMeTokenFactory contract that\r\n    \/\/\/  will create the Clone token contracts, the token factory needs to be\r\n    \/\/\/  deployed first\r\n    \/\/\/ @param _parentToken Address of the parent token, set to 0x0 if it is a\r\n    \/\/\/  new token\r\n    \/\/\/ @param _parentSnapShotBlock Block of the parent token that will\r\n    \/\/\/  determine the initial distribution of the clone token, set to 0 if it\r\n    \/\/\/  is a new token\r\n    \/\/\/ @param _tokenName Name of the new token\r\n    \/\/\/ @param _decimalUnits Number of decimals of the new token\r\n    \/\/\/ @param _tokenSymbol Token Symbol for the new token\r\n    \/\/\/ @param _transfersEnabled If true, tokens will be able to be transferred\r\n    function MiniMeToken(\r\n        address _tokenFactory,\r\n        address _parentToken,\r\n        uint _parentSnapShotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    ) {\r\n        tokenFactory = MiniMeTokenFactory(_tokenFactory);\r\n        name = _tokenName;                                 \/\/ Set the name\r\n        decimals = _decimalUnits;                          \/\/ Set the decimals\r\n        symbol = _tokenSymbol;                             \/\/ Set the symbol\r\n        parentToken = MiniMeToken(_parentToken);\r\n        parentSnapShotBlock = _parentSnapShotBlock;\r\n        transfersEnabled = _transfersEnabled;\r\n        creationBlock = block.number;\r\n    }\r\n\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ ERC20 Methods\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice Send `_amount` tokens to `_to` from `msg.sender`\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _amount The amount of tokens to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _amount) returns (bool success) {\r\n        if (!transfersEnabled) throw;\r\n        return doTransfer(msg.sender, _to, _amount);\r\n    }\r\n\r\n    \/\/\/ @notice Send `_amount` tokens to `_to` from `_from` on the condition it\r\n    \/\/\/  is approved by `_from`\r\n    \/\/\/ @param _from The address holding the tokens being transferred\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _amount The amount of tokens to be transferred\r\n    \/\/\/ @return True if the transfer was successful\r\n    function transferFrom(address _from, address _to, uint256 _amount\r\n    ) returns (bool success) {\r\n\r\n        \/\/ The controller of this contract can move tokens around at will,\r\n        \/\/  this is important to recognize! Confirm that you trust the\r\n        \/\/  controller of this contract, which in most situations should be\r\n        \/\/  another open source smart contract or 0x0\r\n        if (msg.sender != controller) {\r\n            if (!transfersEnabled) throw;\r\n\r\n            \/\/ The standard ERC 20 transferFrom functionality\r\n            if (allowed[_from][msg.sender] < _amount) return false;\r\n            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\r\n        }\r\n        return doTransfer(_from, _to, _amount);\r\n    }\r\n\r\n    \/\/\/ @dev This is the actual transfer function in the token contract, it can\r\n    \/\/\/  only be called by other functions in this contract.\r\n    \/\/\/ @param _from The address holding the tokens being transferred\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _amount The amount of tokens to be transferred\r\n    \/\/\/ @return True if the transfer was successful\r\n    function doTransfer(address _from, address _to, uint _amount\r\n    ) internal returns(bool) {\r\n\r\n           if (_amount == 0) {\r\n               return true;\r\n           }\r\n\r\n           if (parentSnapShotBlock >= block.number) throw;\r\n\r\n           \/\/ Do not allow transfer to 0x0 or the token contract itself\r\n           if ((_to == 0) || (_to == address(this))) throw;\r\n\r\n           \/\/ If the amount being transfered is more than the balance of the\r\n           \/\/  account the transfer returns false\r\n           var previousBalanceFrom = balanceOfAt(_from, block.number);\r\n           if (previousBalanceFrom < _amount) {\r\n               return false;\r\n           }\r\n\r\n           \/\/ Alerts the token controller of the transfer\r\n           if (isContract(controller)) {\r\n               if (!TokenController(controller).onTransfer(_from, _to, _amount))\r\n               throw;\r\n           }\r\n\r\n           \/\/ First update the balance array with the new value for the address\r\n           \/\/  sending the tokens\r\n           updateValueAtNow(balances[_from], previousBalanceFrom.sub(_amount));\r\n\r\n           \/\/ Then update the balance array with the new value for the address\r\n           \/\/  receiving the tokens\r\n           var previousBalanceTo = balanceOfAt(_to, block.number);\r\n           updateValueAtNow(balances[_to], previousBalanceTo.add(_amount));\r\n\r\n           \/\/ An event to make the transfer easy to find on the blockchain\r\n           Transfer(_from, _to, _amount);\r\n\r\n           return true;\r\n    }\r\n\r\n    \/\/\/ @param _owner The address that's balance is being requested\r\n    \/\/\/ @return The balance of `_owner` at the current block\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balanceOfAt(_owner, block.number);\r\n    }\r\n\r\n    \/\/\/ @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\r\n    \/\/\/  its behalf. This is a modified version of the ERC20 approve function\r\n    \/\/\/  to be a little bit safer\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @param _amount The amount of tokens to be approved for transfer\r\n    \/\/\/ @return True if the approval was successful\r\n    function approve(address _spender, uint256 _amount) returns (bool success) {\r\n        if (!transfersEnabled) throw;\r\n\r\n        \/\/ To change the approve amount you first have to reduce the addresses`\r\n        \/\/  allowance to zero by calling `approve(_spender,0)` if it is not\r\n        \/\/  already 0 to mitigate the race condition described here:\r\n        \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\n        if ((_amount!=0) && (allowed[msg.sender][_spender] !=0)) throw;\r\n\r\n        \/\/ Alerts the token controller of the approve function call\r\n        if (isContract(controller)) {\r\n            if (!TokenController(controller).onApprove(msg.sender, _spender, _amount))\r\n                throw;\r\n        }\r\n\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    \/\/\/ @dev This function makes it easy to read the `allowed[]` map\r\n    \/\/\/ @param _owner The address of the account that owns the token\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @return Amount of remaining tokens of _owner that _spender is allowed\r\n    \/\/\/  to spend\r\n    function allowance(address _owner, address _spender\r\n    ) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    \/\/\/ @notice `msg.sender` approves `_spender` to send `_amount` tokens on\r\n    \/\/\/  its behalf, and then a function is triggered in the contract that is\r\n    \/\/\/  being approved, `_spender`. This allows users to use their tokens to\r\n    \/\/\/  interact with contracts in one function call instead of two\r\n    \/\/\/ @param _spender The address of the contract able to transfer the tokens\r\n    \/\/\/ @param _amount The amount of tokens to be approved for transfer\r\n    \/\/\/ @return True if the function call was successful\r\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\r\n    ) returns (bool success) {\r\n        if (!approve(_spender, _amount)) throw;\r\n\r\n        ApproveAndCallFallBack(_spender).receiveApproval(\r\n            msg.sender,\r\n            _amount,\r\n            this,\r\n            _extraData\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    \/\/\/ @dev This function makes it easy to get the total number of tokens\r\n    \/\/\/ @return The total number of tokens\r\n    function totalSupply() constant returns (uint) {\r\n        return totalSupplyAt(block.number);\r\n    }\r\n\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Query balance and totalSupply in History\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @dev Queries the balance of `_owner` at a specific `_blockNumber`\r\n    \/\/\/ @param _owner The address from which the balance will be retrieved\r\n    \/\/\/ @param _blockNumber The block number when the balance is queried\r\n    \/\/\/ @return The balance at `_blockNumber`\r\n    function balanceOfAt(address _owner, uint _blockNumber) constant\r\n        returns (uint) {\r\n\r\n        \/\/ These next few lines are used when the balance of the token is\r\n        \/\/  requested before a check point was ever created for this token, it\r\n        \/\/  requires that the `parentToken.balanceOfAt` be queried at the\r\n        \/\/  genesis block for that token as this contains initial balance of\r\n        \/\/  this token\r\n        if ((balances[_owner].length == 0)\r\n            || (balances[_owner][0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                \/\/ Has no parent\r\n                return 0;\r\n            }\r\n\r\n        \/\/ This will return the expected balance during normal situations\r\n        } else {\r\n            return getValueAt(balances[_owner], _blockNumber);\r\n        }\r\n    }\r\n\r\n    \/\/\/ @notice Total amount of tokens at a specific `_blockNumber`.\r\n    \/\/\/ @param _blockNumber The block number when the totalSupply is queried\r\n    \/\/\/ @return The total amount of tokens at `_blockNumber`\r\n    function totalSupplyAt(uint _blockNumber) constant returns(uint) {\r\n\r\n        \/\/ These next few lines are used when the totalSupply of the token is\r\n        \/\/  requested before a check point was ever created for this token, it\r\n        \/\/  requires that the `parentToken.totalSupplyAt` be queried at the\r\n        \/\/  genesis block for this token as that contains totalSupply of this\r\n        \/\/  token at this block number.\r\n        if ((totalSupplyHistory.length == 0)\r\n            || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                return 0;\r\n            }\r\n\r\n        \/\/ This will return the expected totalSupply during normal situations\r\n        } else {\r\n            return getValueAt(totalSupplyHistory, _blockNumber);\r\n        }\r\n    }\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Clone Token Method\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice Creates a new clone token with the initial distribution being\r\n    \/\/\/  this token at `_snapshotBlock`\r\n    \/\/\/ @param _cloneTokenName Name of the clone token\r\n    \/\/\/ @param _cloneDecimalUnits Number of decimals of the smallest unit\r\n    \/\/\/ @param _cloneTokenSymbol Symbol of the clone token\r\n    \/\/\/ @param _snapshotBlock Block when the distribution of the parent token is\r\n    \/\/\/  copied to set the initial distribution of the new clone token;\r\n    \/\/\/  if the block is zero than the actual block, the current block is used\r\n    \/\/\/ @param _transfersEnabled True if transfers are allowed in the clone\r\n    \/\/\/ @return The address of the new MiniMeToken Contract\r\n    function createCloneToken(\r\n        string _cloneTokenName,\r\n        uint8 _cloneDecimalUnits,\r\n        string _cloneTokenSymbol,\r\n        uint _snapshotBlock,\r\n        bool _transfersEnabled\r\n        ) returns(address) {\r\n        if (_snapshotBlock == 0) _snapshotBlock = block.number;\r\n        MiniMeToken cloneToken = tokenFactory.createCloneToken(\r\n            this,\r\n            _snapshotBlock,\r\n            _cloneTokenName,\r\n            _cloneDecimalUnits,\r\n            _cloneTokenSymbol,\r\n            _transfersEnabled\r\n            );\r\n\r\n        cloneToken.changeController(msg.sender);\r\n\r\n        \/\/ An event to make the token easy to find on the blockchain\r\n        NewCloneToken(address(cloneToken), _snapshotBlock);\r\n        return address(cloneToken);\r\n    }\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Generate and destroy tokens\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice Generates `_amount` tokens that are assigned to `_owner`\r\n    \/\/\/ @param _owner The address that will be assigned the new tokens\r\n    \/\/\/ @param _amount The quantity of tokens generated\r\n    \/\/\/ @return True if the tokens are generated correctly\r\n    function generateTokens(address _owner, uint _amount\r\n    ) onlyController returns (bool) {\r\n        uint curTotalSupply = getValueAt(totalSupplyHistory, block.number);\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply.add(_amount));\r\n        var previousBalanceTo = balanceOf(_owner);\r\n        updateValueAtNow(balances[_owner], previousBalanceTo.add(_amount));\r\n        Transfer(0, _owner, _amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    \/\/\/ @notice Burns `_amount` tokens from `_owner`\r\n    \/\/\/ @param _owner The address that will lose the tokens\r\n    \/\/\/ @param _amount The quantity of tokens to burn\r\n    \/\/\/ @return True if the tokens are burned correctly\r\n    function destroyTokens(address _owner, uint _amount\r\n    ) onlyController returns (bool) {\r\n        uint curTotalSupply = getValueAt(totalSupplyHistory, block.number);\r\n        if (curTotalSupply < _amount) throw;\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply.sub(_amount));\r\n        var previousBalanceFrom = balanceOf(_owner);\r\n        if (previousBalanceFrom < _amount) throw;\r\n        updateValueAtNow(balances[_owner], previousBalanceFrom.sub(_amount));\r\n        Transfer(_owner, 0, _amount);\r\n        return true;\r\n    }\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Enable tokens transfers\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n\r\n    \/\/\/ @notice Enables token holders to transfer their tokens freely if true\r\n    \/\/\/ @param _transfersEnabled True if transfers are allowed in the clone\r\n    function enableTransfers(bool _transfersEnabled) onlyController {\r\n        transfersEnabled = _transfersEnabled;\r\n    }\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Internal helper functions to query and set a value in a snapshot array\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @dev `getValueAt` retrieves the number of tokens at a given block number\r\n    \/\/\/ @param checkpoints The history of values being queried\r\n    \/\/\/ @param _block The block number to retrieve the value at\r\n    \/\/\/ @return The number of tokens being queried\r\n    function getValueAt(Checkpoint[] storage checkpoints, uint _block\r\n    ) constant internal returns (uint) {\r\n        if (checkpoints.length == 0) return 0;\r\n\r\n        \/\/ Shortcut for the actual value\r\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\r\n            return checkpoints[checkpoints.length-1].value;\r\n        if (_block < checkpoints[0].fromBlock) return 0;\r\n\r\n        \/\/ Binary search of the value in the array\r\n        uint min = 0;\r\n        uint max = checkpoints.length-1;\r\n        while (max > min) {\r\n            uint mid = (max + min + 1)\/ 2;\r\n            if (checkpoints[mid].fromBlock<=_block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }\r\n        }\r\n        return checkpoints[min].value;\r\n    }\r\n\r\n    \/\/\/ @dev `updateValueAtNow` used to update the `balances` map and the\r\n    \/\/\/  `totalSupplyHistory`\r\n    \/\/\/ @param checkpoints The history of data being updated\r\n    \/\/\/ @param _value The new number of tokens\r\n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\r\n    ) internal  {\r\n        if ((checkpoints.length == 0)\r\n        || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\r\n               Checkpoint newCheckPoint = checkpoints[ checkpoints.length++ ];\r\n               newCheckPoint.fromBlock =  uint128(block.number);\r\n               newCheckPoint.value = uint128(_value);\r\n           } else {\r\n               Checkpoint oldCheckPoint = checkpoints[checkpoints.length-1];\r\n               oldCheckPoint.value = uint128(_value);\r\n           }\r\n    }\r\n\r\n    \/\/\/ @dev Internal function to determine if an address is a contract\r\n    \/\/\/ @param _addr The address being queried\r\n    \/\/\/ @return True if `_addr` is a contract\r\n    function isContract(address _addr) constant internal returns(bool) {\r\n        uint size;\r\n        if (_addr == 0) return false;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size>0;\r\n    }\r\n\r\n    \/\/\/ @dev Helper function to return a min betwen the two uints\r\n    function min(uint a, uint b) internal returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    \/\/\/ @notice The fallback function: If the contract's controller has not been\r\n    \/\/\/  set to 0, then the `proxyPayment` method is called which relays the\r\n    \/\/\/  ether and creates tokens as described in the token controller contract\r\n    function ()  payable {\r\n        if (isContract(controller)) {\r\n            if (! TokenController(controller).proxyPayment.value(msg.value)(msg.sender))\r\n                throw;\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    \/\/\/\/\/\/\/\/\/\/\r\n    \/\/ Safety Methods\r\n    \/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice This method can be used by the controller to extract mistakenly\r\n    \/\/\/  sent tokens to this contract.\r\n    \/\/\/ @param _token The address of the token contract that you want to recover\r\n    \/\/\/  set to 0 in case you want to extract ether.\r\n    \/\/\/ @param _claimer Address that tokens will be send to\r\n    function claimTokens(address _token, address _claimer) onlyController {\r\n        if (_token == 0x0) {\r\n            _claimer.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        ERC20Basic token = ERC20Basic(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(_claimer, balance);\r\n        ClaimedTokens(_token, _claimer, balance);\r\n    }\r\n\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Events\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n    event ClaimedTokens(address indexed _token, address indexed _claimer, uint _amount);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _amount\r\n        );\r\n\r\n}\r\n\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ MiniMeTokenFactory\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n\/\/\/ @dev This contract is used to generate clone contracts from a contract.\r\n\/\/\/  In solidity this is the way to create a contract from a contract of the\r\n\/\/\/  same class\r\ncontract MiniMeTokenFactory {\r\n\r\n    \/\/\/ @notice Update the DApp by creating a new token with new functionalities\r\n    \/\/\/  the msg.sender becomes the controller of this clone token\r\n    \/\/\/ @param _parentToken Address of the token being cloned\r\n    \/\/\/ @param _snapshotBlock Block of the parent token that will\r\n    \/\/\/  determine the initial distribution of the clone token\r\n    \/\/\/ @param _tokenName Name of the new token\r\n    \/\/\/ @param _decimalUnits Number of decimals of the new token\r\n    \/\/\/ @param _tokenSymbol Token Symbol for the new token\r\n    \/\/\/ @param _transfersEnabled If true, tokens will be able to be transferred\r\n    \/\/\/ @return The address of the new token contract\r\n    function createCloneToken(\r\n        address _parentToken,\r\n        uint _snapshotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    ) returns (MiniMeToken) {\r\n        MiniMeToken newToken = new MiniMeToken(\r\n            this,\r\n            _parentToken,\r\n            _snapshotBlock,\r\n            _tokenName,\r\n            _decimalUnits,\r\n            _tokenSymbol,\r\n            _transfersEnabled\r\n            );\r\n\r\n        newToken.changeController(msg.sender);\r\n        return newToken;\r\n    }\r\n}\r\n\r\ncontract VestedToken is LimitedTransferToken, GrantsControlled {\r\n  using SafeMath for uint;\r\n\r\n  uint256 MAX_GRANTS_PER_ADDRESS = 20;\r\n\r\n  struct TokenGrant {\r\n    address granter;     \/\/ 20 bytes\r\n    uint256 value;       \/\/ 32 bytes\r\n    uint64 cliff;\r\n    uint64 vesting;\r\n    uint64 start;        \/\/ 3 * 8 = 24 bytes\r\n    bool revokable;\r\n    bool burnsOnRevoke;  \/\/ 2 * 1 = 2 bits? or 2 bytes?\r\n  } \/\/ total 78 bytes = 3 sstore per operation (32 per sstore)\r\n\r\n  mapping (address => TokenGrant[]) public grants;\r\n\r\n  event NewTokenGrant(address indexed from, address indexed to, uint256 value, uint256 grantId);\r\n\r\n  \/**\r\n   * @dev Grant tokens to a specified address\r\n   * @param _to address The address which the tokens will be granted to.\r\n   * @param _value uint256 The amount of tokens to be granted.\r\n   * @param _start uint64 Time of the beginning of the grant.\r\n   * @param _cliff uint64 Time of the cliff period.\r\n   * @param _vesting uint64 The vesting period.\r\n   *\/\r\n  function grantVestedTokens(\r\n    address _to,\r\n    uint256 _value,\r\n    uint64 _start,\r\n    uint64 _cliff,\r\n    uint64 _vesting,\r\n    bool _revokable,\r\n    bool _burnsOnRevoke\r\n  ) onlyGrantsController public {\r\n\r\n    \/\/ Check for date inconsistencies that may cause unexpected behavior\r\n    if (_cliff < _start || _vesting < _cliff) {\r\n      throw;\r\n    }\r\n\r\n    if (tokenGrantsCount(_to) > MAX_GRANTS_PER_ADDRESS) throw;   \/\/ To prevent a user being spammed and have his balance locked (out of gas attack when calculating vesting).\r\n\r\n    uint count = grants[_to].push(\r\n                TokenGrant(\r\n                  _revokable ? msg.sender : 0, \/\/ avoid storing an extra 20 bytes when it is non-revokable\r\n                  _value,\r\n                  _cliff,\r\n                  _vesting,\r\n                  _start,\r\n                  _revokable,\r\n                  _burnsOnRevoke\r\n                )\r\n              );\r\n\r\n    transfer(_to, _value);\r\n\r\n    NewTokenGrant(msg.sender, _to, _value, count - 1);\r\n  }\r\n\r\n  \/**\r\n   * @dev Revoke the grant of tokens of a specifed address.\r\n   * @param _holder The address which will have its tokens revoked.\r\n   * @param _grantId The id of the token grant.\r\n   *\/\r\n  function revokeTokenGrant(address _holder, uint _grantId) public {\r\n    TokenGrant grant = grants[_holder][_grantId];\r\n\r\n    if (!grant.revokable) { \/\/ Check if grant was revokable\r\n      throw;\r\n    }\r\n\r\n    if (grant.granter != msg.sender) { \/\/ Only granter can revoke it\r\n      throw;\r\n    }\r\n\r\n    address receiver = grant.burnsOnRevoke ? 0xdead : msg.sender;\r\n\r\n    uint256 nonVested = nonVestedTokens(grant, uint64(now));\r\n\r\n    \/\/ remove grant from array\r\n    delete grants[_holder][_grantId];\r\n    grants[_holder][_grantId] = grants[_holder][grants[_holder].length.sub(1)];\r\n    grants[_holder].length -= 1;\r\n\r\n    \/\/ This will call MiniMe's doTransfer method, so token is transferred according to\r\n    \/\/ MiniMe Token logic\r\n    doTransfer(_holder, receiver, nonVested);\r\n\r\n    Transfer(_holder, receiver, nonVested);\r\n  }\r\n\r\n  \/**\r\n   * @dev Revoke all grants of tokens of a specifed address.\r\n   * @param _holder The address which will have its tokens revoked.\r\n   *\/\r\n    function revokeAllTokenGrants(address _holder) {\r\n        var grandsCount = tokenGrantsCount(_holder);\r\n        for (uint i = 0; i < grandsCount; i++) {\r\n          revokeTokenGrant(_holder, 0);\r\n        }\r\n    }\r\n\r\n  \/**\r\n   * @dev Calculate the total amount of transferable tokens of a holder at a given time\r\n   * @param holder address The address of the holder\r\n   * @param time uint64 The specific time.\r\n   * @return An uint representing a holder's total amount of transferable tokens.\r\n   *\/\r\n  function transferableTokens(address holder, uint64 time) constant public returns (uint256) {\r\n    uint256 grantIndex = tokenGrantsCount(holder);\r\n\r\n    if (grantIndex == 0) return balanceOf(holder); \/\/ shortcut for holder without grants\r\n\r\n    \/\/ Iterate through all the grants the holder has, and add all non-vested tokens\r\n    uint256 nonVested = 0;\r\n    for (uint256 i = 0; i < grantIndex; i++) {\r\n      nonVested = SafeMath.add(nonVested, nonVestedTokens(grants[holder][i], time));\r\n    }\r\n\r\n    \/\/ Balance - totalNonVested is the amount of tokens a holder can transfer at any given time\r\n    uint256 vestedTransferable = SafeMath.sub(balanceOf(holder), nonVested);\r\n\r\n    \/\/ Return the minimum of how many vested can transfer and other value\r\n    \/\/ in case there are other limiting transferability factors (default is balanceOf)\r\n    return SafeMath.min256(vestedTransferable, super.transferableTokens(holder, time));\r\n  }\r\n\r\n  \/**\r\n   * @dev Check the amount of grants that an address has.\r\n   * @param _holder The holder of the grants.\r\n   * @return A uint representing the total amount of grants.\r\n   *\/\r\n  function tokenGrantsCount(address _holder) constant returns (uint index) {\r\n    return grants[_holder].length;\r\n  }\r\n\r\n  \/**\r\n   * @dev Calculate amount of vested tokens at a specifc time.\r\n   * @param tokens uint256 The amount of tokens grantted.\r\n   * @param time uint64 The time to be checked\r\n   * @param start uint64 A time representing the begining of the grant\r\n   * @param cliff uint64 The cliff period.\r\n   * @param vesting uint64 The vesting period.\r\n   * @return An uint representing the amount of vested tokensof a specif grant.\r\n   *  transferableTokens\r\n   *   |                         _\/--------   vestedTokens rect\r\n   *   |                       _\/\r\n   *   |                     _\/\r\n   *   |                   _\/\r\n   *   |                 _\/\r\n   *   |                \/\r\n   *   |              .|\r\n   *   |            .  |\r\n   *   |          .    |\r\n   *   |        .      |\r\n   *   |      .        |\r\n   *   |    .          |\r\n   *   +===+===========+---------+----------> time\r\n   *      Start       Clift    Vesting\r\n   *\/\r\n  function calculateVestedTokens(\r\n    uint256 tokens,\r\n    uint256 time,\r\n    uint256 start,\r\n    uint256 cliff,\r\n    uint256 vesting) constant returns (uint256)\r\n    {\r\n      \/\/ Shortcuts for before cliff and after vesting cases.\r\n      if (time < cliff) return 0;\r\n      if (time >= vesting) return tokens;\r\n\r\n      \/\/ Interpolate all vested tokens.\r\n      \/\/ As before cliff the shortcut returns 0, we can use just calculate a value\r\n      \/\/ in the vesting rect (as shown in above's figure)\r\n\r\n      \/\/ vestedTokens = tokens * (time - start) \/ (vesting - start)\r\n      uint256 vestedTokens = SafeMath.div(\r\n                                    SafeMath.mul(\r\n                                      tokens,\r\n                                      SafeMath.sub(time, start)\r\n                                      ),\r\n                                    SafeMath.sub(vesting, start)\r\n                                    );\r\n\r\n      return vestedTokens;\r\n  }\r\n\r\n  \/**\r\n   * @dev Get all information about a specifc grant.\r\n   * @param _holder The address which will have its tokens revoked.\r\n   * @param _grantId The id of the token grant.\r\n   * @return Returns all the values that represent a TokenGrant(address, value, start, cliff,\r\n   * revokability, burnsOnRevoke, and vesting) plus the vested value at the current time.\r\n   *\/\r\n  function tokenGrant(address _holder, uint _grantId) constant returns (address granter, uint256 value, uint256 vested, uint64 start, uint64 cliff, uint64 vesting, bool revokable, bool burnsOnRevoke) {\r\n    TokenGrant grant = grants[_holder][_grantId];\r\n\r\n    granter = grant.granter;\r\n    value = grant.value;\r\n    start = grant.start;\r\n    cliff = grant.cliff;\r\n    vesting = grant.vesting;\r\n    revokable = grant.revokable;\r\n    burnsOnRevoke = grant.burnsOnRevoke;\r\n\r\n    vested = vestedTokens(grant, uint64(now));\r\n  }\r\n\r\n  \/**\r\n   * @dev Get the amount of vested tokens at a specific time.\r\n   * @param grant TokenGrant The grant to be checked.\r\n   * @param time The time to be checked\r\n   * @return An uint representing the amount of vested tokens of a specific grant at a specific time.\r\n   *\/\r\n  function vestedTokens(TokenGrant grant, uint64 time) private constant returns (uint256) {\r\n    return calculateVestedTokens(\r\n      grant.value,\r\n      uint256(time),\r\n      uint256(grant.start),\r\n      uint256(grant.cliff),\r\n      uint256(grant.vesting)\r\n    );\r\n  }\r\n\r\n  \/**\r\n   * @dev Calculate the amount of non vested tokens at a specific time.\r\n   * @param grant TokenGrant The grant to be checked.\r\n   * @param time uint64 The time to be checked\r\n   * @return An uint representing the amount of non vested tokens of a specifc grant on the\r\n   * passed time frame.\r\n   *\/\r\n  function nonVestedTokens(TokenGrant grant, uint64 time) private constant returns (uint256) {\r\n    return grant.value.sub(vestedTokens(grant, time));\r\n  }\r\n\r\n  \/**\r\n   * @dev Calculate the date when the holder can trasfer all its tokens\r\n   * @param holder address The address of the holder\r\n   * @return An uint representing the date of the last transferable tokens.\r\n   *\/\r\n  function lastTokenIsTransferableDate(address holder) constant public returns (uint64 date) {\r\n    date = uint64(now);\r\n    uint256 grantIndex = grants[holder].length;\r\n    for (uint256 i = 0; i < grantIndex; i++) {\r\n      date = SafeMath.max64(grants[holder][i].vesting, date);\r\n    }\r\n  }\r\n}\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 _amount, address _token, bytes _data);\r\n}\r\n\r\n\r\ncontract TokenController {\r\n    \/\/\/ @notice Called when `_owner` sends ether to the MiniMe Token contract\r\n    \/\/\/ @param _owner The address that sent the ether to create tokens\r\n    \/\/\/ @return True if the ether is accepted, false if it throws\r\n    function proxyPayment(address _owner) payable returns(bool);\r\n\r\n    \/\/\/ @notice Notifies the controller about a token transfer allowing the\r\n    \/\/\/  controller to react if desired\r\n    \/\/\/ @param _from The origin of the transfer\r\n    \/\/\/ @param _to The destination of the transfer\r\n    \/\/\/ @param _amount The amount of the transfer\r\n    \/\/\/ @return False if the controller does not authorize the transfer\r\n    function onTransfer(address _from, address _to, uint _amount) returns(bool);\r\n\r\n    \/\/\/ @notice Notifies the controller about an approval allowing the\r\n    \/\/\/  controller to react if desired\r\n    \/\/\/ @param _owner The address that calls `approve()`\r\n    \/\/\/ @param _spender The spender in the `approve()` call\r\n    \/\/\/ @param _amount The amount in the `approve()` call\r\n    \/\/\/ @return False if the controller does not authorize the approval\r\n    function onApprove(address _owner, address _spender, uint _amount)\r\n        returns(bool);\r\n}\r\n\r\ncontract District0xNetworkToken is MiniMeToken, VestedToken {\r\n    function District0xNetworkToken(address _controller, address _tokenFactory)\r\n        MiniMeToken(\r\n            _tokenFactory,\r\n            0x0,                        \/\/ no parent token\r\n            0,                          \/\/ no snapshot block number from parent\r\n            \"district0x Network Token\", \/\/ Token name\r\n            18,                         \/\/ Decimals\r\n            \"DNT\",                      \/\/ Symbol\r\n            true                        \/\/ Enable transfers\r\n            )\r\n    {\r\n        changeController(_controller);\r\n        changeGrantsController(_controller);\r\n    }\r\n}\r\n\r\ncontract HasNoTokens is Ownable {\r\n\r\n  District0xNetworkToken public district0xNetworkToken;\r\n\r\n \/**\r\n  * @dev Reject all ERC23 compatible tokens\r\n  * @param from_ address The address that is transferring the tokens\r\n  * @param value_ uint256 the amount of the specified token\r\n  * @param data_ Bytes The data passed from the caller.\r\n  *\/\r\n  function tokenFallback(address from_, uint256 value_, bytes data_) external {\r\n    throw;\r\n  }\r\n\r\n  function isTokenSaleToken(address tokenAddr) returns(bool);\r\n\r\n  \/**\r\n   * @dev Reclaim all ERC20Basic compatible tokens\r\n   * @param tokenAddr address The address of the token contract\r\n   *\/\r\n  function reclaimToken(address tokenAddr) external onlyOwner {\r\n    require(!isTokenSaleToken(tokenAddr));\r\n    ERC20Basic tokenInst = ERC20Basic(tokenAddr);\r\n    uint256 balance = tokenInst.balanceOf(this);\r\n    tokenInst.transfer(msg.sender, balance);\r\n  }\r\n}\r\n\r\n\r\ncontract District0xContribution is Pausable, HasNoTokens, TokenController {\r\n    using SafeMath for uint;\r\n\r\n    District0xNetworkToken public district0xNetworkToken;\r\n    address public multisigWallet;                                      \/\/ Wallet that receives all sale funds\r\n    address public founder1;                                            \/\/ Wallet of founder 1\r\n    address public founder2;                                            \/\/ Wallet of founder 2\r\n    address public earlySponsor;                                        \/\/ Wallet of early sponsor\r\n    address[] public advisers;                                          \/\/ 4 Wallets of advisors\r\n\r\n    uint public constant FOUNDER1_STAKE = 119000000 ether;              \/\/ 119M DNT\r\n    uint public constant FOUNDER2_STAKE = 79000000 ether;               \/\/ 79M  DNT\r\n    uint public constant EARLY_CONTRIBUTOR_STAKE = 5000000 ether;       \/\/ 5M   DNT\r\n    uint public constant ADVISER_STAKE = 5000000 ether;                 \/\/ 5M   DNT\r\n    uint public constant ADVISER_STAKE2 = 1000000 ether;                \/\/ 1M   DNT\r\n    uint public constant COMMUNITY_ADVISERS_STAKE = 5000000 ether;      \/\/ 5M   DNT\r\n    uint public constant CONTRIB_PERIOD1_STAKE = 600000000 ether;       \/\/ 600M DNT\r\n    uint public constant CONTRIB_PERIOD2_STAKE = 140000000 ether;       \/\/ 140M DNT\r\n    uint public constant CONTRIB_PERIOD3_STAKE = 40000000 ether;        \/\/ 40M  DNT\r\n\r\n    uint public minContribAmount = 0.01 ether;                          \/\/ 0.01 ether\r\n    uint public maxGasPrice = 50000000000;                              \/\/ 50 GWei\r\n\r\n    uint public constant TEAM_VESTING_CLIFF = 24 weeks;                 \/\/ 6 months vesting cliff for founders and advisors, except community advisors\r\n    uint public constant TEAM_VESTING_PERIOD = 96 weeks;                \/\/ 2 years vesting period for founders and advisors, except community advisors\r\n\r\n    uint public constant EARLY_CONTRIBUTOR_VESTING_CLIFF = 12 weeks;    \/\/ 3 months vesting cliff for early sponsor\r\n    uint public constant EARLY_CONTRIBUTOR_VESTING_PERIOD = 24 weeks;   \/\/ 6 months vesting cliff for early sponsor\r\n\r\n    bool public tokenTransfersEnabled = false;                          \/\/ DNT token transfers will be enabled manually\r\n                                                                        \/\/ after first contribution period\r\n                                                                        \/\/ Can't be disabled back\r\n    struct Contributor {\r\n        uint amount;                        \/\/ Amount of ETH contributed by an address in given contribution period\r\n        bool isCompensated;                 \/\/ Whether this contributor received DNT token for ETH contribution\r\n        uint amountCompensated;             \/\/ Amount of DNT received. Not really needed to store,\r\n                                            \/\/ but stored for accounting and security purposes\r\n    }\r\n\r\n    uint public softCapAmount;                                 \/\/ Soft cap of contribution period in wei\r\n    uint public afterSoftCapDuration;                          \/\/ Number of seconds to the end of sale from the moment of reaching soft cap (unless reaching hardcap)\r\n    uint public hardCapAmount;                                 \/\/ When reached this amount of wei, the contribution will end instantly\r\n    uint public startTime;                                     \/\/ Start time of contribution period in UNIX time\r\n    uint public endTime;                                       \/\/ End time of contribution period in UNIX time\r\n    bool public isEnabled;                                     \/\/ If contribution period was enabled by multisignature\r\n    bool public softCapReached;                                \/\/ If soft cap was reached\r\n    bool public hardCapReached;                                \/\/ If hard cap was reached\r\n    uint public totalContributed;                              \/\/ Total amount of ETH contributed in given period\r\n    address[] public contributorsKeys;                         \/\/ Addresses of all contributors in given contribution period\r\n    mapping (address => Contributor) public contributors;\r\n\r\n    event onContribution(uint totalContributed, address indexed contributor, uint amount,\r\n        uint contributorsCount);\r\n    event onSoftCapReached(uint endTime);\r\n    event onHardCapReached(uint endTime);\r\n    event onCompensated(address indexed contributor, uint amount);\r\n\r\n    modifier onlyMultisig() {\r\n        require(multisigWallet == msg.sender);\r\n        _;\r\n    }\r\n\r\n    function District0xContribution(\r\n        address _multisigWallet,\r\n        address _founder1,\r\n        address _founder2,\r\n        address _earlySponsor,\r\n        address[] _advisers\r\n    ) {\r\n        require(_advisers.length == 5);\r\n        multisigWallet = _multisigWallet;\r\n        founder1 = _founder1;\r\n        founder2 = _founder2;\r\n        earlySponsor = _earlySponsor;\r\n        advisers = _advisers;\r\n    }\r\n\r\n    \/\/ @notice Returns true if contribution period is currently running\r\n    function isContribPeriodRunning() constant returns (bool) {\r\n        return !hardCapReached &&\r\n               isEnabled &&\r\n               startTime <= now &&\r\n               endTime > now;\r\n    }\r\n\r\n    function contribute()\r\n        payable\r\n        stopInEmergency\r\n    {\r\n        contributeWithAddress(msg.sender);\r\n    }\r\n\r\n    \/\/ @notice Function to participate in contribution period\r\n    \/\/  Amounts from the same address should be added up\r\n    \/\/  If soft or hard cap is reached, end time should be modified\r\n    \/\/  Funds should be transferred into multisig wallet\r\n    \/\/ @param contributor Address that will receive DNT token\r\n    function contributeWithAddress(address contributor)\r\n        payable\r\n        stopInEmergency\r\n    {\r\n        require(tx.gasprice <= maxGasPrice);\r\n        require(msg.value >= minContribAmount);\r\n        require(isContribPeriodRunning());\r\n\r\n        uint contribValue = msg.value;\r\n        uint excessContribValue = 0;\r\n\r\n        uint oldTotalContributed = totalContributed;\r\n\r\n        totalContributed = oldTotalContributed.add(contribValue);\r\n\r\n        uint newTotalContributed = totalContributed;\r\n\r\n        \/\/ Soft cap was reached\r\n        if (newTotalContributed >= softCapAmount &&\r\n            oldTotalContributed < softCapAmount)\r\n        {\r\n            softCapReached = true;\r\n            endTime = afterSoftCapDuration.add(now);\r\n            onSoftCapReached(endTime);\r\n        }\r\n        \/\/ Hard cap was reached\r\n        if (newTotalContributed >= hardCapAmount &&\r\n            oldTotalContributed < hardCapAmount)\r\n        {\r\n            hardCapReached = true;\r\n            endTime = now;\r\n            onHardCapReached(endTime);\r\n\r\n            \/\/ Everything above hard cap will be sent back to contributor\r\n            excessContribValue = newTotalContributed.sub(hardCapAmount);\r\n            contribValue = contribValue.sub(excessContribValue);\r\n\r\n            totalContributed = hardCapAmount;\r\n        }\r\n\r\n        if (contributors[contributor].amount == 0) {\r\n            contributorsKeys.push(contributor);\r\n        }\r\n\r\n        contributors[contributor].amount = contributors[contributor].amount.add(contribValue);\r\n\r\n        multisigWallet.transfer(contribValue);\r\n        if (excessContribValue > 0) {\r\n            msg.sender.transfer(excessContribValue);\r\n        }\r\n        onContribution(newTotalContributed, contributor, contribValue, contributorsKeys.length);\r\n    }\r\n\r\n    \/\/ @notice This method is called by owner after contribution period ends, to distribute DNT in proportional manner\r\n    \/\/  Each contributor should receive DNT just once even if this method is called multiple times\r\n    \/\/  In case of many contributors must be able to compensate contributors in paginational way, otherwise might\r\n    \/\/  run out of gas if wanted to compensate all on one method call. Therefore parameters offset and limit\r\n    \/\/ @param periodIndex Index of contribution period (0-2)\r\n    \/\/ @param offset Number of first contributors to skip.\r\n    \/\/ @param limit Max number of contributors compensated on this call\r\n    function compensateContributors(uint offset, uint limit)\r\n        onlyOwner\r\n    {\r\n        require(isEnabled);\r\n        require(endTime < now);\r\n\r\n        uint i = offset;\r\n        uint compensatedCount = 0;\r\n        uint contributorsCount = contributorsKeys.length;\r\n\r\n        uint ratio = CONTRIB_PERIOD1_STAKE\r\n            .mul(1000000000000000000)\r\n            .div(totalContributed);\r\n\r\n        while (i < contributorsCount && compensatedCount < limit) {\r\n            address contributorAddress = contributorsKeys[i];\r\n            if (!contributors[contributorAddress].isCompensated) {\r\n                uint amountContributed = contributors[contributorAddress].amount;\r\n                contributors[contributorAddress].isCompensated = true;\r\n\r\n                contributors[contributorAddress].amountCompensated =\r\n                    amountContributed.mul(ratio).div(1000000000000000000);\r\n\r\n                district0xNetworkToken.transfer(contributorAddress, contributors[contributorAddress].amountCompensated);\r\n                onCompensated(contributorAddress, contributors[contributorAddress].amountCompensated);\r\n\r\n                compensatedCount++;\r\n            }\r\n            i++;\r\n        }\r\n    }\r\n\r\n    \/\/ @notice Method for setting up contribution period\r\n    \/\/  Only owner should be able to execute\r\n    \/\/  Setting first contribution period sets up vesting for founders & advisors\r\n    \/\/  Contribution period should still not be enabled after calling this method\r\n    \/\/ @param softCapAmount Soft Cap in wei\r\n    \/\/ @param afterSoftCapDuration Number of seconds till the end of sale in the moment of reaching soft cap (unless reaching hard cap)\r\n    \/\/ @param hardCapAmount Hard Cap in wei\r\n    \/\/ @param startTime Contribution start time in UNIX time\r\n    \/\/ @param endTime Contribution end time in UNIX time\r\n    function setContribPeriod(\r\n        uint _softCapAmount,\r\n        uint _afterSoftCapDuration,\r\n        uint _hardCapAmount,\r\n        uint _startTime,\r\n        uint _endTime\r\n    )\r\n        onlyOwner\r\n    {\r\n        require(_softCapAmount > 0);\r\n        require(_hardCapAmount > _softCapAmount);\r\n        require(_afterSoftCapDuration > 0);\r\n        require(_startTime > now);\r\n        require(_endTime > _startTime);\r\n        require(!isEnabled);\r\n\r\n        softCapAmount = _softCapAmount;\r\n        afterSoftCapDuration = _afterSoftCapDuration;\r\n        hardCapAmount = _hardCapAmount;\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n\r\n        district0xNetworkToken.revokeAllTokenGrants(founder1);\r\n        district0xNetworkToken.revokeAllTokenGrants(founder2);\r\n        district0xNetworkToken.revokeAllTokenGrants(earlySponsor);\r\n\r\n        for (uint j = 0; j < advisers.length; j++) {\r\n            district0xNetworkToken.revokeAllTokenGrants(advisers[j]);\r\n        }\r\n\r\n        uint64 vestingDate = uint64(startTime.add(TEAM_VESTING_PERIOD));\r\n        uint64 cliffDate = uint64(startTime.add(TEAM_VESTING_CLIFF));\r\n        uint64 earlyContribVestingDate = uint64(startTime.add(EARLY_CONTRIBUTOR_VESTING_PERIOD));\r\n        uint64 earlyContribCliffDate = uint64(startTime.add(EARLY_CONTRIBUTOR_VESTING_CLIFF));\r\n        uint64 startDate = uint64(startTime);\r\n\r\n        district0xNetworkToken.grantVestedTokens(founder1, FOUNDER1_STAKE, startDate, cliffDate, vestingDate, true, false);\r\n        district0xNetworkToken.grantVestedTokens(founder2, FOUNDER2_STAKE, startDate, cliffDate, vestingDate, true, false);\r\n        district0xNetworkToken.grantVestedTokens(earlySponsor, EARLY_CONTRIBUTOR_STAKE, startDate, earlyContribCliffDate, earlyContribVestingDate, true, false);\r\n        district0xNetworkToken.grantVestedTokens(advisers[0], ADVISER_STAKE, startDate, cliffDate, vestingDate, true, false);\r\n        district0xNetworkToken.grantVestedTokens(advisers[1], ADVISER_STAKE, startDate, cliffDate, vestingDate, true, false);\r\n        district0xNetworkToken.grantVestedTokens(advisers[2], ADVISER_STAKE2, startDate, cliffDate, vestingDate, true, false);\r\n        district0xNetworkToken.grantVestedTokens(advisers[3], ADVISER_STAKE2, startDate, cliffDate, vestingDate, true, false);\r\n\r\n        \/\/ Community advisors stake has no vesting, but we set it up this way, so we can revoke it in case of\r\n        \/\/ re-setting up contribution period\r\n        district0xNetworkToken.grantVestedTokens(advisers[4], COMMUNITY_ADVISERS_STAKE, startDate, startDate, startDate, true, false);\r\n    }\r\n\r\n    \/\/ @notice Enables contribution period\r\n    \/\/  Must be executed by multisignature\r\n    function enableContribPeriod()\r\n        onlyMultisig\r\n    {\r\n        require(startTime > now);\r\n        isEnabled = true;\r\n    }\r\n\r\n    \/\/ @notice Sets new min. contribution amount\r\n    \/\/  Only owner can execute\r\n    \/\/  Cannot be executed while contribution period is running\r\n    \/\/ @param _minContribAmount new min. amount\r\n    function setMinContribAmount(uint _minContribAmount)\r\n        onlyOwner\r\n    {\r\n        require(_minContribAmount > 0);\r\n        require(startTime > now);\r\n        minContribAmount = _minContribAmount;\r\n    }\r\n\r\n    \/\/ @notice Sets new max gas price for contribution\r\n    \/\/  Only owner can execute\r\n    \/\/  Cannot be executed while contribution period is running\r\n    \/\/ @param _minContribAmount new min. amount\r\n    function setMaxGasPrice(uint _maxGasPrice)\r\n        onlyOwner\r\n    {\r\n        require(_maxGasPrice > 0);\r\n        require(startTime > now);\r\n        maxGasPrice = _maxGasPrice;\r\n    }\r\n\r\n    \/\/ @notice Sets District0xNetworkToken contract\r\n    \/\/  Generates all DNT tokens and assigns them to this contract\r\n    \/\/  If token contract has already generated tokens, do not generate again\r\n    \/\/ @param _district0xNetworkToken District0xNetworkToken address\r\n    function setDistrict0xNetworkToken(address _district0xNetworkToken)\r\n        onlyOwner\r\n    {\r\n        require(_district0xNetworkToken != 0x0);\r\n        require(!isEnabled);\r\n        district0xNetworkToken = District0xNetworkToken(_district0xNetworkToken);\r\n        if (district0xNetworkToken.totalSupply() == 0) {\r\n            district0xNetworkToken.generateTokens(this, FOUNDER1_STAKE\r\n                .add(FOUNDER2_STAKE)\r\n                .add(EARLY_CONTRIBUTOR_STAKE)\r\n                .add(ADVISER_STAKE.mul(2))\r\n                .add(ADVISER_STAKE2.mul(2))\r\n                .add(COMMUNITY_ADVISERS_STAKE)\r\n                .add(CONTRIB_PERIOD1_STAKE));\r\n\r\n            district0xNetworkToken.generateTokens(multisigWallet, CONTRIB_PERIOD2_STAKE\r\n                .add(CONTRIB_PERIOD3_STAKE));\r\n        }\r\n    }\r\n\r\n    \/\/ @notice Enables transfers of DNT\r\n    \/\/  Will be executed after first contribution period by owner\r\n    function enableDistrict0xNetworkTokenTransfers()\r\n        onlyOwner\r\n    {\r\n        require(endTime < now);\r\n        tokenTransfersEnabled = true;\r\n    }\r\n\r\n    \/\/ @notice Method to claim tokens accidentally sent to a DNT contract\r\n    \/\/  Only multisig wallet can execute\r\n    \/\/ @param _token Address of claimed ERC20 Token\r\n    function claimTokensFromTokenDistrict0xNetworkToken(address _token)\r\n        onlyMultisig\r\n    {\r\n        district0xNetworkToken.claimTokens(_token, multisigWallet);\r\n    }\r\n\r\n    \/\/ @notice Kill method should not really be needed, but just in case\r\n    function kill(address _to) onlyMultisig external {\r\n        suicide(_to);\r\n    }\r\n\r\n    function()\r\n        payable\r\n        stopInEmergency\r\n    {\r\n        contributeWithAddress(msg.sender);\r\n    }\r\n\r\n    \/\/ MiniMe Controller default settings for allowing token transfers.\r\n    function proxyPayment(address _owner) payable public returns (bool) {\r\n        throw;\r\n    }\r\n\r\n    \/\/ Before transfers are enabled for everyone, only this contract is allowed to distribute DNT\r\n    function onTransfer(address _from, address _to, uint _amount) public returns (bool) {\r\n        return tokenTransfersEnabled || _from == address(this) || _to == address(this);\r\n    }\r\n\r\n    function onApprove(address _owner, address _spender, uint _amount) public returns (bool) {\r\n        return tokenTransfersEnabled;\r\n    }\r\n\r\n    function isTokenSaleToken(address tokenAddr) returns(bool) {\r\n        return district0xNetworkToken == tokenAddr;\r\n    }\r\n\r\n    \/*\r\n     Following constant methods are used for tests and contribution web app\r\n     They don't impact logic of contribution contract, therefor DOES NOT NEED TO BE AUDITED\r\n     *\/\r\n\r\n    \/\/ Used by contribution front-end to obtain contribution period properties\r\n    function getContribPeriod()\r\n        constant\r\n        returns (bool[3] boolValues, uint[8] uintValues)\r\n    {\r\n        boolValues[0] = isEnabled;\r\n        boolValues[1] = softCapReached;\r\n        boolValues[2] = hardCapReached;\r\n\r\n        uintValues[0] = softCapAmount;\r\n        uintValues[1] = afterSoftCapDuration;\r\n        uintValues[2] = hardCapAmount;\r\n        uintValues[3] = startTime;\r\n        uintValues[4] = endTime;\r\n        uintValues[5] = totalContributed;\r\n        uintValues[6] = contributorsKeys.length;\r\n        uintValues[7] = CONTRIB_PERIOD1_STAKE;\r\n\r\n        return (boolValues, uintValues);\r\n    }\r\n\r\n    \/\/ Used by contribution front-end to obtain contribution contract properties\r\n    function getConfiguration()\r\n        constant\r\n        returns (bool, address, address, address, address, address[] _advisers, bool, uint)\r\n    {\r\n        _advisers = new address[](advisers.length);\r\n        for (uint i = 0; i < advisers.length; i++) {\r\n            _advisers[i] = advisers[i];\r\n        }\r\n        return (stopped, multisigWallet, founder1, founder2, earlySponsor, _advisers, tokenTransfersEnabled,\r\n            maxGasPrice);\r\n    }\r\n\r\n    \/\/ Used by contribution front-end to obtain contributor's properties\r\n    function getContributor(address contributorAddress)\r\n        constant\r\n        returns(uint, bool, uint)\r\n    {\r\n        Contributor contributor = contributors[contributorAddress];\r\n        return (contributor.amount, contributor.isCompensated, contributor.amountCompensated);\r\n    }\r\n\r\n    \/\/ Function to verify if all contributors were compensated\r\n    function getUncompensatedContributors(uint offset, uint limit)\r\n        constant\r\n        returns (uint[] contributorIndexes)\r\n    {\r\n        uint contributorsCount = contributorsKeys.length;\r\n\r\n        if (limit == 0) {\r\n            limit = contributorsCount;\r\n        }\r\n\r\n        uint i = offset;\r\n        uint resultsCount = 0;\r\n        uint[] memory _contributorIndexes = new uint[](limit);\r\n\r\n        while (i < contributorsCount && resultsCount < limit) {\r\n            if (!contributors[contributorsKeys[i]].isCompensated) {\r\n                _contributorIndexes[resultsCount] = i;\r\n                resultsCount++;\r\n            }\r\n            i++;\r\n        }\r\n\r\n        contributorIndexes = new uint[](resultsCount);\r\n        for (i = 0; i < resultsCount; i++) {\r\n            contributorIndexes[i] = _contributorIndexes[i];\r\n        }\r\n        return contributorIndexes;\r\n    }\r\n\r\n    function getNow()\r\n        constant\r\n        returns(uint)\r\n    {\r\n        return now;\r\n    }\r\n}",
      "officialLinks": {
        "Reddit": "",
        "Telegram": "",
        "Website": "https:\/\/district0x.io\/",
        "Email": "mailto:hello@district0x.io",
        "Twitter": "https:\/\/twitter.com\/district0x"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x0abdace70d3790235af448c88547603b945604ea#code"
    }, {
      "contractId": 15,
      "title": "RequestToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Request",
      "code": "pragma solidity 0.4.15;\r\n\r\n\/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n *\/\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  \/**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   *\/\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  \/**\r\n   * @dev Throws if called by any account other than the owner.\r\n   *\/\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  \/**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   *\/\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\n\/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n *\/\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\n    uint256 c = a \/ b;\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/179\r\n *\/\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\/**\r\n * @title ERC20 interface\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n *\/\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n *\/\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  \/**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  *\/\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    \/\/ SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  *\/\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n}\r\n\r\n\/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n * @dev Based on code by FirstBlood: https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\n *\/\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  \/**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   *\/\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n    \/\/ Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    \/\/ require (_value <= _allowance);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   *\/\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   *\/\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  \/**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   *\/\r\n  function increaseApproval (address _spender, uint _addedValue)\r\n    returns (bool success) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval (address _spender, uint _subtractedValue)\r\n    returns (bool success) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n}\r\n\r\n\/**\r\n * @title StandardCrowdsale \r\n * @dev StandardCrowdsale is a base contract for managing a token crowdsale.\r\n * Crowdsales have a start and end timestamps, where investors can make\r\n * token purchases and the crowdsale will assign them tokens based\r\n * on a token per ETH rate. Funds collected are forwarded to a wallet\r\n * as they arrive.\r\n * @dev from Crowdsale by Zepellin with small changes. Changes are commented with \"Request Modification\"\r\n *\/\r\ncontract StandardCrowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    \/\/ The token being sold\r\n    StandardToken public token; \/\/ Request Modification : change to not mintable\r\n\r\n    \/\/ start and end timestamps where investments are allowed (both inclusive)\r\n    uint256 public startTime;\r\n    uint256 public endTime;\r\n\r\n    \/\/ address where funds are collected\r\n    address public wallet;\r\n\r\n    \/\/ how many token units a buyer gets per wei\r\n    uint256 public rate;\r\n\r\n    \/\/ amount of raised money in wei\r\n    uint256 public weiRaised;\r\n\r\n    \/**\r\n     * event for token purchase logging\r\n     * @param purchaser who paid for the tokens\r\n     * @param value weis paid for purchase\r\n     * @param amount amount of tokens purchased\r\n     *\/\r\n    event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount);\r\n\r\n    function StandardCrowdsale(\r\n        uint256 _startTime, \r\n        uint256 _endTime, \r\n        uint256 _rate, \r\n        address _wallet) \r\n    {\r\n        require(_startTime >= now);\r\n        require(_endTime >= _startTime);\r\n        require(_rate > 0);\r\n        require(_wallet != 0x0);\r\n\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n        rate = _rate;\r\n        wallet = _wallet;\r\n\r\n        token = createTokenContract(); \/\/ Request Modification : change to StandardToken + position\r\n    }\r\n\r\n    \/\/ creates the token to be sold.\r\n    \/\/ Request Modification : change to StandardToken\r\n    \/\/ override this method to have crowdsale of a specific mintable token.\r\n    function createTokenContract() \r\n        internal \r\n        returns(StandardToken) \r\n    {\r\n        return new StandardToken();\r\n    }\r\n\r\n    \/\/ fallback function can be used to buy tokens\r\n    function () \r\n       payable \r\n    {\r\n        buyTokens();\r\n    }\r\n\r\n    \/\/ low level token purchase function\r\n    \/\/ Request Modification : change to not mint but transfer from this contract\r\n    function buyTokens() \r\n       public \r\n       payable \r\n    {\r\n        require(validPurchase());\r\n\r\n        uint256 weiAmount = msg.value;\r\n\r\n        \/\/ calculate token amount to be created\r\n        uint256 tokens = weiAmount.mul(rate);\r\n\r\n        \/\/ update state\r\n        weiRaised = weiRaised.add(weiAmount);\r\n\r\n        require(token.transfer(msg.sender, tokens)); \/\/ Request Modification : changed here - tranfer instead of mintable\r\n        TokenPurchase(msg.sender, weiAmount, tokens);\r\n\r\n        forwardFunds();\r\n    }\r\n\r\n    \/\/ send ether to the fund collection wallet\r\n    \/\/ override to create custom fund forwarding mechanisms\r\n    function forwardFunds() \r\n       internal \r\n    {\r\n        wallet.transfer(msg.value);\r\n    }\r\n\r\n    \/\/ @return true if the transaction can buy tokens\r\n    function validPurchase() \r\n        internal \r\n        returns(bool) \r\n    {\r\n        bool withinPeriod = now >= startTime && now <= endTime;\r\n        bool nonZeroPurchase = msg.value != 0;\r\n        return withinPeriod && nonZeroPurchase;\r\n    }\r\n\r\n    \/\/ @return true if crowdsale event has ended\r\n    function hasEnded() \r\n        public \r\n        constant \r\n        returns(bool) \r\n    {\r\n        return now > endTime;\r\n    }\r\n\r\n    modifier onlyBeforeSale() {\r\n        require(now < startTime);\r\n        _;\r\n    }\r\n\r\n    \/\/ Request Modification : Add check 24hours before token sale\r\n    modifier only24HBeforeSale() {\r\n        require(now < startTime.sub(1 days));\r\n        _;\r\n    }\r\n}\r\n\r\n\/**\r\n * @title CappedCrowdsale\r\n * @dev Extension of Crowdsale with a max amount of funds raised\r\n *\/\r\ncontract CappedCrowdsale is StandardCrowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 public cap;\r\n\r\n  function CappedCrowdsale(uint256 _cap) {\r\n    require(_cap > 0);\r\n    cap = _cap;\r\n  }\r\n\r\n  \/\/ overriding Crowdsale#validPurchase to add extra cap logic\r\n  \/\/ @return true if investors can buy at the moment\r\n  \/\/ Request Modification : delete constant because needed in son contract\r\n  function validPurchase() internal returns (bool) {\r\n    bool withinCap = weiRaised.add(msg.value) <= cap;\r\n    return super.validPurchase() && withinCap;\r\n  }\r\n\r\n  \/\/ overriding Crowdsale#hasEnded to add cap logic\r\n  \/\/ @return true if crowdsale event has ended\r\n  function hasEnded() public constant returns (bool) {\r\n    bool capReached = weiRaised >= cap;\r\n    return super.hasEnded() || capReached;\r\n  }\r\n}\r\n\r\n\/**\r\n * @title ProgressiveIndividualCappedCrowdsale\r\n * @dev Extension of Crowdsale with a progressive individual cap\r\n * @dev This contract is not made for crowdsale superior to 256 * TIME_PERIOD_IN_SEC\r\n * @author Request.network\r\n *\/\r\ncontract ProgressiveIndividualCappedCrowdsale is StandardCrowdsale, Ownable {\r\n\r\n    uint public constant TIME_PERIOD_IN_SEC = 1 days;\r\n    uint public constant GAS_LIMIT_IN_WEI = 50000000000 wei; \/\/ limit gas price -50 Gwei wales stopper\r\n    uint256 public baseEthCapPerAddress = 0 ether;\r\n\r\n    mapping(address=>uint) public participated;\r\n\r\n    \/**\r\n     * @dev overriding CappedCrowdsale#validPurchase to add an individual cap\r\n     * @return true if investors can buy at the moment\r\n     *\/\r\n    function validPurchase() \r\n        internal \r\n        returns(bool)\r\n    {\r\n        require(tx.gasprice <= GAS_LIMIT_IN_WEI);\r\n        uint ethCapPerAddress = getCurrentEthCapPerAddress();\r\n        participated[msg.sender] = participated[msg.sender].add(msg.value);\r\n        return super.validPurchase() && participated[msg.sender] <= ethCapPerAddress;\r\n    }\r\n\r\n    \/**\r\n     * @dev Set the individual cap for the first day. This function can not be called withing the 24h before the sale for security reasons\r\n     * @param _baseEthCapPerAddress base cap in wei\r\n     *\/\r\n    function setBaseEthCapPerAddress(uint256 _baseEthCapPerAddress) \r\n        public\r\n        onlyOwner \r\n        only24HBeforeSale\r\n    {\r\n        baseEthCapPerAddress = _baseEthCapPerAddress;\r\n    }\r\n\r\n    \/**\r\n     * @dev Get the current individual cap. \r\n     * @dev This amount increase everyday in an exponential way. Day 1: base cap, Day 2: 2 * base cap, Day 3: 4 * base cap ...\r\n     * @return individual cap in wei\r\n     *\/\r\n    function getCurrentEthCapPerAddress() \r\n        public\r\n        constant\r\n        returns(uint)\r\n    {\r\n        if (block.timestamp < startTime) return 0;\r\n        uint timeSinceStartInSec = block.timestamp.sub(startTime);\r\n        uint currentPeriod = timeSinceStartInSec.div(TIME_PERIOD_IN_SEC).add(1);\r\n\r\n        \/\/ for currentPeriod > 256 will always return baseEthCapPerAddress\r\n        return (2 ** currentPeriod.sub(1)).mul(baseEthCapPerAddress);\r\n    }\r\n}\r\n\r\n\/**\r\n * @title WhitelistedCrowdsale\r\n * @dev This is an extension to add whitelist to a crowdsale\r\n * @author Request.network\r\n *\r\n *\/\r\ncontract WhitelistedCrowdsale is StandardCrowdsale, Ownable {\r\n    \r\n    mapping(address=>bool) public registered;\r\n\r\n    event RegistrationStatusChanged(address target, bool isRegistered);\r\n\r\n    \/**\r\n     * @dev Changes registration status of an address for participation.\r\n     * @param target Address that will be registered\/deregistered.\r\n     * @param isRegistered New registration status of address.\r\n     *\/\r\n    function changeRegistrationStatus(address target, bool isRegistered)\r\n        public\r\n        onlyOwner\r\n        only24HBeforeSale\r\n    {\r\n        registered[target] = isRegistered;\r\n        RegistrationStatusChanged(target, isRegistered);\r\n    }\r\n\r\n    \/**\r\n     * @dev Changes registration statuses of addresses for participation.\r\n     * @param targets Addresses that will be registered\/deregistered.\r\n     * @param isRegistered New registration status of addresses.\r\n     *\/\r\n    function changeRegistrationStatuses(address[] targets, bool isRegistered)\r\n        public\r\n        onlyOwner\r\n        only24HBeforeSale\r\n    {\r\n        for (uint i = 0; i < targets.length; i++) {\r\n            changeRegistrationStatus(targets[i], isRegistered);\r\n        }\r\n    }\r\n\r\n    \/**\r\n     * @dev overriding Crowdsale#validPurchase to add whilelist\r\n     * @return true if investors can buy at the moment, false otherwise\r\n     *\/\r\n    function validPurchase() internal returns (bool) {\r\n        return super.validPurchase() && registered[msg.sender];\r\n    }\r\n}\r\n\r\n\/**\r\n * @title The RequestToken contract\r\n * @dev The Request Token contract\r\n * @dev inherite from StandardToken and Ownable by Zeppelin\r\n * @author Request.network\r\n *\/\r\ncontract RequestToken is StandardToken, Ownable {\r\n    string  public  constant name = \"Request Token\";\r\n    string  public  constant symbol = \"REQ\";\r\n    uint8    public  constant decimals = 18;\r\n\r\n    uint    public  transferableStartTime;\r\n\r\n    address public  tokenSaleContract;\r\n    address public  earlyInvestorWallet;\r\n\r\n\r\n    modifier onlyWhenTransferEnabled() \r\n    {\r\n        if ( now <= transferableStartTime ) {\r\n            require(msg.sender == tokenSaleContract || msg.sender == earlyInvestorWallet || msg.sender == owner);\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier validDestination(address to) \r\n    {\r\n        require(to != address(this));\r\n        _;\r\n    }\r\n\r\n    function RequestToken(\r\n        uint tokenTotalAmount, \r\n        uint _transferableStartTime, \r\n        address _admin, \r\n        address _earlyInvestorWallet) \r\n    {\r\n        \/\/ Mint all tokens. Then disable minting forever.\r\n        totalSupply = tokenTotalAmount * (10 ** uint256(decimals));\r\n\r\n        balances[msg.sender] = totalSupply;\r\n        Transfer(address(0x0), msg.sender, totalSupply);\r\n\r\n        transferableStartTime = _transferableStartTime;\r\n        tokenSaleContract = msg.sender;\r\n        earlyInvestorWallet = _earlyInvestorWallet;\r\n\r\n        transferOwnership(_admin); \/\/ admin could drain tokens and eth that were sent here by mistake\r\n    }\r\n\r\n    \/**\r\n     * @dev override transfer token for a specified address to add onlyWhenTransferEnabled and validDestination\r\n     * @param _to The address to transfer to.\r\n     * @param _value The amount to be transferred.\r\n     *\/\r\n    function transfer(address _to, uint _value)\r\n        public\r\n        validDestination(_to)\r\n        onlyWhenTransferEnabled\r\n        returns (bool) \r\n    {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    \/**\r\n     * @dev override transferFrom token for a specified address to add onlyWhenTransferEnabled and validDestination\r\n     * @param _from The address to transfer from.\r\n     * @param _to The address to transfer to.\r\n     * @param _value The amount to be transferred.\r\n     *\/\r\n    function transferFrom(address _from, address _to, uint _value)\r\n        public\r\n        validDestination(_to)\r\n        onlyWhenTransferEnabled\r\n        returns (bool) \r\n    {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    event Burn(address indexed _burner, uint _value);\r\n\r\n    \/**\r\n     * @dev burn tokens\r\n     * @param _value The amount to be burned.\r\n     * @return always true (necessary in case of override)\r\n     *\/\r\n    function burn(uint _value) \r\n        public\r\n        onlyWhenTransferEnabled\r\n        returns (bool)\r\n    {\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        Burn(msg.sender, _value);\r\n        Transfer(msg.sender, address(0x0), _value);\r\n        return true;\r\n    }\r\n\r\n    \/**\r\n     * @dev burn tokens in the behalf of someone\r\n     * @param _from The address of the owner of the token.\r\n     * @param _value The amount to be burned.\r\n     * @return always true (necessary in case of override)\r\n     *\/\r\n    function burnFrom(address _from, uint256 _value) \r\n        public\r\n        onlyWhenTransferEnabled\r\n        returns(bool) \r\n    {\r\n        assert(transferFrom(_from, msg.sender, _value));\r\n        return burn(_value);\r\n    }\r\n\r\n    \/**\r\n     * @dev transfer to owner any tokens send by mistake on this contracts\r\n     * @param token The address of the token to transfer.\r\n     * @param amount The amount to be transfered.\r\n     *\/\r\n    function emergencyERC20Drain(ERC20 token, uint amount )\r\n        public\r\n        onlyOwner \r\n    {\r\n        token.transfer(owner, amount);\r\n    }\r\n}\r\n\r\n\/**\r\n * @title RequestTokenSale\r\n * @dev \r\n * We add new features to a base crowdsale using multiple inheritance.\r\n * We are using the following extensions:\r\n * CappedCrowdsale - sets a max boundary for raised funds\r\n * WhitelistedCrowdsale - add a whitelist\r\n * ProgressiveIndividualCappedCrowdsale - add a Progressive individual cap\r\n *\r\n * The code is based on the contracts of Open Zeppelin and we add our contracts : RequestTokenSale, WhiteListedCrowdsale, ProgressiveIndividualCappedCrowdsale and the Request Token\r\n *\r\n * @author Request.network\r\n *\/\r\ncontract RequestTokenSale is Ownable, CappedCrowdsale, WhitelistedCrowdsale, ProgressiveIndividualCappedCrowdsale {\r\n    \/\/ hard cap of the token sale in ether\r\n    uint private constant HARD_CAP_IN_WEI = 100000 ether;\r\n\r\n    \/\/ Total of Request Token supply\r\n    uint public constant TOTAL_REQUEST_TOKEN_SUPPLY = 1000000000;\r\n\r\n    \/\/ Token sale rate from ETH to REQ\r\n    uint private constant RATE_ETH_REQ = 5000;\r\n\r\n    \/\/ Token initialy distributed for the team (15%)\r\n    address public constant TEAM_VESTING_WALLET = 0xA76bC39aE4B88ef203C6Afe3fD219549d86D12f2;\r\n    uint public constant TEAM_VESTING_AMOUNT = 150000000e18;\r\n\r\n    \/\/ Token initialy distributed for the early investor (20%)\r\n    address public constant EARLY_INVESTOR_WALLET = 0xa579E31b930796e3Df50A56829cF82Db98b6F4B3;\r\n    uint public constant EARLY_INVESTOR_AMOUNT = 200000000e18;\r\n\r\n    \/\/ Token initialy distributed for the early foundation (15%)\r\n    \/\/ wallet use also to gather the ether of the token sale\r\n    address private constant REQUEST_FOUNDATION_WALLET = 0xdD76B55ee6dAfe0c7c978bff69206d476a5b9Ce7;\r\n    uint public constant REQUEST_FOUNDATION_AMOUNT = 150000000e18;\r\n\r\n    \/\/ PERIOD WHEN TOKEN IS NOT TRANSFERABLE AFTER THE SALE\r\n    uint public constant PERIOD_AFTERSALE_NOT_TRANSFERABLE_IN_SEC = 3 days;\r\n\r\n    function RequestTokenSale(uint256 _startTime, uint256 _endTime)\r\n      ProgressiveIndividualCappedCrowdsale()\r\n      WhitelistedCrowdsale()\r\n      CappedCrowdsale(HARD_CAP_IN_WEI)\r\n      StandardCrowdsale(_startTime, _endTime, RATE_ETH_REQ, REQUEST_FOUNDATION_WALLET)\r\n    {\r\n        token.transfer(TEAM_VESTING_WALLET, TEAM_VESTING_AMOUNT);\r\n\r\n        token.transfer(EARLY_INVESTOR_WALLET, EARLY_INVESTOR_AMOUNT);\r\n\r\n        token.transfer(REQUEST_FOUNDATION_WALLET, REQUEST_FOUNDATION_AMOUNT);\r\n    }\r\n\r\n    \/**\r\n     * @dev Create the Request token (override createTokenContract of StandardCrowdsale)\r\n     * @return the StandardToken created\r\n     *\/\r\n    function createTokenContract () \r\n      internal \r\n      returns(StandardToken) \r\n    {\r\n        return new RequestToken(TOTAL_REQUEST_TOKEN_SUPPLY, endTime.add(PERIOD_AFTERSALE_NOT_TRANSFERABLE_IN_SEC), REQUEST_FOUNDATION_WALLET, EARLY_INVESTOR_WALLET);\r\n    }\r\n\r\n    \/**\r\n     * @dev Transfer the unsold tokens to the request Foundation multisign wallet \r\n     * @dev Only for owner\r\n     * @return the StandardToken created\r\n     *\/\r\n    function drainRemainingToken () \r\n      public\r\n      onlyOwner\r\n    {\r\n        require(hasEnded());\r\n        token.transfer(REQUEST_FOUNDATION_WALLET, token.balanceOf(this));\r\n    }\r\n  \r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/RequestNetwork\/",
        "Telegram": "https:\/\/t.me\/requestnetwork",
        "Website": "https:\/\/request.network\/",
        "Email": "",
        "Twitter": "https:\/\/twitter.com\/requestnetwork"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x8f8221afbb33998d8584a2b05749ba73c37a938a#code"
    }, {
      "contractId": 16,
      "title": "IconomiToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "ICONOMI",
      "code": "pragma solidity ^0.4.0;\r\n\r\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\r\n\r\ncontract IconomiToken {\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n  event BlockLockSet(uint256 _value);\r\n  event NewOwner(address _newOwner);\r\n\r\n  modifier onlyOwner {\r\n    if (msg.sender == owner) {\r\n      _;\r\n    }\r\n  }\r\n\r\n  modifier blockLock(address _sender) {\r\n    if (!isLocked() || _sender == owner) {\r\n      _;\r\n    }\r\n  }\r\n\r\n  modifier checkIfToContract(address _to) {\r\n    if(_to != address(this))  {\r\n      _;\r\n    }\r\n  }\r\n\r\n  uint256 public totalSupply;\r\n  string public name;\r\n  uint8 public decimals;\r\n  string public symbol;\r\n  string public version = '0.0.1';\r\n  address public owner;\r\n  uint256 public lockedUntilBlock;\r\n\r\n  function IconomiToken(\r\n    uint256 _initialAmount,\r\n    string _tokenName,\r\n    uint8 _decimalUnits,\r\n    string _tokenSymbol,\r\n    uint256 _lockedUntilBlock\r\n    ) {\r\n\r\n    balances[msg.sender] = _initialAmount;\r\n    totalSupply = _initialAmount;\r\n    name = _tokenName;\r\n    decimals = _decimalUnits;\r\n    symbol = _tokenSymbol;\r\n    lockedUntilBlock = _lockedUntilBlock;\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n    tokenRecipient spender = tokenRecipient(_spender);\r\n    if (approve(_spender, _value)) {\r\n      spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n      return true;\r\n    }\r\n  }\r\n\r\n  function transfer(address _to, uint256 _value) blockLock(msg.sender) checkIfToContract(_to) returns (bool success) {\r\n    if (balances[msg.sender] >= _value && _value > 0) {\r\n      balances[msg.sender] -= _value;\r\n      balances[_to] += _value;\r\n      Transfer(msg.sender, _to, _value);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) blockLock(_from) checkIfToContract(_to) returns (bool success) {\r\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n      balances[_to] += _value;\r\n      balances[_from] -= _value;\r\n      allowed[_from][msg.sender] -= _value;\r\n      Transfer(_from, _to, _value);\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value) returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  function setBlockLock(uint256 _lockedUntilBlock) onlyOwner returns (bool success) {\r\n    lockedUntilBlock = _lockedUntilBlock;\r\n    BlockLockSet(_lockedUntilBlock);\r\n    return true;\r\n  }\r\n\r\n  function isLocked() constant returns (bool success) {\r\n    return lockedUntilBlock > block.number;\r\n  }\r\n\r\n  function replaceOwner(address _newOwner) onlyOwner returns (bool success) {\r\n    owner = _newOwner;\r\n    NewOwner(_newOwner);\r\n    return true;\r\n  }\r\n\r\n  mapping (address => uint256) balances;\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/ICONOMI",
        "Telegram": "",
        "Website": "https:\/\/iconomi.net\/",
        "Email": "mailto:support@iconomi.net",
        "Twitter": "https:\/\/twitter.com\/iconominet"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x888666ca69e0f178ded6d75b5726cee99a87d698#code"
    }, {
      "contractId": 17,
      "title": "MANAToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Decentraland",
      "code": "pragma solidity ^0.4.11;\r\n\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) constant returns (uint256);\r\n  function transfer(address to, uint256 value) returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  \/**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   *\/\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  \/**\r\n   * @dev Throws if called by any account other than the owner.\r\n   *\/\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  \/**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   *\/\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  \/**\r\n   * @dev modifier to allow actions only when the contract IS paused\r\n   *\/\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev modifier to allow actions only when the contract IS NOT paused\r\n   *\/\r\n  modifier whenPaused {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   *\/\r\n  function pause() onlyOwner whenNotPaused returns (bool) {\r\n    paused = true;\r\n    Pause();\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   *\/\r\n  function unpause() onlyOwner whenPaused returns (bool) {\r\n    paused = false;\r\n    Unpause();\r\n    return true;\r\n  }\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) returns (bool);\r\n  function approve(address spender, uint256 value) returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\n    uint256 c = a \/ b;\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  \/**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  *\/\r\n  function transfer(address _to, uint256 _value) returns (bool) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of. \r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  *\/\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  \/**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amout of tokens to be transfered\r\n   *\/\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    \/\/ Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    \/\/ require (_value <= _allowance);\r\n\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   *\/\r\n  function approve(address _spender, uint256 _value) returns (bool) {\r\n\r\n    \/\/ To change the approve amount you first have to reduce the addresses`\r\n    \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    \/\/  already 0 to mitigate the race condition described here:\r\n    \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifing the amount of tokens still avaible for the spender.\r\n   *\/\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\ncontract MintableToken is StandardToken, Ownable {\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will recieve the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   *\/\r\n  function mint(address _to, uint256 _amount) onlyOwner canMint returns (bool) {\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   *\/\r\n  function finishMinting() onlyOwner returns (bool) {\r\n    mintingFinished = true;\r\n    MintFinished();\r\n    return true;\r\n  }\r\n}\r\n\r\ncontract PausableToken is StandardToken, Pausable {\r\n\r\n  function transfer(address _to, uint _value) whenNotPaused returns (bool) {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) whenNotPaused returns (bool) {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n}\r\n\r\ncontract BurnableToken is StandardToken {\r\n\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n    \/**\r\n     * @dev Burns a specified amount of tokens.\r\n     * @param _value The amount of tokens to burn. \r\n     *\/\r\n    function burn(uint256 _value) public {\r\n        require(_value > 0);\r\n\r\n        address burner = msg.sender;\r\n        balances[burner] = balances[burner].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        Burn(msg.sender, _value);\r\n    }\r\n\r\n}\r\n\r\ncontract MANAToken is BurnableToken, PausableToken, MintableToken {\r\n\r\n    string public constant symbol = \"MANA\";\r\n\r\n    string public constant name = \"Decentraland MANA\";\r\n\r\n    uint8 public constant decimals = 18;\r\n\r\n    function burn(uint256 _value) whenNotPaused public {\r\n        super.burn(_value);\r\n    }\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/reddit.com\/r\/decentraland",
        "Telegram": "",
        "Website": "https:\/\/decentraland.org\/",
        "Email": "mailto:hello@decentraland.org",
        "Twitter": "https:\/\/twitter.com\/decentraland"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x0f5d2fb29fb7d3cfee444a200298f468908cc942#code"
    }, {
      "contractId": 18,
      "title": "Ethos Token",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Ethos",
      "code": "\/*\r\n * ERC20 interface\r\n * see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n *\/\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n\r\n\/**\r\n * Math operations with safety checks\r\n *\/\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a \/ b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n\/**\r\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\r\n *\r\n * Based on code by FirstBlood:\r\n * https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\n *\/\r\ncontract StandardToken is ERC20, SafeMath {\r\n\r\n  \/* Token supply got increased and a new owner received these tokens *\/\r\n  event Minted(address receiver, uint amount);\r\n\r\n  \/* Actual balances of token holders *\/\r\n  mapping(address => uint) balances;\r\n\r\n  \/* approve() allowances *\/\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  \/* Interface declaration *\/\r\n  function isToken() public constant returns (bool weAre) {\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   *\r\n   * Fix for the ERC20 short address attack\r\n   *\r\n   * http:\/\/vessenes.com\/the-erc20-short-address-attack-explained\/\r\n   *\/\r\n  modifier onlyPayloadSize(uint size) {\r\n     if(msg.data.length < size + 4) {\r\n       throw;\r\n     }\r\n     _;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n    uint _allowance = allowed[_from][msg.sender];\r\n\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n\r\n    \/\/ To change the approve amount you first have to reduce the addresses`\r\n    \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    \/\/  already 0 to mitigate the race condition described here:\r\n    \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\/**\r\n * Upgrade agent interface inspired by Lunyr.\r\n *\r\n * Upgrade agent transfers tokens to a new contract.\r\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\r\n *\/\r\ncontract UpgradeAgent {\r\n\r\n  uint public originalSupply;\r\n\r\n  \/** Interface marker *\/\r\n  function isUpgradeAgent() public constant returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  function upgradeFrom(address _from, uint256 _value) public;\r\n\r\n}\r\n\r\n\r\n\/**\r\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\r\n *\r\n * First envisioned by Golem and Lunyr projects.\r\n *\/\r\ncontract UpgradeableToken is StandardToken {\r\n\r\n  \/** Contract \/ person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. *\/\r\n  address public upgradeMaster;\r\n\r\n  \/** The next contract where the tokens will be migrated. *\/\r\n  UpgradeAgent public upgradeAgent;\r\n\r\n  \/** How many tokens we have upgraded by now. *\/\r\n  uint256 public totalUpgraded;\r\n\r\n  \/**\r\n   * Upgrade states.\r\n   *\r\n   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\r\n   * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet\r\n   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet\r\n   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\r\n   *\r\n   *\/\r\n  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\r\n\r\n  \/**\r\n   * Somebody has upgraded some of his tokens.\r\n   *\/\r\n  event Upgrade(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n  \/**\r\n   * New upgrade agent available.\r\n   *\/\r\n  event UpgradeAgentSet(address agent);\r\n\r\n  \/**\r\n   * Do not allow construction without upgrade master set.\r\n   *\/\r\n  function UpgradeableToken(address _upgradeMaster) {\r\n    upgradeMaster = _upgradeMaster;\r\n  }\r\n\r\n  \/**\r\n   * Allow the token holder to upgrade some of their tokens to a new contract.\r\n   *\/\r\n  function upgrade(uint256 value) public {\r\n\r\n      UpgradeState state = getUpgradeState();\r\n      if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\r\n        \/\/ Called in a bad state\r\n        throw;\r\n      }\r\n\r\n      \/\/ Validate input value.\r\n      if (value == 0) throw;\r\n\r\n      balances[msg.sender] = safeSub(balances[msg.sender], value);\r\n\r\n      \/\/ Take tokens out from circulation\r\n      totalSupply = safeSub(totalSupply, value);\r\n      totalUpgraded = safeAdd(totalUpgraded, value);\r\n\r\n      \/\/ Upgrade agent reissues the tokens\r\n      upgradeAgent.upgradeFrom(msg.sender, value);\r\n      Upgrade(msg.sender, upgradeAgent, value);\r\n  }\r\n\r\n  \/**\r\n   * Set an upgrade agent that handles\r\n   *\/\r\n  function setUpgradeAgent(address agent) external {\r\n\r\n      if(!canUpgrade()) {\r\n        \/\/ The token is not yet in a state that we could think upgrading\r\n        throw;\r\n      }\r\n\r\n      if (agent == 0x0) throw;\r\n      \/\/ Only a master can designate the next agent\r\n      if (msg.sender != upgradeMaster) throw;\r\n      \/\/ Upgrade has already begun for an agent\r\n      if (getUpgradeState() == UpgradeState.Upgrading) throw;\r\n\r\n      upgradeAgent = UpgradeAgent(agent);\r\n\r\n      \/\/ Bad interface\r\n      if(!upgradeAgent.isUpgradeAgent()) throw;\r\n      \/\/ Make sure that token supplies match in source and target\r\n      if (upgradeAgent.originalSupply() != totalSupply) throw;\r\n\r\n      UpgradeAgentSet(upgradeAgent);\r\n  }\r\n\r\n  \/**\r\n   * Get the state of the token upgrade.\r\n   *\/\r\n  function getUpgradeState() public constant returns(UpgradeState) {\r\n    if(!canUpgrade()) return UpgradeState.NotAllowed;\r\n    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\r\n    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\r\n    else return UpgradeState.Upgrading;\r\n  }\r\n\r\n  \/**\r\n   * Change the upgrade master.\r\n   *\r\n   * This allows us to set a new owner for the upgrade mechanism.\r\n   *\/\r\n  function setUpgradeMaster(address master) public {\r\n      if (master == 0x0) throw;\r\n      if (msg.sender != upgradeMaster) throw;\r\n      upgradeMaster = master;\r\n  }\r\n\r\n  \/**\r\n   * Child contract can enable to provide the condition when the upgrade can begun.\r\n   *\/\r\n  function canUpgrade() public constant returns(bool) {\r\n     return true;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\/*\r\n * Ownable\r\n *\r\n * Base contract with an owner.\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\n *\/\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\/**\r\n * Define interface for releasing the token transfer after a successful crowdsale.\r\n *\/\r\ncontract ReleasableToken is ERC20, Ownable {\r\n\r\n  \/* The finalizer contract that allows unlift the transfer limits on this token *\/\r\n  address public releaseAgent;\r\n\r\n  \/** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*\/\r\n  bool public released = false;\r\n\r\n  \/** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. *\/\r\n  mapping (address => bool) public transferAgents;\r\n\r\n  \/**\r\n   * Limit token transfer until the crowdsale is over.\r\n   *\r\n   *\/\r\n  modifier canTransfer(address _sender) {\r\n\r\n    if(!released) {\r\n        if(!transferAgents[_sender]) {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * Set the contract that can call release and make the token transferable.\r\n   *\r\n   * Design choice. Allow reset the release agent to fix fat finger mistakes.\r\n   *\/\r\n  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\r\n\r\n    \/\/ We don't do interface check here as we might want to a normal wallet address to act as a release agent\r\n    releaseAgent = addr;\r\n  }\r\n\r\n  \/**\r\n   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.\r\n   *\/\r\n  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\r\n    transferAgents[addr] = state;\r\n  }\r\n\r\n  \/**\r\n   * One way function to release the tokens to the wild.\r\n   *\r\n   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).\r\n   *\/\r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\n    released = true;\r\n  }\r\n\r\n  \/** The function can be called only before or after the tokens have been releasesd *\/\r\n  modifier inReleaseState(bool releaseState) {\r\n    if(releaseState != released) {\r\n        throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  \/** The function can be called only by a whitelisted release agent. *\/\r\n  modifier onlyReleaseAgent() {\r\n    if(msg.sender != releaseAgent) {\r\n        throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\r\n    \/\/ Call StandardToken.transfer()\r\n   return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\r\n    \/\/ Call StandardToken.transferForm()\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\/**\r\n * Safe unsigned safe math.\r\n *\r\n * https:\/\/blog.aragon.one\/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli\r\n *\r\n * Originally from https:\/\/raw.githubusercontent.com\/AragonOne\/zeppelin-solidity\/master\/contracts\/SafeMathLib.sol\r\n *\r\n * Maintained here until merged to mainline zeppelin-solidity.\r\n *\r\n *\/\r\nlibrary SafeMathLib {\r\n\r\n  function times(uint a, uint b) returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function minus(uint a, uint b) returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function plus(uint a, uint b) returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a);\r\n    return c;\r\n  }\r\n\r\n  function assert(bool assertion) private {\r\n    if (!assertion) throw;\r\n  }\r\n}\r\n\r\n\r\n\r\n\/**\r\n * A token that can increase its supply by another contract.\r\n *\r\n * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\r\n * Only mint agents, contracts whitelisted by owner, can mint new tokens.\r\n *\r\n *\/\r\ncontract MintableToken is StandardToken, Ownable {\r\n\r\n  using SafeMathLib for uint;\r\n\r\n  bool public mintingFinished = false;\r\n\r\n  \/** List of agents that are allowed to create new tokens *\/\r\n  mapping (address => bool) public mintAgents;\r\n\r\n  event MintingAgentChanged(address addr, bool state  );\r\n\r\n  \/**\r\n   * Create new tokens and allocate them to an address..\r\n   *\r\n   * Only callably by a crowdsale contract (mint agent).\r\n   *\/\r\n  function mint(address receiver, uint amount) onlyMintAgent canMint public {\r\n    totalSupply = totalSupply.plus(amount);\r\n    balances[receiver] = balances[receiver].plus(amount);\r\n\r\n    \/\/ This will make the mint transaction apper in EtherScan.io\r\n    \/\/ We can remove this after there is a standardized minting event\r\n    Transfer(0, receiver, amount);\r\n  }\r\n\r\n  \/**\r\n   * Owner can allow a crowdsale contract to mint new tokens.\r\n   *\/\r\n  function setMintAgent(address addr, bool state) onlyOwner canMint public {\r\n    mintAgents[addr] = state;\r\n    MintingAgentChanged(addr, state);\r\n  }\r\n\r\n  modifier onlyMintAgent() {\r\n    \/\/ Only crowdsale contracts are allowed to mint new tokens\r\n    if(!mintAgents[msg.sender]) {\r\n        throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  \/** Make sure we are not done yet. *\/\r\n  modifier canMint() {\r\n    if(mintingFinished) throw;\r\n    _;\r\n  }\r\n}\r\n\r\n\r\n\r\n\/**\r\n * A crowdsaled token.\r\n *\r\n * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\r\n *\r\n * - The token transfer() is disabled until the crowdsale is over\r\n * - The token contract gives an opt-in upgrade path to a new contract\r\n * - The same token can be part of several crowdsales through approve() mechanism\r\n * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\r\n *\r\n *\/\r\ncontract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken {\r\n\r\n  \/** Name and symbol were updated. *\/\r\n  event UpdatedTokenInformation(string newName, string newSymbol);\r\n\r\n  string public name;\r\n\r\n  string public symbol;\r\n\r\n  uint public decimals;\r\n\r\n  \/**\r\n   * Construct the token.\r\n   *\r\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\r\n   *\r\n   * @param _name Token name\r\n   * @param _symbol Token symbol - should be all caps\r\n   * @param _initialSupply How many tokens we start with\r\n   * @param _decimals Number of decimal places\r\n   * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.\r\n   *\/\r\n  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)\r\n    UpgradeableToken(msg.sender) {\r\n\r\n    \/\/ Create any address, can be transferred\r\n    \/\/ to team multisig via changeOwner(),\r\n    \/\/ also remember to call setUpgradeMaster()\r\n    owner = msg.sender;\r\n\r\n    name = _name;\r\n    symbol = _symbol;\r\n\r\n    totalSupply = _initialSupply;\r\n\r\n    decimals = _decimals;\r\n\r\n    \/\/ Create initially all balance on the team multisig\r\n    balances[owner] = totalSupply;\r\n\r\n    if(totalSupply > 0) {\r\n      Minted(owner, totalSupply);\r\n    }\r\n\r\n    \/\/ No more new supply allowed after the token creation\r\n    if(!_mintable) {\r\n      mintingFinished = true;\r\n      if(totalSupply == 0) {\r\n        throw; \/\/ Cannot create a token without supply and no minting\r\n      }\r\n    }\r\n  }\r\n\r\n  \/**\r\n   * When token is released to be transferable, enforce no new tokens can be created.\r\n   *\/\r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\n    mintingFinished = true;\r\n    super.releaseTokenTransfer();\r\n  }\r\n\r\n  \/**\r\n   * Allow upgrade agent functionality kick in only if the crowdsale was success.\r\n   *\/\r\n  function canUpgrade() public constant returns(bool) {\r\n    return released && super.canUpgrade();\r\n  }\r\n\r\n  \/**\r\n   * Owner can update token information here.\r\n   *\r\n   * It is often useful to conceal the actual token association, until\r\n   * the token operations, like central issuance or reissuance have been completed.\r\n   *\r\n   * This function allows the token owner to rename the token after the operations\r\n   * have been completed and then point the audience to use the token contract.\r\n   *\/\r\n  function setTokenInformation(string _name, string _symbol) onlyOwner {\r\n    name = _name;\r\n    symbol = _symbol;\r\n\r\n    UpdatedTokenInformation(name, symbol);\r\n  }\r\n\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/ethos_io\/",
        "Telegram": "https:\/\/t.me\/ethos_io",
        "Website": "https:\/\/www.ethos.io\/",
        "Email": "mailto:press@ethos.io",
        "Twitter": "https:\/\/twitter.com\/ethos_io"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x5af2be193a6abca9c8817001f45744777db30756#code"
    }, {
      "contractId": 19,
      "title": "CDTToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "CoinDash",
      "code": "pragma solidity ^0.4.8;\r\n\r\n\/**\r\n * Math operations with safety checks\r\n *\/\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\n    uint c = a \/ b;\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n\/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n *\/\r\ncontract ERC20Basic {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function transfer(address to, uint value);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\n\/**\r\n * @title ERC20 interface\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n *\/\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n  function transferFrom(address from, address to, uint value);\r\n  function approve(address spender, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n\/**\r\n * @title LimitedTransferToken\r\n * @dev LimitedTransferToken defines the generic interface and the implementation to limit token \r\n * transferability for different events. It is intended to be used as a base class for other token \r\n * contracts. \r\n * LimitedTransferToken has been designed to allow for different limiting factors,\r\n * this can be achieved by recursively calling super.transferableTokens() until the base class is \r\n * hit. For example:\r\n *     function transferableTokens(address holder, uint64 time) constant public returns (uint256) {\r\n *       return min256(unlockedTokens, super.transferableTokens(holder, time));\r\n *     }\r\n * A working example is VestedToken.sol:\r\n * https:\/\/github.com\/OpenZeppelin\/zeppelin-solidity\/blob\/master\/contracts\/token\/VestedToken.sol\r\n *\/\r\n\r\ncontract LimitedTransferToken is ERC20 {\r\n\r\n  \/**\r\n   * @dev Checks whether it can transfer or otherwise throws.\r\n   *\/\r\n  modifier canTransfer(address _sender, uint _value) {\r\n   if (_value > transferableTokens(_sender, uint64(now))) throw;\r\n   _;\r\n  }\r\n\r\n  \/**\r\n   * @dev Checks modifier and allows transfer if tokens are not locked.\r\n   * @param _to The address that will recieve the tokens.\r\n   * @param _value The amount of tokens to be transferred.\r\n   *\/\r\n  function transfer(address _to, uint _value) canTransfer(msg.sender, _value) {\r\n   return super.transfer(_to, _value);\r\n  }\r\n\r\n  \/**\r\n  * @dev Checks modifier and allows transfer if tokens are not locked.\r\n  * @param _from The address that will send the tokens.\r\n  * @param _to The address that will recieve the tokens.\r\n  * @param _value The amount of tokens to be transferred.\r\n  *\/\r\n  function transferFrom(address _from, address _to, uint _value) canTransfer(_from, _value) {\r\n   return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n  \/**\r\n   * @dev Default transferable tokens function returns all tokens for a holder (no limit).\r\n   * @dev Overwriting transferableTokens(address holder, uint64 time) is the way to provide the \r\n   * specific logic for limiting token transferability for a holder over time.\r\n   *\/\r\n  function transferableTokens(address holder, uint64 time) constant public returns (uint256) {\r\n    return balanceOf(holder);\r\n  }\r\n}\r\n\r\n\r\n\/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances. \r\n *\/\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint;\r\n\r\n  mapping(address => uint) balances;\r\n\r\n  \/**\r\n   * @dev Fix for the ERC20 short address attack.\r\n   *\/\r\n  modifier onlyPayloadSize(uint size) {\r\n     if(msg.data.length < size + 4) {\r\n       throw;\r\n     }\r\n     _;\r\n  }\r\n\r\n  \/**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  *\/\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n  }\r\n\r\n  \/**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of. \r\n  * @return An uint representing the amount owned by the passed address.\r\n  *\/\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n\r\n\/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implemantation of the basic standart token.\r\n * @dev https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n * @dev Based on code by FirstBlood: https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\n *\/\r\ncontract StandardToken is BasicToken, ERC20 {\r\n\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n\r\n  \/**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint the amout of tokens to be transfered\r\n   *\/\r\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    \/\/ Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    \/\/ if (_value > _allowance) throw;\r\n\r\n    balances[_to] = balances[_to].add(_value);\r\n    balances[_from] = balances[_from].sub(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n  }\r\n\r\n  \/**\r\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   *\/\r\n  function approve(address _spender, uint _value) {\r\n\r\n    \/\/ To change the approve amount you first have to reduce the addresses`\r\n    \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    \/\/  already 0 to mitigate the race condition described here:\r\n    \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n  }\r\n\r\n  \/**\r\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint specifing the amount of tokens still avaible for the spender.\r\n   *\/\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n\r\n\/**\r\n * @title Vested token\r\n * @dev Tokens that can be vested for a group of addresses.\r\n *\/\r\ncontract VestedToken is StandardToken, LimitedTransferToken {\r\n\r\n  uint256 MAX_GRANTS_PER_ADDRESS = 20;\r\n\r\n  struct TokenGrant {\r\n    address granter;     \/\/ 20 bytes\r\n    uint256 value;       \/\/ 32 bytes\r\n    uint64 cliff;\r\n    uint64 vesting;\r\n    uint64 start;        \/\/ 3 * 8 = 24 bytes\r\n    bool revokable;\r\n    bool burnsOnRevoke;  \/\/ 2 * 1 = 2 bits? or 2 bytes?\r\n  } \/\/ total 78 bytes = 3 sstore per operation (32 per sstore)\r\n\r\n  mapping (address => TokenGrant[]) public grants;\r\n\r\n  event NewTokenGrant(address indexed from, address indexed to, uint256 value, uint256 grantId);\r\n\r\n  \/**\r\n   * @dev Grant tokens to a specified address\r\n   * @param _to address The address which the tokens will be granted to.\r\n   * @param _value uint256 The amount of tokens to be granted.\r\n   * @param _start uint64 Time of the beginning of the grant.\r\n   * @param _cliff uint64 Time of the cliff period.\r\n   * @param _vesting uint64 The vesting period.\r\n   *\/\r\n  function grantVestedTokens(\r\n    address _to,\r\n    uint256 _value,\r\n    uint64 _start,\r\n    uint64 _cliff,\r\n    uint64 _vesting,\r\n    bool _revokable,\r\n    bool _burnsOnRevoke\r\n  ) public {\r\n\r\n    \/\/ Check for date inconsistencies that may cause unexpected behavior\r\n    if (_cliff < _start || _vesting < _cliff) {\r\n      throw;\r\n    }\r\n\r\n    if (tokenGrantsCount(_to) > MAX_GRANTS_PER_ADDRESS) throw;   \/\/ To prevent a user being spammed and have his balance locked (out of gas attack when calculating vesting).\r\n\r\n    uint count = grants[_to].push(\r\n                TokenGrant(\r\n                  _revokable ? msg.sender : 0, \/\/ avoid storing an extra 20 bytes when it is non-revokable\r\n                  _value,\r\n                  _cliff,\r\n                  _vesting,\r\n                  _start,\r\n                  _revokable,\r\n                  _burnsOnRevoke\r\n                )\r\n              );\r\n\r\n    transfer(_to, _value);\r\n\r\n    NewTokenGrant(msg.sender, _to, _value, count - 1);\r\n  }\r\n\r\n  \/**\r\n   * @dev Revoke the grant of tokens of a specifed address.\r\n   * @param _holder The address which will have its tokens revoked.\r\n   * @param _grantId The id of the token grant.\r\n   *\/\r\n  function revokeTokenGrant(address _holder, uint _grantId) public {\r\n    TokenGrant grant = grants[_holder][_grantId];\r\n\r\n    if (!grant.revokable) { \/\/ Check if grant was revokable\r\n      throw;\r\n    }\r\n\r\n    if (grant.granter != msg.sender) { \/\/ Only granter can revoke it\r\n      throw;\r\n    }\r\n\r\n    address receiver = grant.burnsOnRevoke ? 0xdead : msg.sender;\r\n\r\n    uint256 nonVested = nonVestedTokens(grant, uint64(now));\r\n\r\n    \/\/ remove grant from array\r\n    delete grants[_holder][_grantId];\r\n    grants[_holder][_grantId] = grants[_holder][grants[_holder].length.sub(1)];\r\n    grants[_holder].length -= 1;\r\n\r\n    balances[receiver] = balances[receiver].add(nonVested);\r\n    balances[_holder] = balances[_holder].sub(nonVested);\r\n\r\n    Transfer(_holder, receiver, nonVested);\r\n  }\r\n\r\n\r\n  \/**\r\n   * @dev Calculate the total amount of transferable tokens of a holder at a given time\r\n   * @param holder address The address of the holder\r\n   * @param time uint64 The specific time.\r\n   * @return An uint representing a holder's total amount of transferable tokens.\r\n   *\/\r\n  function transferableTokens(address holder, uint64 time) constant public returns (uint256) {\r\n    uint256 grantIndex = tokenGrantsCount(holder);\r\n\r\n    if (grantIndex == 0) return balanceOf(holder); \/\/ shortcut for holder without grants\r\n\r\n    \/\/ Iterate through all the grants the holder has, and add all non-vested tokens\r\n    uint256 nonVested = 0;\r\n    for (uint256 i = 0; i < grantIndex; i++) {\r\n      nonVested = SafeMath.add(nonVested, nonVestedTokens(grants[holder][i], time));\r\n    }\r\n\r\n    \/\/ Balance - totalNonVested is the amount of tokens a holder can transfer at any given time\r\n    uint256 vestedTransferable = SafeMath.sub(balanceOf(holder), nonVested);\r\n\r\n    \/\/ Return the minimum of how many vested can transfer and other value\r\n    \/\/ in case there are other limiting transferability factors (default is balanceOf)\r\n    return SafeMath.min256(vestedTransferable, super.transferableTokens(holder, time));\r\n  }\r\n\r\n  \/**\r\n   * @dev Check the amount of grants that an address has.\r\n   * @param _holder The holder of the grants.\r\n   * @return A uint representing the total amount of grants.\r\n   *\/\r\n  function tokenGrantsCount(address _holder) constant returns (uint index) {\r\n    return grants[_holder].length;\r\n  }\r\n\r\n  \/**\r\n   * @dev Calculate amount of vested tokens at a specifc time.\r\n   * @param tokens uint256 The amount of tokens grantted.\r\n   * @param time uint64 The time to be checked\r\n   * @param start uint64 A time representing the begining of the grant\r\n   * @param cliff uint64 The cliff period.\r\n   * @param vesting uint64 The vesting period.\r\n   * @return An uint representing the amount of vested tokensof a specif grant.\r\n   *  transferableTokens\r\n   *   |                         _\/--------   vestedTokens rect\r\n   *   |                       _\/\r\n   *   |                     _\/\r\n   *   |                   _\/\r\n   *   |                 _\/\r\n   *   |                \/\r\n   *   |              .|\r\n   *   |            .  |\r\n   *   |          .    |\r\n   *   |        .      |\r\n   *   |      .        |\r\n   *   |    .          |\r\n   *   +===+===========+---------+----------> time\r\n   *      Start       Clift    Vesting\r\n   *\/\r\n  function calculateVestedTokens(\r\n    uint256 tokens,\r\n    uint256 time,\r\n    uint256 start,\r\n    uint256 cliff,\r\n    uint256 vesting) constant returns (uint256)\r\n    {\r\n      \/\/ Shortcuts for before cliff and after vesting cases.\r\n      if (time < cliff) return 0;\r\n      if (time >= vesting) return tokens;\r\n\r\n      \/\/ Interpolate all vested tokens.\r\n      \/\/ As before cliff the shortcut returns 0, we can use just calculate a value\r\n      \/\/ in the vesting rect (as shown in above's figure)\r\n\r\n      \/\/ vestedTokens = tokens * (time - start) \/ (vesting - start)\r\n      uint256 vestedTokens = SafeMath.div(\r\n                                    SafeMath.mul(\r\n                                      tokens,\r\n                                      SafeMath.sub(time, start)\r\n                                      ),\r\n                                    SafeMath.sub(vesting, start)\r\n                                    );\r\n\r\n      return vestedTokens;\r\n  }\r\n\r\n  \/**\r\n   * @dev Get all information about a specifc grant.\r\n   * @param _holder The address which will have its tokens revoked.\r\n   * @param _grantId The id of the token grant.\r\n   * @return Returns all the values that represent a TokenGrant(address, value, start, cliff,\r\n   * revokability, burnsOnRevoke, and vesting) plus the vested value at the current time.\r\n   *\/\r\n  function tokenGrant(address _holder, uint _grantId) constant returns (address granter, uint256 value, uint256 vested, uint64 start, uint64 cliff, uint64 vesting, bool revokable, bool burnsOnRevoke) {\r\n    TokenGrant grant = grants[_holder][_grantId];\r\n\r\n    granter = grant.granter;\r\n    value = grant.value;\r\n    start = grant.start;\r\n    cliff = grant.cliff;\r\n    vesting = grant.vesting;\r\n    revokable = grant.revokable;\r\n    burnsOnRevoke = grant.burnsOnRevoke;\r\n\r\n    vested = vestedTokens(grant, uint64(now));\r\n  }\r\n\r\n  \/**\r\n   * @dev Get the amount of vested tokens at a specific time.\r\n   * @param grant TokenGrant The grant to be checked.\r\n   * @param time The time to be checked\r\n   * @return An uint representing the amount of vested tokens of a specific grant at a specific time.\r\n   *\/\r\n  function vestedTokens(TokenGrant grant, uint64 time) private constant returns (uint256) {\r\n    return calculateVestedTokens(\r\n      grant.value,\r\n      uint256(time),\r\n      uint256(grant.start),\r\n      uint256(grant.cliff),\r\n      uint256(grant.vesting)\r\n    );\r\n  }\r\n\r\n  \/**\r\n   * @dev Calculate the amount of non vested tokens at a specific time.\r\n   * @param grant TokenGrant The grant to be checked.\r\n   * @param time uint64 The time to be checked\r\n   * @return An uint representing the amount of non vested tokens of a specifc grant on the \r\n   * passed time frame.\r\n   *\/\r\n  function nonVestedTokens(TokenGrant grant, uint64 time) private constant returns (uint256) {\r\n    return grant.value.sub(vestedTokens(grant, time));\r\n  }\r\n\r\n  \/**\r\n   * @dev Calculate the date when the holder can trasfer all its tokens\r\n   * @param holder address The address of the holder\r\n   * @return An uint representing the date of the last transferable tokens.\r\n   *\/\r\n  function lastTokenIsTransferableDate(address holder) constant public returns (uint64 date) {\r\n    date = uint64(now);\r\n    uint256 grantIndex = grants[holder].length;\r\n    for (uint256 i = 0; i < grantIndex; i++) {\r\n      date = SafeMath.max64(grants[holder][i].vesting, date);\r\n    }\r\n  }\r\n}\r\n\r\ncontract CDTToken is VestedToken {\r\n\tusing SafeMath for uint;\r\n\r\n\t\/\/FIELDS\r\n\t\/\/CONSTANTS\r\n\tuint public constant decimals = 18;  \/\/ 18 decimal places, the same as ETH.\r\n\tstring public constant name = \"CoinDash Token\";\r\n  \tstring public constant symbol = \"CDT\";\r\n\r\n\t\/\/ASSIGNED IN INITIALIZATION\r\n\taddress public creator; \/\/address of the account which may mint new tokens\r\n\r\n\t\/\/May only be called by the owner address\r\n\tmodifier only_owner() {\r\n\t\tif (msg.sender != creator) throw;\r\n\t\t_;\r\n\t}\r\n\r\n\r\n\t\/\/ Initialization contract assigns address of crowdfund contract and end time.\r\n\tfunction CDTToken(uint supply) {\r\n\t\ttotalSupply = supply;\r\n\t\tcreator = msg.sender;\r\n\t\t\r\n\t\tbalances[msg.sender] = supply;\r\n\r\n\t\tMAX_GRANTS_PER_ADDRESS = 2;\r\n\t}\r\n\r\n\t\/\/ Fallback function throws when called.\r\n\tfunction() {\r\n\t\tthrow;\r\n\t}\r\n\r\n\tfunction vestedBalanceOf(address _owner) constant returns (uint balance) {\r\n\t    return transferableTokens(_owner, uint64(now));\r\n    }\r\n\r\n        \/\/failsafe drain\r\n\tfunction drain()\r\n\t\tonly_owner\r\n\t{\r\n\t\tif (!creator.send(this.balance)) throw;\r\n\t}\r\n}",
      "officialLinks": {
        "Reddit": "",
        "Telegram": "",
        "Website": "https:\/\/coindash.io\/",
        "Email": "mailto:contact@coindash.io",
        "Twitter": "https:\/\/twitter.com\/coindashio"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x177d39ac676ed1c67a2b268ad7f1e58826e5b0af#code"
    }, {
      "contractId": 20,
      "title": "SmartToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Bancor",
      "code": "pragma solidity ^0.4.11;\r\n\r\n\/*\r\n    Overflow protected math functions\r\n*\/\r\ncontract SafeMath {\r\n    \/**\r\n        constructor\r\n    *\/\r\n    function SafeMath() {\r\n    }\r\n\r\n    \/**\r\n        @dev returns the sum of _x and _y, asserts if the calculation overflows\r\n\r\n        @param _x   value 1\r\n        @param _y   value 2\r\n\r\n        @return sum\r\n    *\/\r\n    function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        assert(z >= _x);\r\n        return z;\r\n    }\r\n\r\n    \/**\r\n        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\r\n\r\n        @param _x   minuend\r\n        @param _y   subtrahend\r\n\r\n        @return difference\r\n    *\/\r\n    function safeSub(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        assert(_x >= _y);\r\n        return _x - _y;\r\n    }\r\n\r\n    \/**\r\n        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\r\n\r\n        @param _x   factor 1\r\n        @param _y   factor 2\r\n\r\n        @return product\r\n    *\/\r\n    function safeMul(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        uint256 z = _x * _y;\r\n        assert(_x == 0 || z \/ _x == _y);\r\n        return z;\r\n    }\r\n} \r\n\r\n\/*\r\n    Owned contract interface\r\n*\/\r\ncontract IOwned {\r\n    \/\/ this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public constant returns (address owner) { owner; }\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n}\r\n\r\n\/*\r\n    Provides support and utilities for contract ownership\r\n*\/\r\ncontract Owned is IOwned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n\r\n    \/**\r\n        @dev constructor\r\n    *\/\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    \/\/ allows execution by the owner only\r\n    modifier ownerOnly {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    \/**\r\n        @dev allows transferring the contract ownership\r\n        the new owner still need to accept the transfer\r\n        can only be called by the contract owner\r\n\r\n        @param _newOwner    new contract owner\r\n    *\/\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    \/**\r\n        @dev used by a new owner to accept an ownership transfer\r\n    *\/\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n}\r\n\r\n\/*\r\n    Token Holder interface\r\n*\/\r\ncontract ITokenHolder is IOwned {\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\r\n}\r\n\r\n\/*\r\n    We consider every contract to be a 'token holder' since it's currently not possible\r\n    for a contract to deny receiving tokens.\r\n\r\n    The TokenHolder's contract sole purpose is to provide a safety mechanism that allows\r\n    the owner to send tokens that were sent to the contract by mistake back to their sender.\r\n*\/\r\ncontract TokenHolder is ITokenHolder, Owned {\r\n    \/**\r\n        @dev constructor\r\n    *\/\r\n    function TokenHolder() {\r\n    }\r\n\r\n    \/\/ validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        require(_address != 0x0);\r\n        _;\r\n    }\r\n\r\n    \/\/ verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        require(_address != address(this));\r\n        _;\r\n    }\r\n\r\n    \/**\r\n        @dev withdraws tokens held by the contract and sends them to an account\r\n        can only be called by the owner\r\n\r\n        @param _token   ERC20 token contract address\r\n        @param _to      account to receive the new amount\r\n        @param _amount  amount to withdraw\r\n    *\/\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\r\n        public\r\n        ownerOnly\r\n        validAddress(_token)\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        assert(_token.transfer(_to, _amount));\r\n    }\r\n}\r\n\r\n\/*\r\n    ERC20 Standard Token interface\r\n*\/\r\ncontract IERC20Token {\r\n    \/\/ these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public constant returns (string name) { name; }\r\n    function symbol() public constant returns (string symbol) { symbol; }\r\n    function decimals() public constant returns (uint8 decimals) { decimals; }\r\n    function totalSupply() public constant returns (uint256 totalSupply) { totalSupply; }\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; }\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n\/**\r\n    ERC20 Standard Token implementation\r\n*\/\r\ncontract ERC20Token is IERC20Token, SafeMath {\r\n    string public standard = 'Token 0.1';\r\n    string public name = '';\r\n    string public symbol = '';\r\n    uint8 public decimals = 0;\r\n    uint256 public totalSupply = 0;\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    \/**\r\n        @dev constructor\r\n\r\n        @param _name        token name\r\n        @param _symbol      token symbol\r\n        @param _decimals    decimal points, for display purposes\r\n    *\/\r\n    function ERC20Token(string _name, string _symbol, uint8 _decimals) {\r\n        require(bytes(_name).length > 0 && bytes(_symbol).length > 0); \/\/ validate input\r\n\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n    }\r\n\r\n    \/\/ validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        require(_address != 0x0);\r\n        _;\r\n    }\r\n\r\n    \/**\r\n        @dev send coins\r\n        throws on any error rather then return a false flag to minimize user errors\r\n\r\n        @param _to      target address\r\n        @param _value   transfer amount\r\n\r\n        @return true if the transfer was successful, false if it wasn't\r\n    *\/\r\n    function transfer(address _to, uint256 _value)\r\n        public\r\n        validAddress(_to)\r\n        returns (bool success)\r\n    {\r\n        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);\r\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    \/**\r\n        @dev an account\/contract attempts to get the coins\r\n        throws on any error rather then return a false flag to minimize user errors\r\n\r\n        @param _from    source address\r\n        @param _to      target address\r\n        @param _value   transfer amount\r\n\r\n        @return true if the transfer was successful, false if it wasn't\r\n    *\/\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public\r\n        validAddress(_from)\r\n        validAddress(_to)\r\n        returns (bool success)\r\n    {\r\n        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value);\r\n        balanceOf[_from] = safeSub(balanceOf[_from], _value);\r\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    \/**\r\n        @dev allow another account\/contract to spend some tokens on your behalf\r\n        throws on any error rather then return a false flag to minimize user errors\r\n\r\n        also, to minimize the risk of the approve\/transferFrom attack vector\r\n        (see https:\/\/docs.google.com\/document\/d\/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM\/), approve has to be called twice\r\n        in 2 separate transactions - once to change the allowance to 0 and secondly to change it to the new allowance value\r\n\r\n        @param _spender approved address\r\n        @param _value   allowance amount\r\n\r\n        @return true if the approval was successful, false if it wasn't\r\n    *\/\r\n    function approve(address _spender, uint256 _value)\r\n        public\r\n        validAddress(_spender)\r\n        returns (bool success)\r\n    {\r\n        \/\/ if the allowance isn't 0, it can only be updated to 0 to prevent an allowance change immediately after withdrawal\r\n        require(_value == 0 || allowance[msg.sender][_spender] == 0);\r\n\r\n        allowance[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n}\r\n\r\n\/*\r\n    Smart Token interface\r\n*\/\r\ncontract ISmartToken is ITokenHolder, IERC20Token {\r\n    function disableTransfers(bool _disable) public;\r\n    function issue(address _to, uint256 _amount) public;\r\n    function destroy(address _from, uint256 _amount) public;\r\n}\r\n\r\n\/*\r\n    Smart Token v0.2\r\n\r\n    'Owned' is specified here for readability reasons\r\n*\/\r\ncontract SmartToken is ISmartToken, ERC20Token, Owned, TokenHolder {\r\n    string public version = '0.2';\r\n\r\n    bool public transfersEnabled = true;    \/\/ true if transfer\/transferFrom are enabled, false if not\r\n\r\n    \/\/ triggered when a smart token is deployed - the _token address is defined for forward compatibility, in case we want to trigger the event from a factory\r\n    event NewSmartToken(address _token);\r\n    \/\/ triggered when the total supply is increased\r\n    event Issuance(uint256 _amount);\r\n    \/\/ triggered when the total supply is decreased\r\n    event Destruction(uint256 _amount);\r\n\r\n    \/**\r\n        @dev constructor\r\n\r\n        @param _name       token name\r\n        @param _symbol     token short symbol, 1-6 characters\r\n        @param _decimals   for display purposes only\r\n    *\/\r\n    function SmartToken(string _name, string _symbol, uint8 _decimals)\r\n        ERC20Token(_name, _symbol, _decimals)\r\n    {\r\n        require(bytes(_symbol).length <= 6); \/\/ validate input\r\n        NewSmartToken(address(this));\r\n    }\r\n\r\n    \/\/ allows execution only when transfers aren't disabled\r\n    modifier transfersAllowed {\r\n        assert(transfersEnabled);\r\n        _;\r\n    }\r\n\r\n    \/**\r\n        @dev disables\/enables transfers\r\n        can only be called by the contract owner\r\n\r\n        @param _disable    true to disable transfers, false to enable them\r\n    *\/\r\n    function disableTransfers(bool _disable) public ownerOnly {\r\n        transfersEnabled = !_disable;\r\n    }\r\n\r\n    \/**\r\n        @dev increases the token supply and sends the new tokens to an account\r\n        can only be called by the contract owner\r\n\r\n        @param _to         account to receive the new amount\r\n        @param _amount     amount to increase the supply by\r\n    *\/\r\n    function issue(address _to, uint256 _amount)\r\n        public\r\n        ownerOnly\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        totalSupply = safeAdd(totalSupply, _amount);\r\n        balanceOf[_to] = safeAdd(balanceOf[_to], _amount);\r\n\r\n        Issuance(_amount);\r\n        Transfer(this, _to, _amount);\r\n    }\r\n\r\n    \/**\r\n        @dev removes tokens from an account and decreases the token supply\r\n        can only be called by the contract owner\r\n\r\n        @param _from       account to remove the amount from\r\n        @param _amount     amount to decrease the supply by\r\n    *\/\r\n    function destroy(address _from, uint256 _amount)\r\n        public\r\n        ownerOnly\r\n    {\r\n        balanceOf[_from] = safeSub(balanceOf[_from], _amount);\r\n        totalSupply = safeSub(totalSupply, _amount);\r\n\r\n        Transfer(_from, this, _amount);\r\n        Destruction(_amount);\r\n    }\r\n\r\n    \/\/ ERC20 standard method overrides with some extra functionality\r\n\r\n    \/**\r\n        @dev send coins\r\n        throws on any error rather then return a false flag to minimize user errors\r\n        note that when transferring to the smart token's address, the coins are actually destroyed\r\n\r\n        @param _to      target address\r\n        @param _value   transfer amount\r\n\r\n        @return true if the transfer was successful, false if it wasn't\r\n    *\/\r\n    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool success) {\r\n        assert(super.transfer(_to, _value));\r\n\r\n        \/\/ transferring to the contract address destroys tokens\r\n        if (_to == address(this)) {\r\n            balanceOf[_to] -= _value;\r\n            totalSupply -= _value;\r\n            Destruction(_value);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    \/**\r\n        @dev an account\/contract attempts to get the coins\r\n        throws on any error rather then return a false flag to minimize user errors\r\n        note that when transferring to the smart token's address, the coins are actually destroyed\r\n\r\n        @param _from    source address\r\n        @param _to      target address\r\n        @param _value   transfer amount\r\n\r\n        @return true if the transfer was successful, false if it wasn't\r\n    *\/\r\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool success) {\r\n        assert(super.transferFrom(_from, _to, _value));\r\n\r\n        \/\/ transferring to the contract address destroys tokens\r\n        if (_to == address(this)) {\r\n            balanceOf[_to] -= _value;\r\n            totalSupply -= _value;\r\n            Destruction(_value);\r\n        }\r\n\r\n        return true;\r\n    }\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/Bancor\/",
        "Telegram": "",
        "Website": "https:\/\/bancor.network\/",
        "Email": "https:\/\/bancor.network\/contact",
        "Twitter": "https:\/\/twitter.com\/bancornetwork"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C#code"
    }, {
      "contractId": 21,
      "title": "Monaco Token",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Monaco",
      "code": "\/*\r\n * ERC20 interface\r\n * see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n *\/\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n\r\n\/**\r\n * Math operations with safety checks\r\n *\/\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a \/ b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n\/**\r\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\r\n *\r\n * Based on code by FirstBlood:\r\n * https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\n *\/\r\ncontract StandardToken is ERC20, SafeMath {\r\n\r\n  \/* Token supply got increased and a new owner received these tokens *\/\r\n  event Minted(address receiver, uint amount);\r\n\r\n  \/* Actual balances of token holders *\/\r\n  mapping(address => uint) balances;\r\n\r\n  \/* approve() allowances *\/\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  \/* Interface declaration *\/\r\n  function isToken() public constant returns (bool weAre) {\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   *\r\n   * Fix for the ERC20 short address attack\r\n   *\r\n   * http:\/\/vessenes.com\/the-erc20-short-address-attack-explained\/\r\n   *\/\r\n  modifier onlyPayloadSize(uint size) {\r\n     if(msg.data.length < size + 4) {\r\n       throw;\r\n     }\r\n     _;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n    uint _allowance = allowed[_from][msg.sender];\r\n\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n\r\n    \/\/ To change the approve amount you first have to reduce the addresses`\r\n    \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    \/\/  already 0 to mitigate the race condition described here:\r\n    \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\/**\r\n * Upgrade agent interface inspired by Lunyr.\r\n *\r\n * Upgrade agent transfers tokens to a new contract.\r\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\r\n *\/\r\ncontract UpgradeAgent {\r\n\r\n  uint public originalSupply;\r\n\r\n  \/** Interface marker *\/\r\n  function isUpgradeAgent() public constant returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  function upgradeFrom(address _from, uint256 _value) public;\r\n\r\n}\r\n\r\n\r\n\/**\r\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\r\n *\r\n * First envisioned by Golem and Lunyr projects.\r\n *\/\r\ncontract UpgradeableToken is StandardToken {\r\n\r\n  \/** Contract \/ person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. *\/\r\n  address public upgradeMaster;\r\n\r\n  \/** The next contract where the tokens will be migrated. *\/\r\n  UpgradeAgent public upgradeAgent;\r\n\r\n  \/** How many tokens we have upgraded by now. *\/\r\n  uint256 public totalUpgraded;\r\n\r\n  \/**\r\n   * Upgrade states.\r\n   *\r\n   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\r\n   * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet\r\n   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet\r\n   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\r\n   *\r\n   *\/\r\n  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\r\n\r\n  \/**\r\n   * Somebody has upgraded some of his tokens.\r\n   *\/\r\n  event Upgrade(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n  \/**\r\n   * New upgrade agent available.\r\n   *\/\r\n  event UpgradeAgentSet(address agent);\r\n\r\n  \/**\r\n   * Do not allow construction without upgrade master set.\r\n   *\/\r\n  function UpgradeableToken(address _upgradeMaster) {\r\n    upgradeMaster = _upgradeMaster;\r\n  }\r\n\r\n  \/**\r\n   * Allow the token holder to upgrade some of their tokens to a new contract.\r\n   *\/\r\n  function upgrade(uint256 value) public {\r\n\r\n      UpgradeState state = getUpgradeState();\r\n      if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\r\n        \/\/ Called in a bad state\r\n        throw;\r\n      }\r\n\r\n      \/\/ Validate input value.\r\n      if (value == 0) throw;\r\n\r\n      balances[msg.sender] = safeSub(balances[msg.sender], value);\r\n\r\n      \/\/ Take tokens out from circulation\r\n      totalSupply = safeSub(totalSupply, value);\r\n      totalUpgraded = safeAdd(totalUpgraded, value);\r\n\r\n      \/\/ Upgrade agent reissues the tokens\r\n      upgradeAgent.upgradeFrom(msg.sender, value);\r\n      Upgrade(msg.sender, upgradeAgent, value);\r\n  }\r\n\r\n  \/**\r\n   * Set an upgrade agent that handles\r\n   *\/\r\n  function setUpgradeAgent(address agent) external {\r\n\r\n      if(!canUpgrade()) {\r\n        \/\/ The token is not yet in a state that we could think upgrading\r\n        throw;\r\n      }\r\n\r\n      if (agent == 0x0) throw;\r\n      \/\/ Only a master can designate the next agent\r\n      if (msg.sender != upgradeMaster) throw;\r\n      \/\/ Upgrade has already begun for an agent\r\n      if (getUpgradeState() == UpgradeState.Upgrading) throw;\r\n\r\n      upgradeAgent = UpgradeAgent(agent);\r\n\r\n      \/\/ Bad interface\r\n      if(!upgradeAgent.isUpgradeAgent()) throw;\r\n      \/\/ Make sure that token supplies match in source and target\r\n      if (upgradeAgent.originalSupply() != totalSupply) throw;\r\n\r\n      UpgradeAgentSet(upgradeAgent);\r\n  }\r\n\r\n  \/**\r\n   * Get the state of the token upgrade.\r\n   *\/\r\n  function getUpgradeState() public constant returns(UpgradeState) {\r\n    if(!canUpgrade()) return UpgradeState.NotAllowed;\r\n    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\r\n    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\r\n    else return UpgradeState.Upgrading;\r\n  }\r\n\r\n  \/**\r\n   * Change the upgrade master.\r\n   *\r\n   * This allows us to set a new owner for the upgrade mechanism.\r\n   *\/\r\n  function setUpgradeMaster(address master) public {\r\n      if (master == 0x0) throw;\r\n      if (msg.sender != upgradeMaster) throw;\r\n      upgradeMaster = master;\r\n  }\r\n\r\n  \/**\r\n   * Child contract can enable to provide the condition when the upgrade can begun.\r\n   *\/\r\n  function canUpgrade() public constant returns(bool) {\r\n     return true;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\/*\r\n * Ownable\r\n *\r\n * Base contract with an owner.\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\n *\/\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\/**\r\n * Define interface for releasing the token transfer after a successful crowdsale.\r\n *\/\r\ncontract ReleasableToken is ERC20, Ownable {\r\n\r\n  \/* The finalizer contract that allows unlift the transfer limits on this token *\/\r\n  address public releaseAgent;\r\n\r\n  \/** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*\/\r\n  bool public released = false;\r\n\r\n  \/** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. *\/\r\n  mapping (address => bool) public transferAgents;\r\n\r\n  \/**\r\n   * Limit token transfer until the crowdsale is over.\r\n   *\r\n   *\/\r\n  modifier canTransfer(address _sender) {\r\n\r\n    if(!released) {\r\n        if(!transferAgents[_sender]) {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * Set the contract that can call release and make the token transferable.\r\n   *\r\n   * Design choice. Allow reset the release agent to fix fat finger mistakes.\r\n   *\/\r\n  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\r\n\r\n    \/\/ We don't do interface check here as we might want to a normal wallet address to act as a release agent\r\n    releaseAgent = addr;\r\n  }\r\n\r\n  \/**\r\n   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.\r\n   *\/\r\n  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\r\n    transferAgents[addr] = state;\r\n  }\r\n\r\n  \/**\r\n   * One way function to release the tokens to the wild.\r\n   *\r\n   * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).\r\n   *\/\r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\n    released = true;\r\n  }\r\n\r\n  \/** The function can be called only before or after the tokens have been releasesd *\/\r\n  modifier inReleaseState(bool releaseState) {\r\n    if(releaseState != released) {\r\n        throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  \/** The function can be called only by a whitelisted release agent. *\/\r\n  modifier onlyReleaseAgent() {\r\n    if(msg.sender != releaseAgent) {\r\n        throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\r\n    \/\/ Call StandardToken.transfer()\r\n   return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\r\n    \/\/ Call StandardToken.transferForm()\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\/**\r\n * Safe unsigned safe math.\r\n *\r\n * https:\/\/blog.aragon.one\/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli\r\n *\r\n * Originally from https:\/\/raw.githubusercontent.com\/AragonOne\/zeppelin-solidity\/master\/contracts\/SafeMathLib.sol\r\n *\r\n * Maintained here until merged to mainline zeppelin-solidity.\r\n *\r\n *\/\r\nlibrary SafeMathLib {\r\n\r\n  function times(uint a, uint b) returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function minus(uint a, uint b) returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function plus(uint a, uint b) returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a);\r\n    return c;\r\n  }\r\n\r\n  function assert(bool assertion) private {\r\n    if (!assertion) throw;\r\n  }\r\n}\r\n\r\n\r\n\r\n\/**\r\n * A token that can increase its supply by another contract.\r\n *\r\n * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\r\n * Only mint agents, contracts whitelisted by owner, can mint new tokens.\r\n *\r\n *\/\r\ncontract MintableToken is StandardToken, Ownable {\r\n\r\n  using SafeMathLib for uint;\r\n\r\n  bool public mintingFinished = false;\r\n\r\n  \/** List of agents that are allowed to create new tokens *\/\r\n  mapping (address => bool) public mintAgents;\r\n\r\n  event MintingAgentChanged(address addr, bool state  );\r\n\r\n  \/**\r\n   * Create new tokens and allocate them to an address..\r\n   *\r\n   * Only callably by a crowdsale contract (mint agent).\r\n   *\/\r\n  function mint(address receiver, uint amount) onlyMintAgent canMint public {\r\n    totalSupply = totalSupply.plus(amount);\r\n    balances[receiver] = balances[receiver].plus(amount);\r\n\r\n    \/\/ This will make the mint transaction apper in EtherScan.io\r\n    \/\/ We can remove this after there is a standardized minting event\r\n    Transfer(0, receiver, amount);\r\n  }\r\n\r\n  \/**\r\n   * Owner can allow a crowdsale contract to mint new tokens.\r\n   *\/\r\n  function setMintAgent(address addr, bool state) onlyOwner canMint public {\r\n    mintAgents[addr] = state;\r\n    MintingAgentChanged(addr, state);\r\n  }\r\n\r\n  modifier onlyMintAgent() {\r\n    \/\/ Only crowdsale contracts are allowed to mint new tokens\r\n    if(!mintAgents[msg.sender]) {\r\n        throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  \/** Make sure we are not done yet. *\/\r\n  modifier canMint() {\r\n    if(mintingFinished) throw;\r\n    _;\r\n  }\r\n}\r\n\r\n\r\n\r\n\/**\r\n * A crowdsaled token.\r\n *\r\n * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\r\n *\r\n * - The token transfer() is disabled until the crowdsale is over\r\n * - The token contract gives an opt-in upgrade path to a new contract\r\n * - The same token can be part of several crowdsales through approve() mechanism\r\n * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\r\n *\r\n *\/\r\ncontract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken {\r\n\r\n  event UpdatedTokenInformation(string newName, string newSymbol);\r\n\r\n  string public name;\r\n\r\n  string public symbol;\r\n\r\n  uint public decimals;\r\n\r\n  \/**\r\n   * Construct the token.\r\n   *\r\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\r\n   *\r\n   * @param _name Token name\r\n   * @param _symbol Token symbol - should be all caps\r\n   * @param _initialSupply How many tokens we start with\r\n   * @param _decimals Number of decimal places\r\n   * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.\r\n   *\/\r\n  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)\r\n    UpgradeableToken(msg.sender) {\r\n\r\n    \/\/ Create any address, can be transferred\r\n    \/\/ to team multisig via changeOwner(),\r\n    \/\/ also remember to call setUpgradeMaster()\r\n    owner = msg.sender;\r\n\r\n    name = _name;\r\n    symbol = _symbol;\r\n\r\n    totalSupply = _initialSupply;\r\n\r\n    decimals = _decimals;\r\n\r\n    \/\/ Create initially all balance on the team multisig\r\n    balances[owner] = totalSupply;\r\n\r\n    if(totalSupply > 0) {\r\n      Minted(owner, totalSupply);\r\n    }\r\n\r\n    \/\/ No more new supply allowed after the token creation\r\n    if(!_mintable) {\r\n      mintingFinished = true;\r\n      if(totalSupply == 0) {\r\n        throw; \/\/ Cannot create a token without supply and no minting\r\n      }\r\n    }\r\n  }\r\n\r\n  \/**\r\n   * When token is released to be transferable, enforce no new tokens can be created.\r\n   *\/\r\n  function releaseTokenTransfer() public onlyReleaseAgent {\r\n    mintingFinished = true;\r\n    super.releaseTokenTransfer();\r\n  }\r\n\r\n  \/**\r\n   * Allow upgrade agent functionality kick in only if the crowdsale was success.\r\n   *\/\r\n  function canUpgrade() public constant returns(bool) {\r\n    return released && super.canUpgrade();\r\n  }\r\n\r\n  \/**\r\n   * Owner can update token information here\r\n   *\/\r\n  function setTokenInformation(string _name, string _symbol) onlyOwner {\r\n    name = _name;\r\n    symbol = _symbol;\r\n\r\n    UpdatedTokenInformation(name, symbol);\r\n  }\r\n\r\n}",
      "officialLinks": {
        "Reddit": "",
        "Telegram": "https:\/\/t.me\/MonacoCard",
        "Website": "http:\/\/www.mona.co",
        "Email": "",
        "Twitter": "https:\/\/twitter.com\/monaco_card"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xb63b606ac810a52cca15e44bb630fd42d8d1d83d#code"
    }, {
      "contractId": 22,
      "title": "QuantstampToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Quantstamp",
      "code": "pragma solidity ^0.4.15;\r\n\r\n\r\n\/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n *\/\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\n    uint256 c = a \/ b;\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n *\/\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  \/**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   *\/\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  \/**\r\n   * @dev Throws if called by any account other than the owner.\r\n   *\/\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  \/**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   *\/\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n *\/\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  \/**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   *\/\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   *\/\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   *\/\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  \/**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   *\/\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n\r\n\r\n\/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/179\r\n *\/\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\/**\r\n * @title ERC20 interface\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n *\/\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n *\/\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n\r\n\r\n  \/**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  *\/\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    \/\/ SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  *\/\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n * @dev Based on code by FirstBlood: https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\n *\/\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\r\n  \/**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   *\/\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n\r\n    uint256 _allowance = allowed[_from][msg.sender];\r\n\r\n    \/\/ Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\r\n    \/\/ require (_value <= _allowance);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = _allowance.sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   *\/\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   *\/\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  \/**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   *\/\r\n  function increaseApproval (address _spender, uint _addedValue)\r\n    returns (bool success) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval (address _spender, uint _subtractedValue)\r\n    returns (bool success) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n *\/\r\ncontract BurnableToken is StandardToken {\r\n\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n    \/**\r\n     * @dev Burns a specific amount of tokens.\r\n     * @param _value The amount of token to be burned.\r\n     *\/\r\n    function burn(uint256 _value) public {\r\n        require(_value > 0);\r\n\r\n        address burner = msg.sender;\r\n        balances[burner] = balances[burner].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        Burn(burner, _value);\r\n    }\r\n}\r\n\r\n\/\/ Quantstamp Technologies Inc. ([email\u00a0protected])\r\n\r\n\r\n\r\n\/**\r\n * The Quantstamp token (QSP) has a fixed supply and restricts the ability\r\n * to transfer tokens until the owner has called the enableTransfer()\r\n * function.\r\n *\r\n * The owner can associate the token with a token sale contract. In that\r\n * case, the token balance is moved to the token sale contract, which\r\n * in turn can transfer its tokens to contributors to the sale.\r\n *\/\r\ncontract QuantstampToken is StandardToken, BurnableToken, Ownable {\r\n\r\n    \/\/ Constants\r\n    string  public constant name = \"Quantstamp Token\";\r\n    string  public constant symbol = \"QSP\";\r\n    uint8   public constant decimals = 18;\r\n    uint256 public constant INITIAL_SUPPLY      = 1000000000 * (10 ** uint256(decimals));\r\n    uint256 public constant CROWDSALE_ALLOWANCE =  650000000 * (10 ** uint256(decimals));\r\n    uint256 public constant ADMIN_ALLOWANCE     =  350000000 * (10 ** uint256(decimals));\r\n\r\n    \/\/ Properties\r\n    uint256 public crowdSaleAllowance;      \/\/ the number of tokens available for crowdsales\r\n    uint256 public adminAllowance;          \/\/ the number of tokens available for the administrator\r\n    address public crowdSaleAddr;           \/\/ the address of a crowdsale currently selling this token\r\n    address public adminAddr;               \/\/ the address of the token admin account\r\n    bool    public transferEnabled = false; \/\/ indicates if transferring tokens is enabled or not\r\n\r\n    \/\/ Modifiers\r\n    modifier onlyWhenTransferEnabled() {\r\n        if (!transferEnabled) {\r\n            require(msg.sender == adminAddr || msg.sender == crowdSaleAddr);\r\n        }\r\n        _;\r\n    }\r\n\r\n    \/**\r\n     * The listed addresses are not valid recipients of tokens.\r\n     *\r\n     * 0x0           - the zero address is not valid\r\n     * this          - the contract itself should not receive tokens\r\n     * owner         - the owner has all the initial tokens, but cannot receive any back\r\n     * adminAddr     - the admin has an allowance of tokens to transfer, but does not receive any\r\n     * crowdSaleAddr - the crowdsale has an allowance of tokens to transfer, but does not receive any\r\n     *\/\r\n    modifier validDestination(address _to) {\r\n        require(_to != address(0x0));\r\n        require(_to != address(this));\r\n        require(_to != owner);\r\n        require(_to != address(adminAddr));\r\n        require(_to != address(crowdSaleAddr));\r\n        _;\r\n    }\r\n\r\n    \/**\r\n     * Constructor - instantiates token supply and allocates balanace of\r\n     * to the owner (msg.sender).\r\n     *\/\r\n    function QuantstampToken(address _admin) {\r\n        \/\/ the owner is a custodian of tokens that can\r\n        \/\/ give an allowance of tokens for crowdsales\r\n        \/\/ or to the admin, but cannot itself transfer\r\n        \/\/ tokens; hence, this requirement\r\n        require(msg.sender != _admin);\r\n\r\n        totalSupply = INITIAL_SUPPLY;\r\n        crowdSaleAllowance = CROWDSALE_ALLOWANCE;\r\n        adminAllowance = ADMIN_ALLOWANCE;\r\n\r\n        \/\/ mint all tokens\r\n        balances[msg.sender] = totalSupply;\r\n        Transfer(address(0x0), msg.sender, totalSupply);\r\n\r\n        adminAddr = _admin;\r\n        approve(adminAddr, adminAllowance);\r\n    }\r\n\r\n    \/**\r\n     * Associates this token with a current crowdsale, giving the crowdsale\r\n     * an allowance of tokens from the crowdsale supply. This gives the\r\n     * crowdsale the ability to call transferFrom to transfer tokens to\r\n     * whomever has purchased them.\r\n     *\r\n     * Note that if _amountForSale is 0, then it is assumed that the full\r\n     * remaining crowdsale supply is made available to the crowdsale.\r\n     *\r\n     * @param _crowdSaleAddr The address of a crowdsale contract that will sell this token\r\n     * @param _amountForSale The supply of tokens provided to the crowdsale\r\n     *\/\r\n    function setCrowdsale(address _crowdSaleAddr, uint256 _amountForSale) external onlyOwner {\r\n        require(!transferEnabled);\r\n        require(_amountForSale <= crowdSaleAllowance);\r\n\r\n        \/\/ if 0, then full available crowdsale supply is assumed\r\n        uint amount = (_amountForSale == 0) ? crowdSaleAllowance : _amountForSale;\r\n\r\n        \/\/ Clear allowance of old, and set allowance of new\r\n        approve(crowdSaleAddr, 0);\r\n        approve(_crowdSaleAddr, amount);\r\n\r\n        crowdSaleAddr = _crowdSaleAddr;\r\n    }\r\n\r\n    \/**\r\n     * Enables the ability of anyone to transfer their tokens. This can\r\n     * only be called by the token owner. Once enabled, it is not\r\n     * possible to disable transfers.\r\n     *\/\r\n    function enableTransfer() external onlyOwner {\r\n        transferEnabled = true;\r\n        approve(crowdSaleAddr, 0);\r\n        approve(adminAddr, 0);\r\n        crowdSaleAllowance = 0;\r\n        adminAllowance = 0;\r\n    }\r\n\r\n    \/**\r\n     * Overrides ERC20 transfer function with modifier that prevents the\r\n     * ability to transfer tokens until after transfers have been enabled.\r\n     *\/\r\n    function transfer(address _to, uint256 _value) public onlyWhenTransferEnabled validDestination(_to) returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    \/**\r\n     * Overrides ERC20 transferFrom function with modifier that prevents the\r\n     * ability to transfer tokens until after transfers have been enabled.\r\n     *\/\r\n    function transferFrom(address _from, address _to, uint256 _value) public onlyWhenTransferEnabled validDestination(_to) returns (bool) {\r\n        bool result = super.transferFrom(_from, _to, _value);\r\n        if (result) {\r\n            if (msg.sender == crowdSaleAddr)\r\n                crowdSaleAllowance = crowdSaleAllowance.sub(_value);\r\n            if (msg.sender == adminAddr)\r\n                adminAllowance = adminAllowance.sub(_value);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    \/**\r\n     * Overrides the burn function so that it cannot be called until after\r\n     * transfers have been enabled.\r\n     *\r\n     * @param _value    The amount of tokens to burn in mini-QSP\r\n     *\/\r\n    function burn(uint256 _value) public {\r\n        require(transferEnabled || msg.sender == owner);\r\n        require(balances[msg.sender] >= _value);\r\n        super.burn(_value);\r\n        Transfer(msg.sender, address(0x0), _value);\r\n    }\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/Quantstamp\/",
        "Telegram": "https:\/\/t.me\/quantstamp",
        "Website": "https:\/\/quantstamp.com\/",
        "Email": "",
        "Twitter": "https:\/\/twitter.com\/Quantstamp"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x99ea4db9ee77acd40b119bd1dc4e33e1c070b80d#code"
    }, {
      "contractId": 23,
      "title": "GnosisToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Gnosis",
      "code": "pragma solidity 0.4.10;\r\n\r\n\r\n\/\/\/ @title Abstract token contract - Functions to be implemented by token contracts.\r\ncontract Token {\r\n    function transfer(address to, uint256 value) returns (bool success);\r\n    function transferFrom(address from, address to, uint256 value) returns (bool success);\r\n    function approve(address spender, uint256 value) returns (bool success);\r\n\r\n    \/\/ This is not an abstract function, because solc won't recognize generated getter functions for public variables as functions.\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n    function balanceOf(address owner) constant returns (uint256 balance);\r\n    function allowance(address owner, address spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\/\/\/ @title Standard token contract - Standard token interface implementation.\r\ncontract StandardToken is Token {\r\n\r\n    \/*\r\n     *  Data structures\r\n     *\/\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n\r\n    \/*\r\n     *  Public functions\r\n     *\/\r\n    \/\/\/ @dev Transfers sender's tokens to a given address. Returns success.\r\n    \/\/\/ @param _to Address of token receiver.\r\n    \/\/\/ @param _value Number of tokens to transfer.\r\n    \/\/\/ @return Returns success of function call.\r\n    function transfer(address _to, uint256 _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        if (balances[msg.sender] < _value) {\r\n            \/\/ Balance too low\r\n            throw;\r\n        }\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    \/\/\/ @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\r\n    \/\/\/ @param _from Address from where tokens are withdrawn.\r\n    \/\/\/ @param _to Address to where tokens are sent.\r\n    \/\/\/ @param _value Number of tokens to transfer.\r\n    \/\/\/ @return Returns success of function call.\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        if (balances[_from] < _value || allowed[_from][msg.sender] < _value) {\r\n            \/\/ Balance or allowance too low\r\n            throw;\r\n        }\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    \/\/\/ @dev Sets approved amount of tokens for spender. Returns success.\r\n    \/\/\/ @param _spender Address of allowed account.\r\n    \/\/\/ @param _value Number of approved tokens.\r\n    \/\/\/ @return Returns success of function call.\r\n    function approve(address _spender, uint256 _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    \/*\r\n     * Read functions\r\n     *\/\r\n    \/\/\/ @dev Returns number of allowed tokens for given address.\r\n    \/\/\/ @param _owner Address of token owner.\r\n    \/\/\/ @param _spender Address of token spender.\r\n    \/\/\/ @return Returns remaining allowance for spender.\r\n    function allowance(address _owner, address _spender)\r\n        constant\r\n        public\r\n        returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    \/\/\/ @dev Returns number of tokens owned by given address.\r\n    \/\/\/ @param _owner Address of token owner.\r\n    \/\/\/ @return Returns balance of owner.\r\n    function balanceOf(address _owner)\r\n        constant\r\n        public\r\n        returns (uint256)\r\n    {\r\n        return balances[_owner];\r\n    }\r\n}\r\n\r\n\r\n\/\/\/ @title Gnosis token contract\r\n\/\/\/ @author Stefan George - <[email\u00a0protected]>\r\ncontract GnosisToken is StandardToken {\r\n\r\n    \/*\r\n     *  Token meta data\r\n     *\/\r\n    string constant public name = \"Gnosis Token\";\r\n    string constant public symbol = \"GNO\";\r\n    uint8 constant public decimals = 18;\r\n\r\n    \/*\r\n     *  Public functions\r\n     *\/\r\n    \/\/\/ @dev Contract constructor function sets dutch auction contract address and assigns all tokens to dutch auction.\r\n    \/\/\/ @param dutchAuction Address of dutch auction contract.\r\n    \/\/\/ @param owners Array of addresses receiving preassigned tokens.\r\n    \/\/\/ @param tokens Array of preassigned token amounts.\r\n    function GnosisToken(address dutchAuction, address[] owners, uint[] tokens)\r\n        public\r\n    {\r\n        if (dutchAuction == 0)\r\n            \/\/ Address should not be null.\r\n            throw;\r\n        totalSupply = 10000000 * 10**18;\r\n        balances[dutchAuction] = 9000000 * 10**18;\r\n        Transfer(0, dutchAuction, balances[dutchAuction]);\r\n        uint assignedTokens = balances[dutchAuction];\r\n        for (uint i=0; i<owners.length; i++) {\r\n            if (owners[i] == 0)\r\n                \/\/ Address should not be null.\r\n                throw;\r\n            balances[owners[i]] += tokens[i];\r\n            Transfer(0, owners[i], tokens[i]);\r\n            assignedTokens += tokens[i];\r\n        }\r\n        if (assignedTokens != totalSupply)\r\n            throw;\r\n    }\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/gnosisPM\/",
        "Telegram": "",
        "Website": "https:\/\/gnosis.pm\/",
        "Email": "",
        "Twitter": "https:\/\/twitter.com\/gnosisPM"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x6810e776880c02933d47db1b9fc05908e5386b96#code"
    }, {
      "contractId": 24,
      "title": "BNB",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "BNB",
      "code": "pragma solidity ^0.4.8;\r\n\r\n\/**\r\n * Math operations with safety checks\r\n *\/\r\ncontract SafeMath {\r\n  function safeMul(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint256 a, uint256 b) internal returns (uint256) {\r\n    assert(b > 0);\r\n    uint256 c = a \/ b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint256 a, uint256 b) internal returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\ncontract BNB is SafeMath{\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n\taddress public owner;\r\n\r\n    \/* This creates an array with all balances *\/\r\n    mapping (address => uint256) public balanceOf;\r\n\tmapping (address => uint256) public freezeOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    \/* This generates a public event on the blockchain that will notify clients *\/\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    \/* This notifies clients about the amount burnt *\/\r\n    event Burn(address indexed from, uint256 value);\r\n\t\r\n\t\/* This notifies clients about the amount frozen *\/\r\n    event Freeze(address indexed from, uint256 value);\r\n\t\r\n\t\/* This notifies clients about the amount unfrozen *\/\r\n    event Unfreeze(address indexed from, uint256 value);\r\n\r\n    \/* Initializes contract with initial supply tokens to the creator of the contract *\/\r\n    function BNB(\r\n        uint256 initialSupply,\r\n        string tokenName,\r\n        uint8 decimalUnits,\r\n        string tokenSymbol\r\n        ) {\r\n        balanceOf[msg.sender] = initialSupply;              \/\/ Give the creator all initial tokens\r\n        totalSupply = initialSupply;                        \/\/ Update total supply\r\n        name = tokenName;                                   \/\/ Set the name for display purposes\r\n        symbol = tokenSymbol;                               \/\/ Set the symbol for display purposes\r\n        decimals = decimalUnits;                            \/\/ Amount of decimals for display purposes\r\n\t\towner = msg.sender;\r\n    }\r\n\r\n    \/* Send coins *\/\r\n    function transfer(address _to, uint256 _value) {\r\n        if (_to == 0x0) throw;                               \/\/ Prevent transfer to 0x0 address. Use burn() instead\r\n\t\tif (_value <= 0) throw; \r\n        if (balanceOf[msg.sender] < _value) throw;           \/\/ Check if the sender has enough\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; \/\/ Check for overflows\r\n        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                     \/\/ Subtract from the sender\r\n        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            \/\/ Add the same to the recipient\r\n        Transfer(msg.sender, _to, _value);                   \/\/ Notify anyone listening that this transfer took place\r\n    }\r\n\r\n    \/* Allow another contract to spend some tokens in your behalf *\/\r\n    function approve(address _spender, uint256 _value)\r\n        returns (bool success) {\r\n\t\tif (_value <= 0) throw; \r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n       \r\n\r\n    \/* A contract attempts to get the coins *\/\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (_to == 0x0) throw;                                \/\/ Prevent transfer to 0x0 address. Use burn() instead\r\n\t\tif (_value <= 0) throw; \r\n        if (balanceOf[_from] < _value) throw;                 \/\/ Check if the sender has enough\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  \/\/ Check for overflows\r\n        if (_value > allowance[_from][msg.sender]) throw;     \/\/ Check allowance\r\n        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           \/\/ Subtract from the sender\r\n        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             \/\/ Add the same to the recipient\r\n        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function burn(uint256 _value) returns (bool success) {\r\n        if (balanceOf[msg.sender] < _value) throw;            \/\/ Check if the sender has enough\r\n\t\tif (_value <= 0) throw; \r\n        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      \/\/ Subtract from the sender\r\n        totalSupply = SafeMath.safeSub(totalSupply,_value);                                \/\/ Updates totalSupply\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\t\r\n\tfunction freeze(uint256 _value) returns (bool success) {\r\n        if (balanceOf[msg.sender] < _value) throw;            \/\/ Check if the sender has enough\r\n\t\tif (_value <= 0) throw; \r\n        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      \/\/ Subtract from the sender\r\n        freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value);                                \/\/ Updates totalSupply\r\n        Freeze(msg.sender, _value);\r\n        return true;\r\n    }\r\n\t\r\n\tfunction unfreeze(uint256 _value) returns (bool success) {\r\n        if (freezeOf[msg.sender] < _value) throw;            \/\/ Check if the sender has enough\r\n\t\tif (_value <= 0) throw; \r\n        freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value);                      \/\/ Subtract from the sender\r\n\t\tbalanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value);\r\n        Unfreeze(msg.sender, _value);\r\n        return true;\r\n    }\r\n\t\r\n\t\/\/ transfer balance to owner\r\n\tfunction withdrawEther(uint256 amount) {\r\n\t\tif(msg.sender != owner)throw;\r\n\t\towner.transfer(amount);\r\n\t}\r\n\t\r\n\t\/\/ can accept ether\r\n\tfunction() payable {\r\n    }\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/binance\/",
        "Telegram": "",
        "Website": "https:\/\/www.binance.com\/",
        "Email": "mailto:support@binance.zendesk.com",
        "Twitter": "https:\/\/twitter.com\/binance_2017"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xB8c77482e45F1F44dE1745F52C74426C631bDD52#code"
    }, {
      "contractId": 25,
      "title": "WINGS Token",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "WINGS",
      "code": "contract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    if (msg.sender == owner)\r\n      _;\r\n  }\r\n\r\n  function transferOwner(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) throw;\r\n  }\r\n}\r\n\r\ncontract StandardToken is ERC20, SafeMath {\r\n\r\n  mapping(address => uint) balances;\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  function transfer(address _to, uint _value) returns (bool success) {\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n    \r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n\/*\r\n  Wings ERC20 Token.\r\n  Added allocation for users who participiated in Wings Campaign.\r\n\r\n  Important!\r\n  We have to run pre-mine allocation first.\r\n  And only then rest of users.\r\n  Or it's not going to work due to whenAllocation logic.\r\n*\/\r\ncontract Token is StandardToken, Ownable {\r\n  \/\/ Account allocation event\r\n  event ALLOCATION(address indexed account, uint amount);\r\n\r\n  \/*\r\n    Premine events\r\n  *\/\r\n  event PREMINER_ADDED(address indexed owner, address account, uint amount);\r\n  event PREMINE_ALLOCATION_ADDED(address indexed account, uint time);\r\n  event PREMINE_RELEASE(address indexed account, uint timestamp, uint amount);\r\n  event PREMINER_CHANGED(address indexed oldPreminer, address newPreminer, address newRecipient);\r\n\r\n  \/*\r\n    Premine structure\r\n  *\/\r\n  struct Preminer {\r\n    address account;\r\n    uint monthlyPayment;\r\n    uint latestAllocation;\r\n    bool disabled;\r\n\r\n    uint allocationsCount;\r\n    mapping(uint => uint) allocations;\r\n  }\r\n\r\n  \/*\r\n    List of preminers\r\n  *\/\r\n  mapping(address => Preminer) preminers;\r\n\r\n  \/*\r\n    Token Name & Token Symbol & Decimals\r\n  *\/\r\n  string public name = \"WINGS\";\r\n  string public symbol = \"WINGS\";\r\n  uint public decimals = 18;\r\n\r\n  \/*\r\n    Total supply\r\n  *\/\r\n  uint public totalSupply = 10**26;\/\/100000000000000000000000000;\r\n\r\n  \/*\r\n    Premine allocation interval\r\n  *\/\r\n  uint public DAYS_28 = 2419200;\r\n  uint public DAYS_31 = 2678400;\r\n\r\n  \/*\r\n    Maximum premine allocations count\r\n  *\/\r\n  uint public MAX_ALLOCATIONS_COUNT = 26;\r\n\r\n  \/*\r\n    How many accounts allocated?\r\n  *\/\r\n  uint public accountsToAllocate;\r\n\r\n  \/*\r\n    Multisignature\r\n  *\/\r\n  address public multisignature;\r\n\r\n  \/*\r\n    Only multisignature\r\n  *\/\r\n  modifier onlyMultisignature() {\r\n    if (msg.sender != multisignature) {\r\n      throw;\r\n    }\r\n\r\n    _;\r\n  }\r\n\r\n  \/*\r\n    When preminer is not disabled\r\n  *\/\r\n  modifier whenPreminerIsntDisabled(address _account) {\r\n    if (preminers[_account].disabled == true) {\r\n      throw;\r\n    }\r\n\r\n    _;\r\n  }\r\n\r\n  \/*\r\n    Modifier for checking is allocation completed.\r\n    Maybe we should add here pre-mine accounts too.\r\n  *\/\r\n  modifier whenAllocation(bool value) {\r\n    if ((accountsToAllocate > 0) == value) {\r\n      _;\r\n    } else {\r\n      throw;\r\n    }\r\n  }\r\n\r\n  \/*\r\n    Check if user already allocated\r\n  *\/\r\n  modifier whenAccountHasntAllocated(address user) {\r\n    if (balances[user] == 0) {\r\n      _;\r\n    } else {\r\n      throw;\r\n    }\r\n  }\r\n\r\n  \/*\r\n    Check if preminer already added\r\n  *\/\r\n  modifier whenPremineHasntAllocated(address preminer) {\r\n    if (preminers[preminer].account == address(0)) {\r\n      _;\r\n    } else {\r\n      throw;\r\n    }\r\n  }\r\n\r\n  function Token(uint _accountsToAllocate, address _multisignature) {\r\n    \/*\r\n      Maybe we should calculate it in allocation and pre-mine.\r\n      I mean total supply\r\n    *\/\r\n    owner = msg.sender;\r\n    accountsToAllocate = _accountsToAllocate;\r\n    multisignature = _multisignature;\r\n  }\r\n\r\n  \/*\r\n    Allocate tokens for users.\r\n    Only owner and only while allocation active.\r\n\r\n    Should check if user allocated already (no double allocations)\r\n  *\/\r\n  function allocate(address user, uint balance) onlyOwner() whenAllocation(true) whenAccountHasntAllocated(user) {\r\n    balances[user] = balance;\r\n\r\n    accountsToAllocate--;\r\n    ALLOCATION(user, balance);\r\n  }\r\n\r\n  \/*\r\n    Standard Token functional\r\n  *\/\r\n  function transfer(address _to, uint _value) whenAllocation(false) returns (bool success) {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) whenAllocation(false) returns (bool success) {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n  function approve(address _spender, uint _value) whenAllocation(false) returns (bool success) {\r\n    return super.approve(_spender, _value);\r\n  }\r\n\r\n  \/*\r\n    Premine functionality\r\n  *\/\r\n\r\n  \/*\r\n    Add pre-mine account\r\n  *\/\r\n  function addPreminer(address preminer, address recipient, uint initialBalance, uint monthlyPayment) onlyOwner() whenAllocation(true) whenPremineHasntAllocated(preminer) {\r\n    var premine = Preminer(\r\n        recipient,\r\n        monthlyPayment,\r\n        0,\r\n        false,\r\n        0\r\n      );\r\n\r\n\r\n    balances[recipient] = safeAdd(balances[recipient], initialBalance);\r\n    preminers[preminer] = premine;\r\n    accountsToAllocate--;\r\n    PREMINER_ADDED(preminer, premine.account, initialBalance);\r\n  }\r\n\r\n  \/*\r\n    Disable pre-miner\r\n  *\/\r\n  function disablePreminer(address _preminer, address _newPreminer, address _newRecipient) onlyMultisignature() whenPreminerIsntDisabled(_preminer) {\r\n    var oldPreminer = preminers[_preminer];\r\n\r\n    if (oldPreminer.account == address(0) || preminers[_newPreminer].account != address(0)) {\r\n      throw;\r\n    }\r\n\r\n    preminers[_newPreminer] = oldPreminer;\r\n    preminers[_newPreminer].account = _newRecipient;\r\n    oldPreminer.disabled = true;\r\n\r\n    if(preminers[_newPreminer].disabled == true) {\r\n      throw;\r\n    }\r\n\r\n    for (uint i = 0; i < preminers[_newPreminer].allocationsCount; i++) {\r\n      preminers[_newPreminer].allocations[i] = oldPreminer.allocations[i];\r\n    }\r\n\r\n    PREMINER_CHANGED(_preminer, _newPreminer, _newRecipient);\r\n  }\r\n\r\n  \/*\r\n    Add pre-mine allocation\r\n  *\/\r\n  function addPremineAllocation(address _preminer, uint _time) onlyOwner() whenAllocation(true) whenPreminerIsntDisabled(_preminer) {\r\n    var preminer = preminers[_preminer];\r\n\r\n    if (preminer.account == address(0) ||  _time == 0 || preminer.allocationsCount == MAX_ALLOCATIONS_COUNT) {\r\n      throw;\r\n    }\r\n\r\n    if (preminer.allocationsCount > 0) {\r\n      var previousAllocation = preminer.allocations[preminer.allocationsCount-1];\r\n\r\n      if (previousAllocation > _time) {\r\n        throw;\r\n      }\r\n\r\n      if (previousAllocation + DAYS_28 > _time) {\r\n        throw;\r\n      }\r\n\r\n      if (previousAllocation + DAYS_31 < _time) {\r\n        throw;\r\n      }\r\n    }\r\n\r\n    preminer.allocations[preminer.allocationsCount++] = _time;\r\n    PREMINE_ALLOCATION_ADDED(_preminer, _time);\r\n  }\r\n\r\n  \/*\r\n    Get preminer\r\n  *\/\r\n  function getPreminer(address _preminer) constant returns (address, bool, uint, uint, uint) {\r\n    var preminer = preminers[_preminer];\r\n\r\n    return (preminer.account, preminer.disabled, preminer.monthlyPayment, preminer.latestAllocation, preminer.allocationsCount);\r\n  }\r\n\r\n  \/*\r\n    Get preminer allocation time by index\r\n  *\/\r\n  function getPreminerAllocation(address _preminer, uint _index) constant returns (uint) {\r\n    return preminers[_preminer].allocations[_index];\r\n  }\r\n\r\n  \/*\r\n    Release premine when preminer asking\r\n    Gas usage: 0x5786 or 22406 GAS.\r\n    Maximum is 26 months of pre-mine in case of Wings. So should be enough to execute it.\r\n  *\/\r\n  function releasePremine() whenAllocation(false) whenPreminerIsntDisabled(msg.sender) {\r\n    var preminer = preminers[msg.sender];\r\n\r\n    if (preminer.account == address(0)) {\r\n      throw;\r\n    }\r\n\r\n    for (uint i = preminer.latestAllocation; i < preminer.allocationsCount; i++) {\r\n      if (preminer.allocations[i] < block.timestamp) {\r\n        if (preminer.allocations[i] == 0) {\r\n          continue;\r\n        }\r\n\r\n        balances[preminer.account] = safeAdd(balances[preminer.account], preminer.monthlyPayment);\r\n        preminer.latestAllocation = i;\r\n\r\n        PREMINE_RELEASE(preminer.account, preminer.allocations[i], preminer.monthlyPayment);\r\n        preminer.allocations[i] = 0;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/reddit.com\/r\/WingsDAO\/",
        "Telegram": "https:\/\/telegram.me\/wingschat",
        "Website": "https:\/\/wings.ai\/",
        "Email": "mailto:domi@wings.ai",
        "Twitter": "https:\/\/twitter.com\/wingsplatform"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x667088b212ce3d06a1b553a7221e1fd19000d9af#code"
    }, {
      "contractId": 26,
      "title": "EdgelessToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": " Edgeless",
      "code": "\/**\r\n * The Edgeless token contract complies with the ERC20 standard (see https:\/\/github.com\/ethereum\/EIPs\/issues\/20).\r\n * Additionally tokens can be locked for a defined time interval by token holders.\r\n * The owner's share of tokens is locked for the first year and all tokens not\r\n * being sold during the crowdsale but 60.000.000 (owner's share + bounty program) are burned.\r\n * Author: Julia Altenried\r\n * *\/\r\n\r\npragma solidity ^0.4.6;\r\n\r\ncontract SafeMath {\r\n  \/\/internals\r\n\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) throw;\r\n  }\r\n}\r\n\r\ncontract EdgelessToken is SafeMath {\r\n    \/* Public variables of the token *\/\r\n    string public standard = 'ERC20';\r\n    string public name = 'Edgeless';\r\n    string public symbol = 'EDG';\r\n    uint8 public decimals = 0;\r\n    uint256 public totalSupply;\r\n    address public owner;\r\n    \/* from this time on tokens may be transfered (after ICO)*\/\r\n    uint256 public startTime = 1490112000;\r\n    \/* tells if tokens have been burned already *\/\r\n    bool burned;\r\n\r\n    \/* This creates an array with all balances *\/\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n\r\n    \/* This generates a public event on the blockchain that will notify clients *\/\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\tevent Burned(uint amount);\r\n\r\n    \/* Initializes contract with initial supply tokens to the creator of the contract *\/\r\n    function EdgelessToken() {\r\n        owner = 0x003230BBE64eccD66f62913679C8966Cf9F41166;\r\n        balanceOf[owner] = 500000000;              \/\/ Give the owner all initial tokens\r\n        totalSupply = 500000000;                   \/\/ Update total supply\r\n    }\r\n\r\n    \/* Send some of your tokens to a given address *\/\r\n    function transfer(address _to, uint256 _value) returns (bool success){\r\n        if (now < startTime) throw; \/\/check if the crowdsale is already over\r\n        if(msg.sender == owner && now < startTime + 1 years && safeSub(balanceOf[msg.sender],_value) < 50000000) throw; \/\/prevent the owner of spending his share of tokens within the first year\r\n        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender],_value);                     \/\/ Subtract from the sender\r\n        balanceOf[_to] = safeAdd(balanceOf[_to],_value);                            \/\/ Add the same to the recipient\r\n        Transfer(msg.sender, _to, _value);                   \/\/ Notify anyone listening that this transfer took place\r\n        return true;\r\n    }\r\n\r\n    \/* Allow another contract or person to spend some tokens in your behalf *\/\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    \/* A contract or  person attempts to get the tokens of somebody else.\r\n    *  This is only allowed if the token holder approved. *\/\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (now < startTime && _from!=owner) throw; \/\/check if the crowdsale is already over\r\n        if(_from == owner && now < startTime + 1 years && safeSub(balanceOf[_from],_value) < 50000000) throw; \/\/prevent the owner of spending his share of tokens within the first year\r\n        var _allowance = allowance[_from][msg.sender];\r\n        balanceOf[_from] = safeSub(balanceOf[_from],_value); \/\/ Subtract from the sender\r\n        balanceOf[_to] = safeAdd(balanceOf[_to],_value);     \/\/ Add the same to the recipient\r\n        allowance[_from][msg.sender] = safeSub(_allowance,_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    \/* to be called when ICO is closed, burns the remaining tokens but the owners share (50 000 000) and the ones reserved\r\n    *  for the bounty program (10 000 000).\r\n    *  anybody may burn the tokens after ICO ended, but only once (in case the owner holds more tokens in the future).\r\n    *  this ensures that the owner will not posses a majority of the tokens. *\/\r\n    function burn(){\r\n    \t\/\/if tokens have not been burned already and the ICO ended\r\n    \tif(!burned && now>startTime){\r\n    \t\tuint difference = safeSub(balanceOf[owner], 60000000);\/\/checked for overflow above\r\n    \t\tbalanceOf[owner] = 60000000;\r\n    \t\ttotalSupply = safeSub(totalSupply, difference);\r\n    \t\tburned = true;\r\n    \t\tBurned(difference);\r\n    \t}\r\n    }\r\n\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/Edgeless\/",
        "Telegram": "https:\/\/t.me\/joinchat\/AAAAAEBTy7K9KXQcQsyozQ",
        "Website": "https:\/\/edgeless.io\/",
        "Email": "mailto:support@edgeless.io",
        "Twitter": "https:\/\/twitter.com\/edgelessproject"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x08711d3b02c8758f2fb3ab4e80228418a7f8e39c#code"
    }, {
      "contractId": 27,
      "title": "FirstBloodToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "FirstBlood",
      "code": "\/**\r\n * Overflow aware uint math functions.\r\n *\r\n * Inspired by https:\/\/github.com\/MakerDAO\/maker-otc\/blob\/master\/contracts\/simple_market.sol\r\n *\/\r\ncontract SafeMath {\r\n  \/\/internals\r\n\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) throw;\r\n  }\r\n}\r\n\r\n\/**\r\n * ERC 20 token\r\n *\r\n * https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n *\/\r\ncontract Token {\r\n\r\n    \/\/\/ @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    \/\/\/ @param _owner The address from which the balance will be retrieved\r\n    \/\/\/ @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    \/\/\/ @notice send `_value` token to `_to` from `msg.sender`\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _value The amount of token to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    \/\/\/ @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    \/\/\/ @param _from The address of the sender\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _value The amount of token to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    \/\/\/ @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @param _value The amount of wei to be approved for transfer\r\n    \/\/\/ @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    \/\/\/ @param _owner The address of the account owning tokens\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\n\/**\r\n * ERC 20 token\r\n *\r\n * https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n *\/\r\ncontract StandardToken is Token {\r\n\r\n    \/**\r\n     * Reviewed:\r\n     * - Interger overflow = OK, checked\r\n     *\/\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        \/\/Default assumes totalSupply can't be over max (2^256 - 1).\r\n        \/\/If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        \/\/Replace the if with this one instead.\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        \/\/if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        \/\/same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        \/\/if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping(address => uint256) balances;\r\n\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    uint256 public totalSupply;\r\n\r\n}\r\n\r\n\r\n\/**\r\n * First blood crowdsale crowdsale contract.\r\n *\r\n * Security criteria evaluated against http:\/\/ethereum.stackexchange.com\/questions\/8551\/methodological-security-review-of-a-smart-contract\r\n *\r\n *\r\n *\/\r\ncontract FirstBloodToken is StandardToken, SafeMath {\r\n\r\n    string public name = \"FirstBlood Token\";\r\n    string public symbol = \"1ST\";\r\n    uint public decimals = 18;\r\n    uint public startBlock; \/\/crowdsale start block (set in constructor)\r\n    uint public endBlock; \/\/crowdsale end block (set in constructor)\r\n\r\n    \/\/ Initial founder address (set in constructor)\r\n    \/\/ All deposited ETH will be instantly forwarded to this address.\r\n    \/\/ Address is a multisig wallet.\r\n    address public founder = 0x0;\r\n\r\n    \/\/ signer address (for clickwrap agreement)\r\n    \/\/ see function() {} for comments\r\n    address public signer = 0x0;\r\n\r\n    uint public etherCap = 465313 * 10**18; \/\/max amount raised during crowdsale (5.5M USD worth of ether will be measured with a moving average market price at beginning of the crowdsale)\r\n    uint public transferLockup = 370285; \/\/transfers are locked for this many blocks after endBlock (assuming 14 second blocks, this is 2 months)\r\n    uint public founderLockup = 2252571; \/\/founder allocation cannot be created until this many blocks after endBlock (assuming 14 second blocks, this is 1 year)\r\n    uint public bountyAllocation = 2500000 * 10**18; \/\/2.5M tokens allocated post-crowdsale for the bounty fund\r\n    uint public ecosystemAllocation = 5 * 10**16; \/\/5% of token supply allocated post-crowdsale for the ecosystem fund\r\n    uint public founderAllocation = 10 * 10**16; \/\/10% of token supply allocated post-crowdsale for the founder allocation\r\n    bool public bountyAllocated = false; \/\/this will change to true when the bounty fund is allocated\r\n    bool public ecosystemAllocated = false; \/\/this will change to true when the ecosystem fund is allocated\r\n    bool public founderAllocated = false; \/\/this will change to true when the founder fund is allocated\r\n    uint public presaleTokenSupply = 0; \/\/this will keep track of the token supply created during the crowdsale\r\n    uint public presaleEtherRaised = 0; \/\/this will keep track of the Ether raised during the crowdsale\r\n    bool public halted = false; \/\/the founder address can set this to true to halt the crowdsale due to emergency\r\n    event Buy(address indexed sender, uint eth, uint fbt);\r\n    event Withdraw(address indexed sender, address to, uint eth);\r\n    event AllocateFounderTokens(address indexed sender);\r\n    event AllocateBountyAndEcosystemTokens(address indexed sender);\r\n\r\n    function FirstBloodToken(address founderInput, address signerInput, uint startBlockInput, uint endBlockInput) {\r\n        founder = founderInput;\r\n        signer = signerInput;\r\n        startBlock = startBlockInput;\r\n        endBlock = endBlockInput;\r\n    }\r\n\r\n    \/**\r\n     * Security review\r\n     *\r\n     * - Integer overflow: does not apply, blocknumber can't grow that high\r\n     * - Division is the last operation and constant, should not cause issues\r\n     * - Price function plotted https:\/\/github.com\/Firstbloodio\/token\/issues\/2\r\n     *\/\r\n    function price() constant returns(uint) {\r\n        if (block.number>=startBlock && block.number<startBlock+250) return 170; \/\/power hour\r\n        if (block.number<startBlock || block.number>endBlock) return 100; \/\/default price\r\n        return 100 + 4*(endBlock - block.number)\/(endBlock - startBlock + 1)*67\/4; \/\/crowdsale price\r\n    }\r\n\r\n    \/\/ price() exposed for unit tests\r\n    function testPrice(uint blockNumber) constant returns(uint) {\r\n        if (blockNumber>=startBlock && blockNumber<startBlock+250) return 170; \/\/power hour\r\n        if (blockNumber<startBlock || blockNumber>endBlock) return 100; \/\/default price\r\n        return 100 + 4*(endBlock - blockNumber)\/(endBlock - startBlock + 1)*67\/4; \/\/crowdsale price\r\n    }\r\n\r\n    \/\/ Buy entry point\r\n    function buy(uint8 v, bytes32 r, bytes32 s) {\r\n        buyRecipient(msg.sender, v, r, s);\r\n    }\r\n\r\n    \/**\r\n     * Main token buy function.\r\n     *\r\n     * Security review\r\n     *\r\n     * - Integer math: ok - using SafeMath\r\n     *\r\n     * - halt flag added - ok\r\n     *\r\n     * Applicable tests:\r\n     *\r\n     * - Test halting, buying, and failing\r\n     * - Test buying on behalf of a recipient\r\n     * - Test buy\r\n     * - Test unhalting, buying, and succeeding\r\n     * - Test buying after the sale ends\r\n     *\r\n     *\/\r\n    function buyRecipient(address recipient, uint8 v, bytes32 r, bytes32 s) {\r\n        bytes32 hash = sha256(msg.sender);\r\n        if (ecrecover(hash,v,r,s) != signer) throw;\r\n        if (block.number<startBlock || block.number>endBlock || safeAdd(presaleEtherRaised,msg.value)>etherCap || halted) throw;\r\n        uint tokens = safeMul(msg.value, price());\r\n        balances[recipient] = safeAdd(balances[recipient], tokens);\r\n        totalSupply = safeAdd(totalSupply, tokens);\r\n        presaleEtherRaised = safeAdd(presaleEtherRaised, msg.value);\r\n\r\n        if (!founder.call.value(msg.value)()) throw; \/\/immediately send Ether to founder address\r\n\r\n        Buy(recipient, msg.value, tokens);\r\n    }\r\n\r\n    \/**\r\n     * Set up founder address token balance.\r\n     *\r\n     * allocateBountyAndEcosystemTokens() must be calld first.\r\n     *\r\n     * Security review\r\n     *\r\n     * - Integer math: ok - only called once with fixed parameters\r\n     *\r\n     * Applicable tests:\r\n     *\r\n     * - Test bounty and ecosystem allocation\r\n     * - Test bounty and ecosystem allocation twice\r\n     *\r\n     *\/\r\n    function allocateFounderTokens() {\r\n        if (msg.sender!=founder) throw;\r\n        if (block.number <= endBlock + founderLockup) throw;\r\n        if (founderAllocated) throw;\r\n        if (!bountyAllocated || !ecosystemAllocated) throw;\r\n        balances[founder] = safeAdd(balances[founder], presaleTokenSupply * founderAllocation \/ (1 ether));\r\n        totalSupply = safeAdd(totalSupply, presaleTokenSupply * founderAllocation \/ (1 ether));\r\n        founderAllocated = true;\r\n        AllocateFounderTokens(msg.sender);\r\n    }\r\n\r\n    \/**\r\n     * Set up founder address token balance.\r\n     *\r\n     * Set up bounty pool.\r\n     *\r\n     * Security review\r\n     *\r\n     * - Integer math: ok - only called once with fixed parameters\r\n     *\r\n     * Applicable tests:\r\n     *\r\n     * - Test founder token allocation too early\r\n     * - Test founder token allocation on time\r\n     * - Test founder token allocation twice\r\n     *\r\n     *\/\r\n    function allocateBountyAndEcosystemTokens() {\r\n        if (msg.sender!=founder) throw;\r\n        if (block.number <= endBlock) throw;\r\n        if (bountyAllocated || ecosystemAllocated) throw;\r\n        presaleTokenSupply = totalSupply;\r\n        balances[founder] = safeAdd(balances[founder], presaleTokenSupply * ecosystemAllocation \/ (1 ether));\r\n        totalSupply = safeAdd(totalSupply, presaleTokenSupply * ecosystemAllocation \/ (1 ether));\r\n        balances[founder] = safeAdd(balances[founder], bountyAllocation);\r\n        totalSupply = safeAdd(totalSupply, bountyAllocation);\r\n        bountyAllocated = true;\r\n        ecosystemAllocated = true;\r\n        AllocateBountyAndEcosystemTokens(msg.sender);\r\n    }\r\n\r\n    \/**\r\n     * Emergency Stop crowdsale.\r\n     *\r\n     *  Applicable tests:\r\n     *\r\n     * - Test unhalting, buying, and succeeding\r\n     *\/\r\n    function halt() {\r\n        if (msg.sender!=founder) throw;\r\n        halted = true;\r\n    }\r\n\r\n    function unhalt() {\r\n        if (msg.sender!=founder) throw;\r\n        halted = false;\r\n    }\r\n\r\n    \/**\r\n     * Change founder address (where crowdsale ETH is being forwarded).\r\n     *\r\n     * Applicable tests:\r\n     *\r\n     * - Test founder change by hacker\r\n     * - Test founder change\r\n     * - Test founder token allocation twice\r\n     *\r\n     *\/\r\n\r\n    function changeFounder(address newFounder) {\r\n        if (msg.sender!=founder) throw;\r\n        founder = newFounder;\r\n    }\r\n\r\n    \/**\r\n     * ERC 20 Standard Token interface transfer function\r\n     *\r\n     * Prevent transfers until freeze period is over.\r\n     *\r\n     * Applicable tests:\r\n     *\r\n     * - Test restricted early transfer\r\n     * - Test transfer after restricted period\r\n     *\/\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (block.number <= endBlock + transferLockup && msg.sender!=founder) throw;\r\n        return super.transfer(_to, _value);\r\n    }\r\n    \/**\r\n     * ERC 20 Standard Token interface transfer function\r\n     *\r\n     * Prevent transfers until freeze period is over.\r\n     *\/\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (block.number <= endBlock + transferLockup && msg.sender!=founder) throw;\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    \/**\r\n     * Do not allow direct deposits.\r\n     *\r\n     * All crowdsale depositors must have read the legal agreement.\r\n     * This is confirmed by having them signing the terms of service on the website.\r\n     * They give their crowdsale Ethereum source address on the website.\r\n     * Website signs this address using crowdsale private key (different from founders key).\r\n     * buy() takes this signature as input and rejects all deposits that do not have\r\n     * signature you receive after reading terms of service.\r\n     *\r\n     *\/\r\n    function() {\r\n        throw;\r\n    }\r\n\r\n}",
      "officialLinks": {
        "Reddit": "",
        "Telegram": "",
        "Website": "https:\/\/firstblood.io\/",
        "Email": "mailto:team@firstblood.io",
        "Twitter": "https:\/\/twitter.com\/firstbloodio"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xaf30d2a7e90d7dc361c8c4585e9bb7d2f6f15bc7#code"
    }, {
      "contractId": 28,
      "title": "SingularDTVToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "SNGLS",
      "code": "\/\/\/ Implements ERC 20 Token standard: https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n\r\n\/\/\/ @title Abstract token contract - Functions to be implemented by token contracts.\r\n\/\/\/ @author Stefan George - <[email\u00a0protected]>\r\ncontract Token {\r\n    \/\/ This is not an abstract function, because solc won't recognize generated getter functions for public variables as functions\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n    function balanceOf(address owner) constant returns (uint256 balance);\r\n    function transfer(address to, uint256 value) returns (bool success);\r\n    function transferFrom(address from, address to, uint256 value) returns (bool success);\r\n    function approve(address spender, uint256 value) returns (bool success);\r\n    function allowance(address owner, address spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    \/*\r\n     *  Data structures\r\n     *\/\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n\r\n    \/*\r\n     *  Read and write storage functions\r\n     *\/\r\n    \/\/\/ @dev Transfers sender's tokens to a given address. Returns success.\r\n    \/\/\/ @param _to Address of token receiver.\r\n    \/\/\/ @param _value Number of tokens to transfer.\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    \/\/\/ @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\r\n    \/\/\/ @param _from Address from where tokens are withdrawn.\r\n    \/\/\/ @param _to Address to where tokens are sent.\r\n    \/\/\/ @param _value Number of tokens to transfer.\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    \/\/\/ @dev Returns number of tokens owned by given address.\r\n    \/\/\/ @param _owner Address of token owner.\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    \/\/\/ @dev Sets approved amount of tokens for spender. Returns success.\r\n    \/\/\/ @param _spender Address of allowed account.\r\n    \/\/\/ @param _value Number of approved tokens.\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    \/*\r\n     * Read storage functions\r\n     *\/\r\n    \/\/\/ @dev Returns number of allowed tokens for given address.\r\n    \/\/\/ @param _owner Address of token owner.\r\n    \/\/\/ @param _spender Address of token spender.\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\ncontract SingularDTVFund {\r\n    function workshop() returns (address);\r\n    function softWithdrawRevenueFor(address forAddress) returns (uint);\r\n}\r\ncontract SingularDTVCrowdfunding {\r\n    function twoYearsPassed() returns (bool);\r\n    function startDate() returns (uint);\r\n    function CROWDFUNDING_PERIOD() returns (uint);\r\n    function TOKEN_TARGET() returns (uint);\r\n    function valuePerShare() returns (uint);\r\n    function fundBalance() returns (uint);\r\n    function campaignEndedSuccessfully() returns (bool);\r\n}\r\n\r\n\r\n\/\/\/ @title Token contract - Implements token issuance.\r\n\/\/\/ @author Stefan George - <[email\u00a0protected]>\r\ncontract SingularDTVToken is StandardToken {\r\n\r\n    \/*\r\n     *  External contracts\r\n     *\/\r\n    SingularDTVFund constant singularDTVFund = SingularDTVFund(0xe736091fc36f1ad476f5e4e03e4425940822d3ba);\r\n    SingularDTVCrowdfunding constant singularDTVCrowdfunding = SingularDTVCrowdfunding(0xbdf5c4f1c1a9d7335a6a68d9aa011d5f40cf5520);\r\n\r\n    \/*\r\n     *  Token meta data\r\n     *\/\r\n    string constant public name = \"SingularDTV\";\r\n    string constant public symbol = \"SNGLS\";\r\n    uint8 constant public decimals = 0;\r\n\r\n    \/*\r\n     *  Modifiers\r\n     *\/\r\n    modifier noEther() {\r\n        if (msg.value > 0) {\r\n            throw;\r\n        }\r\n        _\r\n    }\r\n\r\n    modifier workshopWaitedTwoYears() {\r\n        \/\/ Workshop can only transfer tokens after a two years period.\r\n        if (msg.sender == singularDTVFund.workshop() && !singularDTVCrowdfunding.twoYearsPassed()) {\r\n            throw;\r\n        }\r\n        _\r\n    }\r\n\r\n    modifier isCrowdfundingContract () {\r\n        \/\/ Only crowdfunding contract is allowed to proceed.\r\n        if (msg.sender != address(singularDTVCrowdfunding)) {\r\n            throw;\r\n        }\r\n        _\r\n    }\r\n\r\n    \/*\r\n     *  Contract functions\r\n     *\/\r\n    \/\/\/ @dev Crowdfunding contract issues new tokens for address. Returns success.\r\n    \/\/\/ @param _for Address of receiver.\r\n    \/\/\/ @param tokenCount Number of tokens to issue.\r\n    function issueTokens(address _for, uint tokenCount)\r\n        external\r\n        isCrowdfundingContract\r\n        returns (bool)\r\n    {\r\n        if (tokenCount == 0) {\r\n            return false;\r\n        }\r\n        balances[_for] += tokenCount;\r\n        totalSupply += tokenCount;\r\n        return true;\r\n    }\r\n\r\n    \/\/\/ @dev Transfers sender's tokens to a given address. Returns success.\r\n    \/\/\/ @param to Address of token receiver.\r\n    \/\/\/ @param value Number of tokens to transfer.\r\n    function transfer(address to, uint256 value)\r\n        noEther\r\n        workshopWaitedTwoYears\r\n        returns (bool)\r\n    {\r\n        \/\/ Both parties withdraw their revenue first\r\n        singularDTVFund.softWithdrawRevenueFor(msg.sender);\r\n        singularDTVFund.softWithdrawRevenueFor(to);\r\n        return super.transfer(to, value);\r\n    }\r\n\r\n    \/\/\/ @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\r\n    \/\/\/ @param from Address from where tokens are withdrawn.\r\n    \/\/\/ @param to Address to where tokens are sent.\r\n    \/\/\/ @param value Number of tokens to transfer.\r\n    function transferFrom(address from, address to, uint256 value)\r\n        noEther\r\n        workshopWaitedTwoYears\r\n        returns (bool)\r\n    {\r\n        \/\/ Both parties withdraw their revenue first\r\n        singularDTVFund.softWithdrawRevenueFor(from);\r\n        singularDTVFund.softWithdrawRevenueFor(to);\r\n        return super.transferFrom(from, to, value);\r\n    }\r\n\r\n    \/\/\/ @dev Contract constructor function sets initial token balances.\r\n    function SingularDTVToken() noEther {\r\n        \/\/ Set token creation for workshop\r\n        balances[singularDTVFund.workshop()] = 400000000; \/\/ ~400M\r\n        \/\/ Set token creation for core\r\n        balances[0x0196b712a0459cbee711e7c1d34d2c85a9910379] = 5000000;\r\n        balances[0x0f94dc84ce0f5fa2a8cc8d27a6969e25b5a39273] = 200000;\r\n        balances[0x122b7eb5f629d806c8adb0baa0560266abb3ec80] = 450000;\r\n        balances[0x13870d30fcdb7d7ae875668f2a1219225295d57c] = 50000;\r\n        balances[0x26640e826547bc700b8c7a9cc2c1c39a4ab3cbb3] = 900000;\r\n        balances[0x26bbfc6b23bc36e84447f061c6804f3a8b1a3698] = 250000;\r\n        balances[0x2d37383a45b5122a27efade69f7180eee4d965da] = 1270000;\r\n        balances[0x2e79b81121193d55c4934c0f32ad3d0474ca7b9c] = 4200000;\r\n        balances[0x3114844fc0e3de03963bbd1d983ba17ca89ad010] = 5000000;\r\n        balances[0x378e6582e4e3723f7076c7769eef6febf51258e1] = 680000;\r\n        balances[0x3e18530a4ee49a0357ffc8e74c08bfdee3915482] = 2490000;\r\n        balances[0x43fed1208d25ca0ef5681a5c17180af50c19f826] = 100000;\r\n        balances[0x4f183b18302c0ac5804b8c455018efc51af15a56] = 10000;\r\n        balances[0x55a886834658ccb6f26c39d5fdf6d833df3a276a] = 100000;\r\n        balances[0x5faa1624422db662c654ab35ce57bf3242888937] = 5000000;\r\n        balances[0x6407b662b306e2353b627488da952337a5a0bbaa] = 5000000;\r\n        balances[0x66c334fff8c8b8224b480d8da658ca3b032fe625] = 10000000;\r\n        balances[0x6c24991c6a40cd5ad6fab78388651fb324b35458] = 250000;\r\n        balances[0x781ba492f786b2be48c2884b733874639f50022c] = 500000;\r\n        balances[0x79b48f6f1ac373648c509b74a2c04a3281066457] = 2000000;\r\n        balances[0x835898804ed30e20aa29f2fe35c9f225175b049f] = 100000;\r\n        balances[0x93c56ea8848150389e0917de868b0a23c87cf7b1] = 2790000;\r\n        balances[0x93f959df3df3c6ee01ee9748327b881b2137bf2a] = 450000;\r\n        balances[0x9adc0215372e4ffd8c89621a6bd9cfddf230349f] = 550000;\r\n        balances[0xae4dbd3dae66722315541d66fe9457b342ac76d9] = 500000;\r\n        balances[0xbae02fe006f115e45b372f2ddc053eedca2d6fff] = 1800000;\r\n        balances[0xcc835821f643e090d8157de05451b416cd1202c4] = 300000;\r\n        balances[0xce75342b92a7d0b1a2c6e9835b6b85787e12e585] = 670000;\r\n        balances[0xd2b388467d9d0c30bab0a68070c6f49c473583a0] = 990000;\r\n        balances[0xdca0724ddde95bbace1b557cab4375d9a813da49] = 3500000;\r\n        balances[0xe3ef62165b60cac0fcbe9c2dc6a03aab4c5c8462] = 150000;\r\n        balances[0xe4f7d5083baeea7810b6d816581bb0ee7cd4b6f4] = 10560000;\r\n        balances[0xef08eb55d3482973c178b02bd4d5f2cea420325f] = 80000;\r\n        balances[0xfdecc9f2ee374cedc94f72ab4da2de896ce58c19] = 5000000;\r\n        balances[0xe5ff71dc1dea8cd2552eec59e9a5e8813da9bb01] = 29110000;\r\n        totalSupply = 500000000; \/\/ 500M\r\n    }\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/SingularDTV",
        "Telegram": "",
        "Website": "https:\/\/singulardtv.com\/",
        "Email": "https:\/\/singulardtv.com\/contact-us",
        "Twitter": "https:\/\/twitter.com\/SingularDTV"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xaec2e87e0a235266d9c5adc9deb4b2e29b54d009#code"
    }, {
      "contractId": 29,
      "title": "DGD Token",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "DGD",
      "code": "\/\/\/ @title DigixDAO Contract Interfaces\r\n\r\ncontract ConfigInterface {\r\n        address public owner;\r\n        mapping(address => bool) admins;\r\n        mapping(bytes32 => address) addressMap;\r\n        mapping(bytes32 => bool) boolMap;\r\n        mapping(bytes32 => bytes32) bytesMap;\r\n        mapping(bytes32 => uint256) uintMap;\r\n\r\n        \/\/\/ @notice setConfigAddress sets configuration `_key` to `_val`\r\n        \/\/\/ @param _key The key name of the configuration.\r\n        \/\/\/ @param _val The value of the configuration.\r\n        \/\/\/ @return Whether the configuration setting was successful or not.\r\n        function setConfigAddress(bytes32 _key, address _val) returns(bool success);\r\n\r\n        \/\/\/ @notice setConfigBool sets configuration `_key` to `_val`\r\n        \/\/\/ @param _key The key name of the configuration.\r\n        \/\/\/ @param _val The value of the configuration.\r\n        \/\/\/ @return Whether the configuration setting was successful or not.\r\n        function setConfigBool(bytes32 _key, bool _val) returns(bool success);\r\n\r\n        \/\/\/ @notice setConfigBytes sets configuration `_key` to `_val`\r\n        \/\/\/ @param _key The key name of the configuration.\r\n        \/\/\/ @param _val The value of the configuration.\r\n        \/\/\/ @return Whether the configuration setting was successful or not.\r\n        function setConfigBytes(bytes32 _key, bytes32 _val) returns(bool success);\r\n\r\n        \/\/\/ @notice setConfigUint `_key` to `_val`\r\n        \/\/\/ @param _key The key name of the configuration.\r\n        \/\/\/ @param _val The value of the configuration.\r\n        \/\/\/ @return Whether the configuration setting was successful or not.\r\n        function setConfigUint(bytes32 _key, uint256 _val) returns(bool success);\r\n\r\n        \/\/\/ @notice getConfigAddress gets configuration `_key`'s value\r\n        \/\/\/ @param _key The key name of the configuration.\r\n        \/\/\/ @return The configuration value\r\n        function getConfigAddress(bytes32 _key) returns(address val);\r\n\r\n        \/\/\/ @notice getConfigBool gets configuration `_key`'s value\r\n        \/\/\/ @param _key The key name of the configuration.\r\n        \/\/\/ @return The configuration value\r\n        function getConfigBool(bytes32 _key) returns(bool val);\r\n\r\n        \/\/\/ @notice getConfigBytes gets configuration `_key`'s value\r\n        \/\/\/ @param _key The key name of the configuration.\r\n        \/\/\/ @return The configuration value\r\n        function getConfigBytes(bytes32 _key) returns(bytes32 val);\r\n\r\n        \/\/\/ @notice getConfigUint gets configuration `_key`'s value\r\n        \/\/\/ @param _key The key name of the configuration.\r\n        \/\/\/ @return The configuration value\r\n        function getConfigUint(bytes32 _key) returns(uint256 val);\r\n\r\n        \/\/\/ @notice addAdmin sets `_admin` as configuration admin\r\n        \/\/\/ @return Whether the configuration setting was successful or not.\r\n        function addAdmin(address _admin) returns(bool success);\r\n\r\n        \/\/\/ @notice removeAdmin removes  `_admin`'s rights\r\n        \/\/\/ @param _admin The key name of the configuration.\r\n        \/\/\/ @return Whether the configuration setting was successful or not.\r\n        function removeAdmin(address _admin) returns(bool success);\r\n\r\n}\r\n\r\ncontract TokenInterface {\r\n\r\n        mapping(address => uint256) balances;\r\n        mapping(address => mapping(address => uint256)) allowed;\r\n        mapping(address => bool) seller;\r\n\r\n        address config;\r\n        address owner;\r\n        address dao;\r\n        address public badgeLedger;\r\n        bool locked;\r\n\r\n        \/\/\/ @return total amount of tokens\r\n        uint256 public totalSupply;\r\n\r\n        \/\/\/ @param _owner The address from which the balance will be retrieved\r\n        \/\/\/ @return The balance\r\n        function balanceOf(address _owner) constant returns(uint256 balance);\r\n\r\n        \/\/\/ @notice send `_value` tokens to `_to` from `msg.sender`\r\n        \/\/\/ @param _to The address of the recipient\r\n        \/\/\/ @param _value The amount of tokens to be transfered\r\n        \/\/\/ @return Whether the transfer was successful or not\r\n        function transfer(address _to, uint256 _value) returns(bool success);\r\n\r\n        \/\/\/ @notice send `_value` tokens to `_to` from `_from` on the condition it is approved by `_from`\r\n        \/\/\/ @param _from The address of the sender\r\n        \/\/\/ @param _to The address of the recipient\r\n        \/\/\/ @param _value The amount of tokens to be transfered\r\n        \/\/\/ @return Whether the transfer was successful or not\r\n        function transferFrom(address _from, address _to, uint256 _value) returns(bool success);\r\n\r\n        \/\/\/ @notice `msg.sender` approves `_spender` to spend `_value` tokens on its behalf\r\n        \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n        \/\/\/ @param _value The amount of tokens to be approved for transfer\r\n        \/\/\/ @return Whether the approval was successful or not\r\n        function approve(address _spender, uint256 _value) returns(bool success);\r\n\r\n        \/\/\/ @param _owner The address of the account owning tokens\r\n        \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n        \/\/\/ @return Amount of remaining tokens of _owner that _spender is allowed to spend\r\n        function allowance(address _owner, address _spender) constant returns(uint256 remaining);\r\n\r\n        \/\/\/ @notice mint `_amount` of tokens to `_owner`\r\n        \/\/\/ @param _owner The address of the account receiving the tokens\r\n        \/\/\/ @param _amount The amount of tokens to mint\r\n        \/\/\/ @return Whether or not minting was successful\r\n        function mint(address _owner, uint256 _amount) returns(bool success);\r\n\r\n        \/\/\/ @notice mintBadge Mint `_amount` badges to `_owner`\r\n        \/\/\/ @param _owner The address of the account receiving the tokens\r\n        \/\/\/ @param _amount The amount of tokens to mint\r\n        \/\/\/ @return Whether or not minting was successful\r\n        function mintBadge(address _owner, uint256 _amount) returns(bool success);\r\n\r\n        function registerDao(address _dao) returns(bool success);\r\n\r\n        function registerSeller(address _tokensales) returns(bool success);\r\n\r\n        event Transfer(address indexed _from, address indexed _to, uint256 indexed _value);\r\n        event Mint(address indexed _recipient, uint256 indexed _amount);\r\n        event Approval(address indexed _owner, address indexed _spender, uint256 indexed _value);\r\n}\r\n\r\ncontract TokenSalesInterface {\r\n\r\n        struct SaleProxy {\r\n                address payout;\r\n                bool isProxy;\r\n        }\r\n\r\n        struct SaleStatus {\r\n                bool founderClaim;\r\n                uint256 releasedTokens;\r\n                uint256 releasedBadges;\r\n                uint256 claimers;\r\n        }\r\n\r\n        struct Info {\r\n                uint256 totalWei;\r\n                uint256 totalCents;\r\n                uint256 realCents;\r\n                uint256 amount;\r\n        }\r\n\r\n        struct SaleConfig {\r\n                uint256 startDate;\r\n                uint256 periodTwo;\r\n                uint256 periodThree;\r\n                uint256 endDate;\r\n                uint256 goal;\r\n                uint256 cap;\r\n                uint256 badgeCost;\r\n                uint256 founderAmount;\r\n                address founderWallet;\r\n        }\r\n\r\n        struct Buyer {\r\n                uint256 centsTotal;\r\n                uint256 weiTotal;\r\n                bool claimed;\r\n        }\r\n\r\n        Info saleInfo;\r\n        SaleConfig saleConfig;\r\n        SaleStatus saleStatus;\r\n\r\n        address config;\r\n        address owner;\r\n        bool locked;\r\n\r\n        uint256 public ethToCents;\r\n\r\n        mapping(address => Buyer) buyers;\r\n        mapping(address => SaleProxy) proxies;\r\n\r\n        \/\/\/ @notice Calculates the parts per billion 1\u20441,000,000,000 of `_a` to `_b`\r\n        \/\/\/ @param _a The antecedent\r\n        \/\/\/ @param _c The consequent\r\n        \/\/\/ @return Part per billion value\r\n        function ppb(uint256 _a, uint256 _c) public constant returns(uint256 b);\r\n\r\n\r\n        \/\/\/ @notice Calculates the share from `_total` based on `_contrib`\r\n        \/\/\/ @param _contrib The contributed amount in USD\r\n        \/\/\/ @param _total The total amount raised in USD\r\n        \/\/\/ @return Total number of shares\r\n        function calcShare(uint256 _contrib, uint256 _total) public constant returns(uint256 share);\r\n\r\n        \/\/\/ @notice Calculates the current USD cents value of `_wei`\r\n        \/\/\/ @param _wei the amount of wei\r\n        \/\/\/ @return The USD cents value\r\n        function weiToCents(uint256 _wei) public constant returns(uint256 centsvalue);\r\n\r\n        function proxyPurchase(address _user) returns(bool success);\r\n\r\n        \/\/\/ @notice Send msg.value purchase for _user.\r\n        \/\/\/ @param _user The account to be credited\r\n        \/\/\/ @return Success if purchase was accepted\r\n        function purchase(address _user, uint256 _amount) private returns(bool success);\r\n\r\n        \/\/\/ @notice Get crowdsale information for `_user`\r\n        \/\/\/ @param _user The account to be queried\r\n        \/\/\/ @return `centstotal` the total amount of USD cents contributed\r\n        \/\/\/ @return `weitotal` the total amount in wei contributed\r\n        \/\/\/ @return `share` the current token shares earned\r\n        \/\/\/ @return `badges` the number of proposer badges earned\r\n        \/\/\/ @return `claimed` is true if the tokens and badges have been claimed\r\n        function userInfo(address _user) public constant returns(uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed);\r\n\r\n        \/\/\/ @notice Get the crowdsale information from msg.sender (see userInfo)\r\n        function myInfo() public constant returns(uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed);\r\n\r\n        \/\/\/ @notice get the total amount of wei raised for the crowdsale\r\n        \/\/\/ @return The amount of wei raised\r\n        function totalWei() public constant returns(uint);\r\n\r\n        \/\/\/ @notice get the total USD value in cents raised for the crowdsale\r\n        \/\/\/ @return the amount USD cents\r\n        function totalCents() public constant returns(uint);\r\n\r\n        \/\/\/ @notice get the current crowdsale information\r\n        \/\/\/ @return `startsale` The unix timestamp for the start of the crowdsale and the first period modifier\r\n        \/\/\/ @return `two` The unix timestamp for the start of the second period modifier\r\n        \/\/\/ @return `three` The unix timestamp for the start of the third period modifier\r\n        \/\/\/ @return `endsale` The unix timestamp of the end of crowdsale\r\n        \/\/\/ @return `totalwei` The total amount of wei raised\r\n        \/\/\/ @return `totalcents` The total number of USD cents raised\r\n        \/\/\/ @return `amount` The amount of DGD tokens available for the crowdsale\r\n        \/\/\/ @return `goal` The USD value goal for the crowdsale\r\n        \/\/\/ @return `famount` Founders endowment\r\n        \/\/\/ @return `faddress` Founder wallet address\r\n        \/*function getSaleInfo() public constant returns (uint256 startsale, uint256 two, uint256 three, uint256 endsale, uint256 totalwei, uint256 totalcents, uint256 amount, uint256 goal, uint256 famount, address faddress);*\/\r\n\r\n        function claimFor(address _user) returns(bool success);\r\n\r\n        \/\/\/ @notice Allows msg.sender to claim the DGD tokens and badges if the goal is reached or refunds the ETH contributed if goal is not reached at the end of the crowdsale\r\n        function claim() returns(bool success);\r\n\r\n        function claimFounders() returns(bool success);\r\n\r\n        \/\/\/ @notice See if the crowdsale goal has been reached\r\n        function goalReached() public constant returns(bool reached);\r\n\r\n        \/\/\/ @notice Get the current sale period\r\n        \/\/\/ @return `saleperiod` 0 = Outside of the crowdsale period, 1 = First reward period, 2 = Second reward period, 3 = Final crowdsale period.\r\n        function getPeriod() public constant returns(uint saleperiod);\r\n\r\n        \/\/\/ @notice Get the date for the start of the crowdsale\r\n        \/\/\/ @return `date` The unix timestamp for the start\r\n        function startDate() public constant returns(uint date);\r\n\r\n        \/\/\/ @notice Get the date for the second reward period of the crowdsale\r\n        \/\/\/ @return `date` The unix timestamp for the second period\r\n        function periodTwo() public constant returns(uint date);\r\n\r\n        \/\/\/ @notice Get the date for the final period of the crowdsale\r\n        \/\/\/ @return `date` The unix timestamp for the final period\r\n        function periodThree() public constant returns(uint date);\r\n\r\n        \/\/\/ @notice Get the date for the end of the crowdsale\r\n        \/\/\/ @return `date` The unix timestamp for the end of the crowdsale\r\n        function endDate() public constant returns(uint date);\r\n\r\n        \/\/\/ @notice Check if crowdsale has ended\r\n        \/\/\/ @return `ended` If the crowdsale has ended\r\n\r\n        function isEnded() public constant returns(bool ended);\r\n\r\n        \/\/\/ @notice Send raised funds from the crowdsale to the DAO\r\n        \/\/\/ @return `success` if the send succeeded\r\n        function sendFunds() public returns(bool success);\r\n\r\n        \/\/function regProxy(address _payment, address _payout) returns (bool success);\r\n        function regProxy(address _payout) returns(bool success);\r\n\r\n        function getProxy(address _payout) public returns(address proxy);\r\n\r\n        function getPayout(address _proxy) public returns(address payout, bool isproxy);\r\n\r\n        function unlock() public returns(bool success);\r\n\r\n        function getSaleStatus() public constant returns(bool fclaim, uint256 reltokens, uint256 relbadges, uint256 claimers);\r\n\r\n        function getSaleInfo() public constant returns(uint256 weiamount, uint256 cents, uint256 realcents, uint256 amount);\r\n\r\n        function getSaleConfig() public constant returns(uint256 start, uint256 two, uint256 three, uint256 end, uint256 goal, uint256 cap, uint256 badgecost, uint256 famount, address fwallet);\r\n\r\n        event Purchase(uint256 indexed _exchange, uint256 indexed _rate, uint256 indexed _cents);\r\n        event Claim(address indexed _user, uint256 indexed _amount, uint256 indexed _badges);\r\n\r\n}\r\n\r\ncontract Badge {\r\n        mapping(address => uint256) balances;\r\n        mapping(address => mapping(address => uint256)) allowed;\r\n\r\n        address public owner;\r\n        bool public locked;\r\n\r\n        \/\/\/ @return total amount of tokens\r\n        uint256 public totalSupply;\r\n\r\n        modifier ifOwner() {\r\n                if (msg.sender != owner) {\r\n                        throw;\r\n                } else {\r\n                        _\r\n                }\r\n        }\r\n\r\n\r\n        event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n        event Mint(address indexed _recipient, uint256 indexed _amount);\r\n        event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n        function Badge() {\r\n                owner = msg.sender;\r\n        }\r\n\r\n        function safeToAdd(uint a, uint b) returns(bool) {\r\n                return (a + b >= a);\r\n        }\r\n\r\n        function addSafely(uint a, uint b) returns(uint result) {\r\n                if (!safeToAdd(a, b)) {\r\n                        throw;\r\n                } else {\r\n                        result = a + b;\r\n                        return result;\r\n                }\r\n        }\r\n\r\n        function safeToSubtract(uint a, uint b) returns(bool) {\r\n                return (b <= a);\r\n        }\r\n\r\n        function subtractSafely(uint a, uint b) returns(uint) {\r\n                if (!safeToSubtract(a, b)) throw;\r\n                return a - b;\r\n        }\r\n\r\n        function balanceOf(address _owner) constant returns(uint256 balance) {\r\n                return balances[_owner];\r\n        }\r\n\r\n        function transfer(address _to, uint256 _value) returns(bool success) {\r\n                if (balances[msg.sender] >= _value && _value > 0) {\r\n                        balances[msg.sender] = subtractSafely(balances[msg.sender], _value);\r\n                        balances[_to] = addSafely(_value, balances[_to]);\r\n                        Transfer(msg.sender, _to, _value);\r\n                        success = true;\r\n                } else {\r\n                        success = false;\r\n                }\r\n                return success;\r\n        }\r\n\r\n        function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\r\n                if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n                        balances[_to] = addSafely(balances[_to], _value);\r\n                        balances[_from] = subtractSafely(balances[_from], _value);\r\n                        allowed[_from][msg.sender] = subtractSafely(allowed[_from][msg.sender], _value);\r\n                        Transfer(_from, _to, _value);\r\n                        return true;\r\n                } else {\r\n                        return false;\r\n                }\r\n        }\r\n\r\n        function approve(address _spender, uint256 _value) returns(bool success) {\r\n                allowed[msg.sender][_spender] = _value;\r\n                Approval(msg.sender, _spender, _value);\r\n                success = true;\r\n                return success;\r\n        }\r\n\r\n        function allowance(address _owner, address _spender) constant returns(uint256 remaining) {\r\n                remaining = allowed[_owner][_spender];\r\n                return remaining;\r\n        }\r\n\r\n        function mint(address _owner, uint256 _amount) ifOwner returns(bool success) {\r\n                totalSupply = addSafely(totalSupply, _amount);\r\n                balances[_owner] = addSafely(balances[_owner], _amount);\r\n                Mint(_owner, _amount);\r\n                return true;\r\n        }\r\n\r\n        function setOwner(address _owner) ifOwner returns(bool success) {\r\n                owner = _owner;\r\n                return true;\r\n        }\r\n\r\n}\r\n\r\ncontract Token {\r\n\r\n        address public owner;\r\n        address public config;\r\n        bool public locked;\r\n        address public dao;\r\n        address public badgeLedger;\r\n        uint256 public totalSupply;\r\n\r\n        mapping(address => uint256) balances;\r\n        mapping(address => mapping(address => uint256)) allowed;\r\n        mapping(address => bool) seller;\r\n\r\n        \/\/\/ @return total amount of tokens\r\n\r\n        modifier ifSales() {\r\n                if (!seller[msg.sender]) throw;\r\n                _\r\n        }\r\n\r\n        modifier ifOwner() {\r\n                if (msg.sender != owner) throw;\r\n                _\r\n        }\r\n\r\n        modifier ifDao() {\r\n                if (msg.sender != dao) throw;\r\n                _\r\n        }\r\n\r\n        event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n        event Mint(address indexed _recipient, uint256 _amount);\r\n        event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n        function Token(address _config) {\r\n                config = _config;\r\n                owner = msg.sender;\r\n                address _initseller = ConfigInterface(_config).getConfigAddress(\"sale1:address\");\r\n                seller[_initseller] = true;\r\n                badgeLedger = new Badge();\r\n                locked = false;\r\n        }\r\n\r\n        function safeToAdd(uint a, uint b) returns(bool) {\r\n                return (a + b >= a);\r\n        }\r\n\r\n        function addSafely(uint a, uint b) returns(uint result) {\r\n                if (!safeToAdd(a, b)) {\r\n                        throw;\r\n                } else {\r\n                        result = a + b;\r\n                        return result;\r\n                }\r\n        }\r\n\r\n        function safeToSubtract(uint a, uint b) returns(bool) {\r\n                return (b <= a);\r\n        }\r\n\r\n        function subtractSafely(uint a, uint b) returns(uint) {\r\n                if (!safeToSubtract(a, b)) throw;\r\n                return a - b;\r\n        }\r\n\r\n        function balanceOf(address _owner) constant returns(uint256 balance) {\r\n                return balances[_owner];\r\n        }\r\n\r\n        function transfer(address _to, uint256 _value) returns(bool success) {\r\n                if (balances[msg.sender] >= _value && _value > 0) {\r\n                        balances[msg.sender] = subtractSafely(balances[msg.sender], _value);\r\n                        balances[_to] = addSafely(balances[_to], _value);\r\n                        Transfer(msg.sender, _to, _value);\r\n                        success = true;\r\n                } else {\r\n                        success = false;\r\n                }\r\n                return success;\r\n        }\r\n\r\n        function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\r\n                if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n                        balances[_to] = addSafely(balances[_to], _value);\r\n                        balances[_from] = subtractSafely(balances[_from], _value);\r\n                        allowed[_from][msg.sender] = subtractSafely(allowed[_from][msg.sender], _value);\r\n                        Transfer(_from, _to, _value);\r\n                        return true;\r\n                } else {\r\n                        return false;\r\n                }\r\n        }\r\n\r\n        function approve(address _spender, uint256 _value) returns(bool success) {\r\n                allowed[msg.sender][_spender] = _value;\r\n                Approval(msg.sender, _spender, _value);\r\n                success = true;\r\n                return success;\r\n        }\r\n\r\n        function allowance(address _owner, address _spender) constant returns(uint256 remaining) {\r\n                remaining = allowed[_owner][_spender];\r\n                return remaining;\r\n        }\r\n\r\n        function mint(address _owner, uint256 _amount) ifSales returns(bool success) {\r\n                totalSupply = addSafely(_amount, totalSupply);\r\n                balances[_owner] = addSafely(balances[_owner], _amount);\r\n                return true;\r\n        }\r\n\r\n        function mintBadge(address _owner, uint256 _amount) ifSales returns(bool success) {\r\n                if (!Badge(badgeLedger).mint(_owner, _amount)) return false;\r\n                return true;\r\n        }\r\n\r\n        function registerDao(address _dao) ifOwner returns(bool success) {\r\n                if (locked == true) return false;\r\n                dao = _dao;\r\n                locked = true;\r\n                return true;\r\n        }\r\n\r\n        function setDao(address _newdao) ifDao returns(bool success) {\r\n                dao = _newdao;\r\n                return true;\r\n        }\r\n\r\n        function isSeller(address _query) returns(bool isseller) {\r\n                return seller[_query];\r\n        }\r\n\r\n        function registerSeller(address _tokensales) ifDao returns(bool success) {\r\n                seller[_tokensales] = true;\r\n                return true;\r\n        }\r\n\r\n        function unregisterSeller(address _tokensales) ifDao returns(bool success) {\r\n                seller[_tokensales] = false;\r\n                return true;\r\n        }\r\n\r\n        function setOwner(address _newowner) ifDao returns(bool success) {\r\n                if (Badge(badgeLedger).setOwner(_newowner)) {\r\n                        owner = _newowner;\r\n                        success = true;\r\n                } else {\r\n                        success = false;\r\n                }\r\n                return success;\r\n        }\r\n\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/digix\/",
        "Telegram": "",
        "Website": "https:\/\/digix.io\/",
        "Email": "mailto:support@digix.io",
        "Twitter": "https:\/\/twitter.com\/digixglobal"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xe0b7927c4af23765cb51314a0e0521a9645f0e2a#code"
    }, {
      "contractId": 30,
      "title": "QASHToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "QASH",
      "code": "pragma solidity ^0.4.16;\r\n\r\n\/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n *\/\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\n    uint256 c = a \/ b;\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/179\r\n *\/\r\ncontract ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n *\/\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  \/**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  *\/\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    \/\/ SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  *\/\r\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n\/**\r\n * @title ERC20 interface\r\n * @dev see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n *\/\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n * @dev Based on code by FirstBlood: https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\n *\/\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  \/**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   *\/\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   *\/\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   *\/\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n}\r\n\r\n\/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n *\/\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  \/**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   *\/\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  \/**\r\n   * @dev Throws if called by any account other than the owner.\r\n   *\/\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  \/**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   *\/\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n *\/\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  \/**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   *\/\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   *\/\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   *\/\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  \/**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   *\/\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n\/**\r\n * @title Pausable token\r\n *\r\n * @dev StandardToken modified with pausable transfers.\r\n **\/\r\n\r\ncontract PausableToken is StandardToken, Pausable {\r\n\r\n  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\r\n    return super.approve(_spender, _value);\r\n  }\r\n}\r\n\r\n\/**\r\n * @title QASH Token\r\n *\r\n * @dev Implementation of QASH Token based on the basic standard token.\r\n *\/\r\ncontract QASHToken is PausableToken {\r\n\r\n    function () {\r\n      \/\/if ether is sent to this address, send it back.\r\n        revert();\r\n    }\r\n\r\n    \/**\r\n    * Public variables of the token\r\n    * The following variables are OPTIONAL vanities. One does not have to include them.\r\n    * They allow one to customise the token contract & in no way influences the core functionality.\r\n    * Some wallets\/interfaces might not even bother to look at this information.\r\n    *\/\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    string public version = '1.0.0';\r\n\r\n    \/**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param _totalSupply total supply of the token.\r\n     * @param _name token name e.g QASH Token.\r\n     * @param _symbol token symbol e.g QASH.\r\n     * @param _decimals amount of decimals.\r\n     *\/\r\n    function QASHToken(uint256 _totalSupply, string _name, string _symbol, uint8 _decimals) {\r\n        balances[msg.sender] = _totalSupply;    \/\/ Give the creator all initial tokens\r\n        totalSupply = _totalSupply;\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n    }\r\n}",
      "officialLinks": {
        "Reddit": "",
        "Telegram": "https:\/\/t.me\/QUOINE",
        "Website": "https:\/\/liquid.plus\/",
        "Email": "mailto:support@quoine.com",
        "Twitter": "https:\/\/twitter.com\/quoine_SG"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x618e75ac90b12c6049ba3b27f5d5f8651b0037f6#code"
    }, {
      "contractId": 31,
      "title": "RaidenToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Raiden",
      "code": "pragma solidity ^0.4.17;\r\n\r\n\/\/\/ @title ERC223ReceivingContract - Standard contract implementation for compatibility with ERC223 tokens.\r\ncontract ERC223ReceivingContract {\r\n\r\n    \/\/\/ @dev Function that is called when a user or another contract wants to transfer funds.\r\n    \/\/\/ @param _from Transaction initiator, analogue of msg.sender\r\n    \/\/\/ @param _value Number of tokens to transfer.\r\n    \/\/\/ @param _data Data containig a function signature and\/or parameters\r\n    function tokenFallback(address _from, uint256 _value, bytes _data) public;\r\n}\r\n\r\ncontract Token {\r\n    \/*\r\n     * Implements ERC 20 standard.\r\n     * https:\/\/github.com\/ethereum\/EIPs\/blob\/f90864a3d2b2b45c4decf95efd26b3f0c276051a\/EIPS\/eip-20-token-standard.md\r\n     * https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n     *\r\n     *  Added support for the ERC 223 \"tokenFallback\" method in a \"transfer\" function with a payload.\r\n     *  https:\/\/github.com\/ethereum\/EIPs\/issues\/223\r\n     *\/\r\n\r\n    \/*\r\n     * This is a slight change to the ERC20 base standard.\r\n     * function totalSupply() constant returns (uint256 supply);\r\n     * is replaced with:\r\n     * uint256 public totalSupply;\r\n     * This automatically creates a getter function for the totalSupply.\r\n     * This is moved to the base contract since public getter functions are not\r\n     * currently recognised as an implementation of the matching abstract\r\n     * function by the compiler.\r\n     *\/\r\n    uint256 public totalSupply;\r\n\r\n    \/*\r\n     * ERC 20\r\n     *\/\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n    \/*\r\n     * ERC 223\r\n     *\/\r\n    function transfer(address _to, uint256 _value, bytes _data) public returns (bool success);\r\n\r\n    \/*\r\n     * Events\r\n     *\/\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    \/\/ There is no ERC223 compatible Transfer event, with `_data` included.\r\n}\r\n\r\n\r\n\/\/\/ @title Standard token contract - Standard token implementation.\r\ncontract StandardToken is Token {\r\n\r\n    \/*\r\n     * Data structures\r\n     *\/\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    \/*\r\n     * Public functions\r\n     *\/\r\n    \/\/\/ @notice Send `_value` tokens to `_to` from `msg.sender`.\r\n    \/\/\/ @dev Transfers sender's tokens to a given address. Returns success.\r\n    \/\/\/ @param _to Address of token receiver.\r\n    \/\/\/ @param _value Number of tokens to transfer.\r\n    \/\/\/ @return Returns success of function call.\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != 0x0);\r\n        require(_to != address(this));\r\n        require(balances[msg.sender] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]);\r\n\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    \/\/\/ @notice Send `_value` tokens to `_to` from `msg.sender` and trigger\r\n    \/\/\/ tokenFallback if sender is a contract.\r\n    \/\/\/ @dev Function that is called when a user or another contract wants to transfer funds.\r\n    \/\/\/ @param _to Address of token receiver.\r\n    \/\/\/ @param _value Number of tokens to transfer.\r\n    \/\/\/ @param _data Data to be sent to tokenFallback\r\n    \/\/\/ @return Returns success of function call.\r\n    function transfer(\r\n        address _to,\r\n        uint256 _value,\r\n        bytes _data)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(transfer(_to, _value));\r\n\r\n        uint codeLength;\r\n\r\n        assembly {\r\n            \/\/ Retrieve the size of the code on target address, this needs assembly.\r\n            codeLength := extcodesize(_to)\r\n        }\r\n\r\n        if (codeLength > 0) {\r\n            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    \/\/\/ @notice Transfer `_value` tokens from `_from` to `_to` if `msg.sender` is allowed.\r\n    \/\/\/ @dev Allows for an approved third party to transfer tokens from one\r\n    \/\/\/ address to another. Returns success.\r\n    \/\/\/ @param _from Address from where tokens are withdrawn.\r\n    \/\/\/ @param _to Address to where tokens are sent.\r\n    \/\/\/ @param _value Number of tokens to transfer.\r\n    \/\/\/ @return Returns success of function call.\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_from != 0x0);\r\n        require(_to != 0x0);\r\n        require(_to != address(this));\r\n        require(balances[_from] >= _value);\r\n        require(allowed[_from][msg.sender] >= _value);\r\n        require(balances[_to] + _value >= balances[_to]);\r\n\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n\r\n        Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    \/\/\/ @notice Allows `_spender` to transfer `_value` tokens from `msg.sender` to any address.\r\n    \/\/\/ @dev Sets approved amount of tokens for spender. Returns success.\r\n    \/\/\/ @param _spender Address of allowed account.\r\n    \/\/\/ @param _value Number of approved tokens.\r\n    \/\/\/ @return Returns success of function call.\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        require(_spender != 0x0);\r\n\r\n        \/\/ To change the approve amount you first have to reduce the addresses`\r\n        \/\/ allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        \/\/ already 0 to mitigate the race condition described here:\r\n        \/\/ https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\n        require(_value == 0 || allowed[msg.sender][_spender] == 0);\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    \/*\r\n     * Read functions\r\n     *\/\r\n    \/\/\/ @dev Returns number of allowed tokens that a spender can transfer on\r\n    \/\/\/ behalf of a token owner.\r\n    \/\/\/ @param _owner Address of token owner.\r\n    \/\/\/ @param _spender Address of token spender.\r\n    \/\/\/ @return Returns remaining allowance for spender.\r\n    function allowance(address _owner, address _spender)\r\n        constant\r\n        public\r\n        returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    \/\/\/ @dev Returns number of tokens owned by the given address.\r\n    \/\/\/ @param _owner Address of token owner.\r\n    \/\/\/ @return Returns balance of owner.\r\n    function balanceOf(address _owner) constant public returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n}\r\n\r\n\r\n\/\/\/ @title Raiden Token\r\ncontract RaidenToken is StandardToken {\r\n\r\n    \/*\r\n     *  Terminology:\r\n     *  1 token unit = Rei\r\n     *  1 token = RDN = Rei * multiplier\r\n     *  multiplier set from token's number of decimals (i.e. 10 ** decimals)\r\n     *\/\r\n\r\n    \/*\r\n     *  Token metadata\r\n     *\/\r\n    string constant public name = \"Raiden Token\";\r\n    string constant public symbol = \"RDN\";\r\n    uint8 constant public decimals = 18;\r\n    uint constant multiplier = 10 ** uint(decimals);\r\n\r\n    event Deployed(uint indexed _total_supply);\r\n    event Burnt(\r\n        address indexed _receiver,\r\n        uint indexed _num,\r\n        uint indexed _total_supply\r\n    );\r\n\r\n    \/*\r\n     *  Public functions\r\n     *\/\r\n    \/\/\/ @dev Contract constructor function sets dutch auction contract address\r\n    \/\/\/ and assigns all tokens to dutch auction.\r\n    \/\/\/ @param auction_address Address of dutch auction contract.\r\n    \/\/\/ @param wallet_address Address of wallet.\r\n    \/\/\/ @param initial_supply Number of initially provided token units (Rei).\r\n    function RaidenToken(\r\n        address auction_address,\r\n        address wallet_address,\r\n        uint initial_supply)\r\n        public\r\n    {\r\n        \/\/ Auction address should not be null.\r\n        require(auction_address != 0x0);\r\n        require(wallet_address != 0x0);\r\n\r\n        \/\/ Initial supply is in Rei\r\n        require(initial_supply > multiplier);\r\n\r\n        \/\/ Total supply of Rei at deployment\r\n        totalSupply = initial_supply;\r\n\r\n        balances[auction_address] = initial_supply \/ 2;\r\n        balances[wallet_address] = initial_supply \/ 2;\r\n\r\n        Transfer(0x0, auction_address, balances[auction_address]);\r\n        Transfer(0x0, wallet_address, balances[wallet_address]);\r\n\r\n        Deployed(totalSupply);\r\n\r\n        assert(totalSupply == balances[auction_address] + balances[wallet_address]);\r\n    }\r\n\r\n    \/\/\/ @notice Allows `msg.sender` to simply destroy `num` token units (Rei). This means the total\r\n    \/\/\/ token supply will decrease.\r\n    \/\/\/ @dev Allows to destroy token units (Rei).\r\n    \/\/\/ @param num Number of token units (Rei) to burn.\r\n    function burn(uint num) public {\r\n        require(num > 0);\r\n        require(balances[msg.sender] >= num);\r\n        require(totalSupply >= num);\r\n\r\n        uint pre_balance = balances[msg.sender];\r\n\r\n        balances[msg.sender] -= num;\r\n        totalSupply -= num;\r\n        Burnt(msg.sender, num, totalSupply);\r\n        Transfer(msg.sender, 0x0, num);\r\n\r\n        assert(balances[msg.sender] == pre_balance - num);\r\n    }\r\n\r\n}\r\n\r\n\r\n\/\/\/ @title Dutch auction contract - distribution of a fixed number of tokens using an auction.\r\n\/\/\/ The contract code is inspired by the Gnosis auction contract. Main difference is that the\r\n\/\/\/ auction ends if a fixed number of tokens was sold.\r\ncontract DutchAuction {\r\n    \/*\r\n     * Auction for the RDN Token.\r\n     *\r\n     * Terminology:\r\n     * 1 token unit = Rei\r\n     * 1 token = RDN = Rei * token_multiplier\r\n     * token_multiplier set from token's number of decimals (i.e. 10 ** decimals)\r\n     *\/\r\n\r\n    \/\/ Wait 7 days after the end of the auction, before anyone can claim tokens\r\n    uint constant public token_claim_waiting_period = 7 days;\r\n\r\n    \/\/ Bid value over which the address has to be whitelisted\r\n    \/\/ At deployment moment, less than 1k$\r\n    uint constant public bid_threshold = 2.5 ether;\r\n\r\n    \/*\r\n     * Storage\r\n     *\/\r\n\r\n    RaidenToken public token;\r\n    address public owner_address;\r\n    address public wallet_address;\r\n    address public whitelister_address;\r\n\r\n    \/\/ Price decay function parameters to be changed depending on the desired outcome\r\n\r\n    \/\/ Starting price in WEI; e.g. 2 * 10 ** 18\r\n    uint public price_start;\r\n\r\n    \/\/ Divisor constant; e.g. 524880000\r\n    uint public price_constant;\r\n\r\n    \/\/ Divisor exponent; e.g. 3\r\n    uint32 public price_exponent;\r\n\r\n    \/\/ For calculating elapsed time for price\r\n    uint public start_time;\r\n    uint public end_time;\r\n    uint public start_block;\r\n\r\n    \/\/ Keep track of all ETH received in the bids\r\n    uint public received_wei;\r\n\r\n    \/\/ Keep track of cumulative ETH funds for which the tokens have been claimed\r\n    uint public funds_claimed;\r\n\r\n    uint public token_multiplier;\r\n\r\n    \/\/ Total number of Rei (RDN * token_multiplier) that will be auctioned\r\n    uint public num_tokens_auctioned;\r\n\r\n    \/\/ Wei per RDN (Rei * token_multiplier)\r\n    uint public final_price;\r\n\r\n    \/\/ Bidder address => bid value\r\n    mapping (address => uint) public bids;\r\n\r\n    \/\/ Whitelist for addresses that want to bid more than bid_threshold\r\n    mapping (address => bool) public whitelist;\r\n\r\n    Stages public stage;\r\n\r\n    \/*\r\n     * Enums\r\n     *\/\r\n    enum Stages {\r\n        AuctionDeployed,\r\n        AuctionSetUp,\r\n        AuctionStarted,\r\n        AuctionEnded,\r\n        TokensDistributed\r\n    }\r\n\r\n    \/*\r\n     * Modifiers\r\n     *\/\r\n    modifier atStage(Stages _stage) {\r\n        require(stage == _stage);\r\n        _;\r\n    }\r\n\r\n    modifier isOwner() {\r\n        require(msg.sender == owner_address);\r\n        _;\r\n    }\r\n\r\n    modifier isWhitelister() {\r\n        require(msg.sender == whitelister_address);\r\n        _;\r\n    }\r\n\r\n    \/*\r\n     * Events\r\n     *\/\r\n\r\n    event Deployed(\r\n        uint indexed _price_start,\r\n        uint indexed _price_constant,\r\n        uint32 indexed _price_exponent\r\n    );\r\n    event Setup();\r\n    event AuctionStarted(uint indexed _start_time, uint indexed _block_number);\r\n    event BidSubmission(\r\n        address indexed _sender,\r\n        uint _amount,\r\n        uint _missing_funds\r\n    );\r\n    event ClaimedTokens(address indexed _recipient, uint _sent_amount);\r\n    event AuctionEnded(uint _final_price);\r\n    event TokensDistributed();\r\n\r\n    \/*\r\n     * Public functions\r\n     *\/\r\n\r\n    \/\/\/ @dev Contract constructor function sets the starting price, divisor constant and\r\n    \/\/\/ divisor exponent for calculating the Dutch Auction price.\r\n    \/\/\/ @param _wallet_address Wallet address to which all contributed ETH will be forwarded.\r\n    \/\/\/ @param _price_start High price in WEI at which the auction starts.\r\n    \/\/\/ @param _price_constant Auction price divisor constant.\r\n    \/\/\/ @param _price_exponent Auction price divisor exponent.\r\n    function DutchAuction(\r\n        address _wallet_address,\r\n        address _whitelister_address,\r\n        uint _price_start,\r\n        uint _price_constant,\r\n        uint32 _price_exponent)\r\n        public\r\n    {\r\n        require(_wallet_address != 0x0);\r\n        require(_whitelister_address != 0x0);\r\n        wallet_address = _wallet_address;\r\n        whitelister_address = _whitelister_address;\r\n\r\n        owner_address = msg.sender;\r\n        stage = Stages.AuctionDeployed;\r\n        changeSettings(_price_start, _price_constant, _price_exponent);\r\n        Deployed(_price_start, _price_constant, _price_exponent);\r\n    }\r\n\r\n    \/\/\/ @dev Fallback function for the contract, which calls bid() if the auction has started.\r\n    function () public payable atStage(Stages.AuctionStarted) {\r\n        bid();\r\n    }\r\n\r\n    \/\/\/ @notice Set `_token_address` as the token address to be used in the auction.\r\n    \/\/\/ @dev Setup function sets external contracts addresses.\r\n    \/\/\/ @param _token_address Token address.\r\n    function setup(address _token_address) public isOwner atStage(Stages.AuctionDeployed) {\r\n        require(_token_address != 0x0);\r\n        token = RaidenToken(_token_address);\r\n\r\n        \/\/ Get number of Rei (RDN * token_multiplier) to be auctioned from token auction balance\r\n        num_tokens_auctioned = token.balanceOf(address(this));\r\n\r\n        \/\/ Set the number of the token multiplier for its decimals\r\n        token_multiplier = 10 ** uint(token.decimals());\r\n\r\n        stage = Stages.AuctionSetUp;\r\n        Setup();\r\n    }\r\n\r\n    \/\/\/ @notice Set `_price_start`, `_price_constant` and `_price_exponent` as\r\n    \/\/\/ the new starting price, price divisor constant and price divisor exponent.\r\n    \/\/\/ @dev Changes auction price function parameters before auction is started.\r\n    \/\/\/ @param _price_start Updated start price.\r\n    \/\/\/ @param _price_constant Updated price divisor constant.\r\n    \/\/\/ @param _price_exponent Updated price divisor exponent.\r\n    function changeSettings(\r\n        uint _price_start,\r\n        uint _price_constant,\r\n        uint32 _price_exponent)\r\n        internal\r\n    {\r\n        require(stage == Stages.AuctionDeployed || stage == Stages.AuctionSetUp);\r\n        require(_price_start > 0);\r\n        require(_price_constant > 0);\r\n\r\n        price_start = _price_start;\r\n        price_constant = _price_constant;\r\n        price_exponent = _price_exponent;\r\n    }\r\n\r\n    \/\/\/ @notice Adds account addresses to whitelist.\r\n    \/\/\/ @dev Adds account addresses to whitelist.\r\n    \/\/\/ @param _bidder_addresses Array of addresses.\r\n    function addToWhitelist(address[] _bidder_addresses) public isWhitelister {\r\n        for (uint32 i = 0; i < _bidder_addresses.length; i++) {\r\n            whitelist[_bidder_addresses[i]] = true;\r\n        }\r\n    }\r\n\r\n    \/\/\/ @notice Removes account addresses from whitelist.\r\n    \/\/\/ @dev Removes account addresses from whitelist.\r\n    \/\/\/ @param _bidder_addresses Array of addresses.\r\n    function removeFromWhitelist(address[] _bidder_addresses) public isWhitelister {\r\n        for (uint32 i = 0; i < _bidder_addresses.length; i++) {\r\n            whitelist[_bidder_addresses[i]] = false;\r\n        }\r\n    }\r\n\r\n    \/\/\/ @notice Start the auction.\r\n    \/\/\/ @dev Starts auction and sets start_time.\r\n    function startAuction() public isOwner atStage(Stages.AuctionSetUp) {\r\n        stage = Stages.AuctionStarted;\r\n        start_time = now;\r\n        start_block = block.number;\r\n        AuctionStarted(start_time, start_block);\r\n    }\r\n\r\n    \/\/\/ @notice Finalize the auction - sets the final RDN token price and changes the auction\r\n    \/\/\/ stage after no bids are allowed anymore.\r\n    \/\/\/ @dev Finalize auction and set the final RDN token price.\r\n    function finalizeAuction() public atStage(Stages.AuctionStarted)\r\n    {\r\n        \/\/ Missing funds should be 0 at this point\r\n        uint missing_funds = missingFundsToEndAuction();\r\n        require(missing_funds == 0);\r\n\r\n        \/\/ Calculate the final price = WEI \/ RDN = WEI \/ (Rei \/ token_multiplier)\r\n        \/\/ Reminder: num_tokens_auctioned is the number of Rei (RDN * token_multiplier) that are auctioned\r\n        final_price = token_multiplier * received_wei \/ num_tokens_auctioned;\r\n\r\n        end_time = now;\r\n        stage = Stages.AuctionEnded;\r\n        AuctionEnded(final_price);\r\n\r\n        assert(final_price > 0);\r\n    }\r\n\r\n    \/\/\/ --------------------------------- Auction Functions ------------------\r\n\r\n\r\n    \/\/\/ @notice Send `msg.value` WEI to the auction from the `msg.sender` account.\r\n    \/\/\/ @dev Allows to send a bid to the auction.\r\n    function bid()\r\n        public\r\n        payable\r\n        atStage(Stages.AuctionStarted)\r\n    {\r\n        require(msg.value > 0);\r\n        require(bids[msg.sender] + msg.value <= bid_threshold || whitelist[msg.sender]);\r\n        assert(bids[msg.sender] + msg.value >= msg.value);\r\n\r\n        \/\/ Missing funds without the current bid value\r\n        uint missing_funds = missingFundsToEndAuction();\r\n\r\n        \/\/ We require bid values to be less than the funds missing to end the auction\r\n        \/\/ at the current price.\r\n        require(msg.value <= missing_funds);\r\n\r\n        bids[msg.sender] += msg.value;\r\n        received_wei += msg.value;\r\n\r\n        \/\/ Send bid amount to wallet\r\n        wallet_address.transfer(msg.value);\r\n\r\n        BidSubmission(msg.sender, msg.value, missing_funds);\r\n\r\n        assert(received_wei >= msg.value);\r\n    }\r\n\r\n    \/\/\/ @notice Claim auction tokens for `msg.sender` after the auction has ended.\r\n    \/\/\/ @dev Claims tokens for `msg.sender` after auction. To be used if tokens can\r\n    \/\/\/ be claimed by beneficiaries, individually.\r\n    function claimTokens() public atStage(Stages.AuctionEnded) returns (bool) {\r\n        return proxyClaimTokens(msg.sender);\r\n    }\r\n\r\n    \/\/\/ @notice Claim auction tokens for `receiver_address` after the auction has ended.\r\n    \/\/\/ @dev Claims tokens for `receiver_address` after auction has ended.\r\n    \/\/\/ @param receiver_address Tokens will be assigned to this address if eligible.\r\n    function proxyClaimTokens(address receiver_address)\r\n        public\r\n        atStage(Stages.AuctionEnded)\r\n        returns (bool)\r\n    {\r\n        \/\/ Waiting period after the end of the auction, before anyone can claim tokens\r\n        \/\/ Ensures enough time to check if auction was finalized correctly\r\n        \/\/ before users start transacting tokens\r\n        require(now > end_time + token_claim_waiting_period);\r\n        require(receiver_address != 0x0);\r\n\r\n        if (bids[receiver_address] == 0) {\r\n            return false;\r\n        }\r\n\r\n        \/\/ Number of Rei = bid_wei \/ Rei = bid_wei \/ (wei_per_RDN * token_multiplier)\r\n        uint num = (token_multiplier * bids[receiver_address]) \/ final_price;\r\n\r\n        \/\/ Due to final_price floor rounding, the number of assigned tokens may be higher\r\n        \/\/ than expected. Therefore, the number of remaining unassigned auction tokens\r\n        \/\/ may be smaller than the number of tokens needed for the last claimTokens call\r\n        uint auction_tokens_balance = token.balanceOf(address(this));\r\n        if (num > auction_tokens_balance) {\r\n            num = auction_tokens_balance;\r\n        }\r\n\r\n        \/\/ Update the total amount of funds for which tokens have been claimed\r\n        funds_claimed += bids[receiver_address];\r\n\r\n        \/\/ Set receiver bid to 0 before assigning tokens\r\n        bids[receiver_address] = 0;\r\n\r\n        require(token.transfer(receiver_address, num));\r\n\r\n        ClaimedTokens(receiver_address, num);\r\n\r\n        \/\/ After the last tokens are claimed, we change the auction stage\r\n        \/\/ Due to the above logic, rounding errors will not be an issue\r\n        if (funds_claimed == received_wei) {\r\n            stage = Stages.TokensDistributed;\r\n            TokensDistributed();\r\n        }\r\n\r\n        assert(token.balanceOf(receiver_address) >= num);\r\n        assert(bids[receiver_address] == 0);\r\n        return true;\r\n    }\r\n\r\n    \/\/\/ @notice Get the RDN price in WEI during the auction, at the time of\r\n    \/\/\/ calling this function. Returns `0` if auction has ended.\r\n    \/\/\/ Returns `price_start` before auction has started.\r\n    \/\/\/ @dev Calculates the current RDN token price in WEI.\r\n    \/\/\/ @return Returns WEI per RDN (token_multiplier * Rei).\r\n    function price() public constant returns (uint) {\r\n        if (stage == Stages.AuctionEnded ||\r\n            stage == Stages.TokensDistributed) {\r\n            return 0;\r\n        }\r\n        return calcTokenPrice();\r\n    }\r\n\r\n    \/\/\/ @notice Get the missing funds needed to end the auction,\r\n    \/\/\/ calculated at the current RDN price in WEI.\r\n    \/\/\/ @dev The missing funds amount necessary to end the auction at the current RDN price in WEI.\r\n    \/\/\/ @return Returns the missing funds amount in WEI.\r\n    function missingFundsToEndAuction() constant public returns (uint) {\r\n\r\n        \/\/ num_tokens_auctioned = total number of Rei (RDN * token_multiplier) that is auctioned\r\n        uint required_wei_at_price = num_tokens_auctioned * price() \/ token_multiplier;\r\n        if (required_wei_at_price <= received_wei) {\r\n            return 0;\r\n        }\r\n\r\n        \/\/ assert(required_wei_at_price - received_wei > 0);\r\n        return required_wei_at_price - received_wei;\r\n    }\r\n\r\n    \/*\r\n     *  Private functions\r\n     *\/\r\n\r\n    \/\/\/ @dev Calculates the token price (WEI \/ RDN) at the current timestamp\r\n    \/\/\/ during the auction; elapsed time = 0 before auction starts.\r\n    \/\/\/ Based on the provided parameters, the price does not change in the first\r\n    \/\/\/ `price_constant^(1\/price_exponent)` seconds due to rounding.\r\n    \/\/\/ Rounding in `decay_rate` also produces values that increase instead of decrease\r\n    \/\/\/ in the beginning; these spikes decrease over time and are noticeable\r\n    \/\/\/ only in first hours. This should be calculated before usage.\r\n    \/\/\/ @return Returns the token price - Wei per RDN.\r\n    function calcTokenPrice() constant private returns (uint) {\r\n        uint elapsed;\r\n        if (stage == Stages.AuctionStarted) {\r\n            elapsed = now - start_time;\r\n        }\r\n\r\n        uint decay_rate = elapsed ** price_exponent \/ price_constant;\r\n        return price_start * (1 + elapsed) \/ (1 + elapsed + decay_rate);\r\n    }\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/raidennetwork\/",
        "Telegram": "",
        "Website": "https:\/\/raiden.network\/",
        "Email": "mailto:contact@raiden.network",
        "Twitter": "https:\/\/twitter.com\/raiden_network"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x255aa6df07540cb5d3d297f0d0d4d84cb52bc8e6#code"
    }, {
      "contractId": 32,
      "title": "RCNToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "RipioCreditNetwork",
      "code": "pragma solidity ^0.4.11;\r\n\r\ncontract Crowdsale {\r\n    function buyTokens(address _recipient) payable;\r\n}\r\n\r\ncontract CapWhitelist {\r\n    address public owner;\r\n    mapping (address => uint256) public whitelist;\r\n\r\n    event Set(address _address, uint256 _amount);\r\n\r\n    function CapWhitelist() {\r\n        owner = msg.sender;\r\n        \/\/ Set in prod\r\n    }\r\n\r\n    function destruct() {\r\n        require(msg.sender == owner);\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function setWhitelisted(address _address, uint256 _amount) {\r\n        require(msg.sender == owner);\r\n        setWhitelistInternal(_address, _amount);\r\n    }\r\n\r\n    function setWhitelistInternal(address _address, uint256 _amount) private {\r\n        whitelist[_address] = _amount;\r\n        Set(_address, _amount);\r\n    }\r\n}\r\n\r\ncontract Token {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n\/*  ERC 20 token *\/\r\ncontract StandardToken is Token {\r\n    using SafeMath for uint256;\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n      if (balances[msg.sender] >= _value) {\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\r\n        balances[_to] = balances[_to].add(_value);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender,  uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\r\n      allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n      Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n      return true;\r\n    }\r\n\r\n    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\r\n      uint oldValue = allowed[msg.sender][_spender];\r\n      if (_subtractedValue > oldValue) {\r\n        allowed[msg.sender][_spender] = 0;\r\n      } else {\r\n        allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n      }\r\n      Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n      return true;\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  \/**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   *\/\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  \/**\r\n   * @dev Throws if called by any account other than the owner.\r\n   *\/\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  \/**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   *\/\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    \/\/ assert(b > 0); \/\/ Solidity automatically throws when dividing by 0\r\n    uint256 c = a \/ b;\r\n    \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract MintableToken is StandardToken, Ownable {\r\n  using SafeMath for uint256;\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   *\/\r\n  function mint(address _to, uint256 _amount) onlyOwner canMint public {\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    Mint(_to, _amount);\r\n    Transfer(0x0, _to, _amount);\r\n  }\r\n\r\n  \/**\r\n   * @dev Function to stop minting new tokens.\r\n   *\/\r\n  function finishMinting() onlyOwner public {\r\n    mintingFinished = true;\r\n    MintFinished();\r\n  }\r\n}\r\ncontract RCNToken is MintableToken {\r\n    string public constant name = \"Ripio Credit Network Token\";\r\n    string public constant symbol = \"RCN\";\r\n    uint8 public constant decimals = 18;\r\n    string public version = \"1.0\";\r\n}",
      "officialLinks": {
        "Reddit": "",
        "Telegram": "https:\/\/t.me\/RCNtalk",
        "Website": "https:\/\/ripiocredit.network\/",
        "Email": "mailto:info@ripiocredit.network",
        "Twitter": "https:\/\/twitter.com\/RCN_token"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xf970b8e36e23f7fc3fd752eea86f8be8d83375a6#code"
    }, {
      "contractId": 33,
      "title": "RLC",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "RLC",
      "code": "pragma solidity ^0.4.8;\r\n\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    if (msg.sender == owner)\r\n      _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract TokenSpender {\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\r\n}\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a \/ b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n\r\ncontract RLC is ERC20, SafeMath, Ownable {\r\n\r\n    \/* Public variables of the token *\/\r\n  string public name;       \/\/fancy name\r\n  string public symbol;\r\n  uint8 public decimals;    \/\/How many decimals to show.\r\n  string public version = 'v0.1'; \r\n  uint public initialSupply;\r\n  uint public totalSupply;\r\n  bool public locked;\r\n  \/\/uint public unlockBlock;\r\n\r\n  mapping(address => uint) balances;\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  \/\/ lock transfer during the ICO\r\n  modifier onlyUnlocked() {\r\n    if (msg.sender != owner && locked) throw;\r\n    _;\r\n  }\r\n\r\n  \/*\r\n   *  The RLC Token created with the time at which the crowdsale end\r\n   *\/\r\n\r\n  function RLC() {\r\n    \/\/ lock the transfer function during the crowdsale\r\n    locked = true;\r\n    \/\/unlockBlock=  now + 45 days; \/\/ (testnet) - for mainnet put the block number\r\n\r\n    initialSupply = 87000000000000000;\r\n    totalSupply = initialSupply;\r\n    balances[msg.sender] = initialSupply;\/\/ Give the creator all initial tokens                    \r\n    name = 'iEx.ec Network Token';        \/\/ Set the name for display purposes     \r\n    symbol = 'RLC';                       \/\/ Set the symbol for display purposes  \r\n    decimals = 9;                        \/\/ Amount of decimals for display purposes\r\n  }\r\n\r\n  function unlock() onlyOwner {\r\n    locked = false;\r\n  }\r\n\r\n  function burn(uint256 _value) returns (bool){\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value) ;\r\n    totalSupply = safeSub(totalSupply, _value);\r\n    Transfer(msg.sender, 0x0, _value);\r\n    return true;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) onlyUnlocked returns (bool) {\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) onlyUnlocked returns (bool) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n    \r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n    \/* Approve and then comunicate the approved contract in a single tx *\/\r\n  function approveAndCall(address _spender, uint256 _value, bytes _extraData){    \r\n      TokenSpender spender = TokenSpender(_spender);\r\n      if (approve(_spender, _value)) {\r\n          spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n      }\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n  \r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/iexec\/",
        "Telegram": "",
        "Website": "http:\/\/iex.ec\/",
        "Email": "mailto:contact@iex.ec",
        "Twitter": "https:\/\/twitter.com\/iEx_ec"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x607F4C5BB672230e8672085532f7e901544a7375#code"
    }, {
      "contractId": 34,
      "title": "AirSwapToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "AirSwap",
      "code": "pragma solidity ^0.4.11;\r\n\r\n\/\/ See the Github at github.com\/airswap\/contracts\r\n\r\n\/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n *\/\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  \/**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   *\/\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  \/**\r\n   * @dev Throws if called by any account other than the owner.\r\n   *\/\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  \/**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   *\/\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n\/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n *\/\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  \/**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   *\/\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   *\/\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   *\/\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  \/**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   *\/\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\n\r\ncontract Token {\r\n    \/* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    *\/\r\n    \/\/\/ total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    \/\/\/ @param _owner The address from which the balance will be retrieved\r\n    \/\/\/ @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    \/\/\/ @notice send `_value` token to `_to` from `msg.sender`\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _value The amount of token to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    \/\/\/ @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    \/\/\/ @param _from The address of the sender\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _value The amount of token to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    \/\/\/ @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @param _value The amount of tokens to be approved for transfer\r\n    \/\/\/ @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    \/\/\/ @param _owner The address of the account owning tokens\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) public balances; \/\/ *added public\r\n    mapping (address => mapping (address => uint256)) public allowed; \/\/ *added public\r\n}\r\n\r\n\r\n\r\n\r\n\/** @title The AirSwap Token\r\n  * An ERC20-compliant token that is only transferable after a\r\n  * specified time. Holders also have the ability to lock an amount of tokens\r\n  * for a period of time for applications that reference this locked amount\r\n  * for example for licensing features.\r\n  *\/\r\ncontract AirSwapToken is StandardToken, Pausable {\r\n\r\n    string public constant name = \"AirSwap Token\";\r\n    string public constant symbol = \"AST\";\r\n    uint8 public constant decimals = 4;\r\n    uint256 public constant totalSupply = 5000000000000;\r\n\r\n    \/\/ The time after which AirSwap tokens become transferable.\r\n    \/\/ Current value is October 17, 2017 10:10:10 Eastern Time.\r\n    uint256 becomesTransferable = 1508249410;\r\n\r\n    \/\/ The time that tokens are to be locked before becoming unlockable.\r\n    \/\/ Current value is 7 days.\r\n    uint256 lockingPeriod = 604800;\r\n\r\n    \/\/ Prevents premature execution.\r\n    modifier onlyAfter(uint256 _time) {\r\n        require(now >= _time);\r\n        _;\r\n    }\r\n\r\n    \/\/ Prevent premature execution for anyone but the owner.\r\n    modifier onlyAfterOrOwner(uint256 _time, address _from) {\r\n        if (_from != owner) {\r\n            require(now >= _time);\r\n        }\r\n        _;\r\n    }\r\n\r\n    \/\/ Holds the amount and date of a given balance lock.\r\n    struct BalanceLock {\r\n        uint256 amount;\r\n        uint256 unlockDate;\r\n    }\r\n\r\n    \/\/ A mapping of balance lock to a given address.\r\n    mapping (address => BalanceLock) public balanceLocks;\r\n\r\n    \/\/ An event to notify that _owner has locked a balance.\r\n    event BalanceLocked(address indexed _owner, uint256 _oldLockedAmount,\r\n    uint256 _newLockedAmount, uint256 _expiry);\r\n\r\n    \/** @dev Constructor for the contract.\r\n      * @param _deployer The address that will initially hold all tokens.\r\n      * @param _owner The address that will be able to transfer early.\r\n      * @param _balance The initial balance for the owner.\r\n      *\/\r\n    function AirSwapToken(address _deployer, address _owner, uint256 _balance)\r\n        Pausable() {\r\n        transferOwnership(_owner);\r\n        balances[_deployer] = totalSupply - _balance;\r\n        balances[_owner] = _balance;\r\n        Transfer(0x0, _deployer, totalSupply);\r\n        Transfer(_deployer, _owner, _balance);\r\n    }\r\n\r\n    \/** @dev Sets a token balance to be locked by the sender, on the condition\r\n      * that the amount is equal or greater than the previous amount, or if the\r\n      * previous lock time has expired.\r\n      * @param _value The amount be locked.\r\n      *\/\r\n    function lockBalance(uint256 _value) {\r\n\r\n        \/\/ Check if the lock on previously locked tokens is still active.\r\n        if (balanceLocks[msg.sender].unlockDate > now) {\r\n            \/\/ Only allow confirming the lock or adding to it.\r\n            require(_value >= balanceLocks[msg.sender].amount);\r\n        }\r\n        \/\/ Ensure that no more than the balance can be locked.\r\n        require(balances[msg.sender] >= _value);\r\n\r\n        \/\/ Lock tokens and notify.\r\n        uint256 _expiry = now + lockingPeriod;\r\n        BalanceLocked(msg.sender, balanceLocks[msg.sender].amount, _value, _expiry);\r\n        balanceLocks[msg.sender] = BalanceLock(_value, _expiry);\r\n    }\r\n\r\n    \/** @dev Returns the balance that a given address has available for transfer.\r\n      * @param _owner The address of the token owner.\r\n      *\/\r\n    function availableBalance(address _owner) constant returns(uint256) {\r\n        if (balanceLocks[_owner].unlockDate < now) {\r\n            return balances[_owner];\r\n        } else {\r\n            assert(balances[_owner] >= balanceLocks[_owner].amount);\r\n            return balances[_owner] - balanceLocks[_owner].amount;\r\n        }\r\n    }\r\n\r\n    \/** @dev Send `_value` token to `_to` from `msg.sender`, on the condition\r\n      * that there are enough unlocked tokens in the `msg.sender` account.\r\n      * @param _to The address of the recipient.\r\n      * @param _value The amount of token to be transferred.\r\n      * @return Whether the transfer was successful or not.\r\n      *\/\r\n    function transfer(address _to, uint256 _value)\r\n        onlyAfter(becomesTransferable) whenNotPaused\r\n        returns (bool success) {\r\n        require(availableBalance(msg.sender) >= _value);\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    \/** @dev Send `_value` token to `_to` from `_from` on the condition\r\n      * that there are enough unlocked tokens in the `_from` account.\r\n      * @param _from The address of the sender.\r\n      * @param _to The address of the recipient.\r\n      * @param _value The amount of token to be transferred.\r\n      * @return Whether the transfer was successful or not.\r\n      *\/\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        onlyAfterOrOwner(becomesTransferable, _from) whenNotPaused\r\n        returns (bool success) {\r\n        require(availableBalance(_from) >= _value);\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/AirSwap\/",
        "Telegram": "https:\/\/t.me\/airswapofficial",
        "Website": "https:\/\/www.airswap.io\/",
        "Email": "mailto:team@airswap.io",
        "Twitter": "https:\/\/twitter.com\/airswap"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x27054b13b1b798b345b591a4d22e6562d47ea75a#code"
    }, {
      "contractId": 35,
      "title": "Trustcoin",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Trustcoin",
      "code": "\/**\r\n *  TRST Trustcoin contract, ERC20 compliant (see https:\/\/github.com\/ethereum\/EIPs\/issues\/20)\r\n *\r\n *  Code is based on multiple sources:\r\n *  https:\/\/github.com\/OpenZeppelin\/zeppelin-solidity\/blob\/master\/contracts\/token\/ERC20.sol\r\n *  https:\/\/github.com\/ConsenSys\/Tokens\/blob\/master\/Token_Contracts\/contracts\/StandardToken.sol\r\n *  https:\/\/github.com\/ConsenSys\/Tokens\/blob\/master\/Token_Contracts\/contracts\/HumanStandardToken.sol\r\n *\/\r\n\r\n\/\/ Abstract contract for the full ERC 20 Token standard\r\n\/\/ https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n\r\n\/\/ Based on https:\/\/github.com\/ConsenSys\/Tokens\/blob\/master\/Token_Contracts\/contracts\/Token.sol\r\npragma solidity 0.4.8;\r\n\r\ncontract ERC20TokenInterface {\r\n\r\n    \/\/\/ @return The total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply);\r\n\r\n    \/\/\/ @param _owner The address from which the balance will be retrieved\r\n    \/\/\/ @return The balance\r\n    function balanceOf(address _owner) constant public returns (uint256 balance);\r\n\r\n    \/\/\/ @notice send `_value` token to `_to` from `msg.sender`\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _value The amount of token to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    \/\/\/ @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    \/\/\/ @param _from The address of the sender\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _value The amount of token to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    \/\/\/ @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @param _value The amount of tokens to be approved for transfer\r\n    \/\/\/ @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    \/\/\/ @param _owner The address of the account owning tokens\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Trustcoin is ERC20TokenInterface {\r\n\r\n  \/\/\/\/ Constants \/\/\/\/\r\n  string public constant name = 'Trustcoin';\r\n  uint256 public constant decimals = 6;\r\n  string public constant symbol = 'TRST';\r\n  string public constant version = 'TRST1.0';\r\n\r\n  \/\/ One hundred million coins, each divided to up to 10^decimals units.\r\n  uint256 private constant totalTokens = 100000000 * (10 ** decimals);\r\n\r\n  mapping (address => uint256) public balances; \/\/ (ERC20)\r\n  \/\/ A mapping from an account owner to a map from approved spender to their allowances.\r\n  \/\/ (see ERC20 for details about allowances).\r\n  mapping (address => mapping (address => uint256)) public allowed; \/\/ (ERC20)\r\n\r\n  \/\/\/\/ Events \/\/\/\/\r\n  event MigrationInfoSet(string newMigrationInfo);\r\n\r\n  \/\/ This is to be used when migration to a new contract starts.\r\n  \/\/ This string can be used for any authorative information re the migration\r\n  \/\/ (e.g. address to use for migration, or URL to explain where to find more info)\r\n  string public migrationInfo = \"\";\r\n\r\n  \/\/ The only address that can set migrationContractAddress, a secure multisig.\r\n  address public migrationInfoSetter;\r\n\r\n  \/\/\/\/ Modifiers \/\/\/\/\r\n  modifier onlyFromMigrationInfoSetter {\r\n    if (msg.sender != migrationInfoSetter) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  \/\/\/\/ Public functions \/\/\/\/\r\n  function Trustcoin(address _migrationInfoSetter) {\r\n    if (_migrationInfoSetter == 0) throw;\r\n    migrationInfoSetter = _migrationInfoSetter;\r\n    \/\/ Upon creation, all tokens belong to the deployer.\r\n    balances[msg.sender] = totalTokens;\r\n  }\r\n\r\n  \/\/ See ERC20\r\n  function totalSupply() constant returns (uint256) {\r\n    return totalTokens;\r\n  }\r\n\r\n  \/\/ See ERC20\r\n  \/\/ WARNING: If you call this with the address of a contract, the contract will receive the\r\n  \/\/ funds, but will have no idea where they came from. Furthermore, if the contract is\r\n  \/\/ not aware of TRST, the tokens will remain locked away in the contract forever.\r\n  \/\/ It is always recommended to call instead compareAndApprove() (or approve()) and have the\r\n  \/\/ receiving contract withdraw the money using transferFrom().\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    if (balances[msg.sender] >= _value) {\r\n      balances[msg.sender] -= _value;\r\n      balances[_to] += _value;\r\n      Transfer(msg.sender, _to, _value);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  \/\/ See ERC20\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\r\n      balances[_from] -= _value;\r\n      allowed[_from][msg.sender] -= _value;\r\n      balances[_to] += _value;\r\n      Transfer(_from, _to, _value);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  \/\/ See ERC20\r\n  function balanceOf(address _owner) constant public returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  \/\/ See ERC20\r\n  \/\/ NOTE: this method is vulnerable and is placed here only to follow the ERC20 standard.\r\n  \/\/ Before using, please take a look at the better compareAndApprove below.\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  \/\/ A vulernability of the approve method in the ERC20 standard was identified by\r\n  \/\/ Mikhail Vladimirov and Dmitry Khovratovich here:\r\n  \/\/ https:\/\/docs.google.com\/document\/d\/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM\r\n  \/\/ It's better to use this method which is not susceptible to over-withdrawing by the approvee.\r\n  \/\/\/ @param _spender The address to approve\r\n  \/\/\/ @param _currentValue The previous value approved, which can be retrieved with allowance(msg.sender, _spender)\r\n  \/\/\/ @param _newValue The new value to approve, this will replace the _currentValue\r\n  \/\/\/ @return bool Whether the approval was a success (see ERC20's `approve`)\r\n  function compareAndApprove(address _spender, uint256 _currentValue, uint256 _newValue) public returns(bool) {\r\n    if (allowed[msg.sender][_spender] != _currentValue) {\r\n      return false;\r\n    }\r\n    return approve(_spender, _newValue);\r\n  }\r\n\r\n  \/\/ See ERC20\r\n  function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  \/\/ Allows setting a descriptive string, which will aid any users in migrating their token\r\n  \/\/ to a newer version of the contract. This field provides a kind of 'double-layer' of\r\n  \/\/ authentication for any migration announcement, as it can only be set by WeTrust.\r\n  \/\/\/ @param _migrationInfo The information string to be stored on the contract\r\n  function setMigrationInfo(string _migrationInfo) onlyFromMigrationInfoSetter public {\r\n    migrationInfo = _migrationInfo;\r\n    MigrationInfoSet(_migrationInfo);\r\n  }\r\n\r\n  \/\/ To be used if the migrationInfoSetter wishes to transfer the migrationInfoSetter\r\n  \/\/ permission to a new account, e.g. because of change in personnel, a concern that account\r\n  \/\/ may have been compromised etc.\r\n  \/\/\/ @param _newMigrationInfoSetter The address of the new Migration Info Setter\r\n  function changeMigrationInfoSetter(address _newMigrationInfoSetter) onlyFromMigrationInfoSetter public {\r\n    migrationInfoSetter = _newMigrationInfoSetter;\r\n  }\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/WeTrustPlatform\/",
        "Telegram": "",
        "Website": "https:\/\/www.wetrust.io\/",
        "Email": "",
        "Twitter": "https:\/\/twitter.com\/wetrustplatform"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xcb94be6f13a1182e4a4b6140cb7bf2025d28e41b#code"
    }, {
      "contractId": 36,
      "title": "TAAS",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "TAAS",
      "code": "pragma solidity 0.4.8;\r\n\r\ncontract EToken2 {\r\n    function baseUnit(bytes32 _symbol) constant returns(uint8);\r\n    function name(bytes32 _symbol) constant returns(string);\r\n    function description(bytes32 _symbol) constant returns(string);\r\n    function owner(bytes32 _symbol) constant returns(address);\r\n    function isOwner(address _owner, bytes32 _symbol) constant returns(bool);\r\n    function totalSupply(bytes32 _symbol) constant returns(uint);\r\n    function balanceOf(address _holder, bytes32 _symbol) constant returns(uint);\r\n    function proxyTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference, address _sender) returns(bool);\r\n    function proxyApprove(address _spender, uint _value, bytes32 _symbol, address _sender) returns(bool);\r\n    function allowance(address _from, address _spender, bytes32 _symbol) constant returns(uint);\r\n    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference, address _sender) returns(bool);\r\n}\r\n\r\ncontract Asset {\r\n    function _performTransferWithReference(address _to, uint _value, string _reference, address _sender) returns(bool);\r\n    function _performTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference, address _sender) returns(bool);\r\n    function _performApprove(address _spender, uint _value, address _sender) returns(bool);    \r\n    function _performTransferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) returns(bool);\r\n    function _performTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference, address _sender) returns(bool);\r\n    function _performGeneric(bytes _data, address _sender) payable returns(bytes32) {\r\n        throw;\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n\r\n    function totalSupply() constant returns(uint256 supply);\r\n    function balanceOf(address _owner) constant returns(uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns(bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns(bool success);\r\n    function approve(address _spender, uint256 _value) returns(bool success);\r\n    function allowance(address _owner, address _spender) constant returns(uint256 remaining);\r\n    function decimals() constant returns(uint8);\r\n}\r\n\r\ncontract AssetProxyInterface {\r\n    function _forwardApprove(address _spender, uint _value, address _sender) returns(bool);    \r\n    function _forwardTransferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) returns(bool);\r\n    function _forwardTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference, address _sender) returns(bool);\r\n}\r\n\r\ncontract Bytes32 {\r\n    function _bytes32(string _input) internal constant returns(bytes32 result) {\r\n        assembly {\r\n            result := mload(add(_input, 32))\r\n        }\r\n    }\r\n}\r\n\r\n\/**\r\n * @title EToken2 Asset Proxy.\r\n *\r\n * Proxy implements ERC20 interface and acts as a gateway to a single EToken2 asset.\r\n * Proxy adds etoken2Symbol and caller(sender) when forwarding requests to EToken2.\r\n * Every request that is made by caller first sent to the specific asset implementation\r\n * contract, which then calls back to be forwarded onto EToken2.\r\n *\r\n * Calls flow: Caller ->\r\n *             Proxy.func(...) ->\r\n *             Asset._performFunc(..., Caller.address) ->\r\n *             Proxy._forwardFunc(..., Caller.address) ->\r\n *             Platform.proxyFunc(..., symbol, Caller.address)\r\n *\r\n * Generic call flow: Caller ->\r\n *             Proxy.unknownFunc(...) ->\r\n *             Asset._performGeneric(..., Caller.address) ->\r\n *             Asset.unknownFunc(...)\r\n *\r\n * Asset implementation contract is mutable, but each user have an option to stick with\r\n * old implementation, through explicit decision made in timely manner, if he doesn't agree\r\n * with new rules.\r\n * Each user have a possibility to upgrade to latest asset contract implementation, without the\r\n * possibility to rollback.\r\n *\r\n * Note: all the non constant functions return false instead of throwing in case if state change\r\n * didn't happen yet.\r\n *\/\r\ncontract TAAS is ERC20, AssetProxyInterface, Bytes32 {\r\n    \/\/ Assigned EToken2, immutable.\r\n    EToken2 public etoken2;\r\n\r\n    \/\/ Assigned symbol, immutable.\r\n    bytes32 public etoken2Symbol;\r\n\r\n    \/\/ Assigned name, immutable. For UI.\r\n    string public name;\r\n    string public symbol;\r\n\r\n    \/**\r\n     * Sets EToken2 address, assigns symbol and name.\r\n     *\r\n     * Can be set only once.\r\n     *\r\n     * @param _etoken2 EToken2 contract address.\r\n     * @param _symbol assigned symbol.\r\n     * @param _name assigned name.\r\n     *\r\n     * @return success.\r\n     *\/\r\n    function init(EToken2 _etoken2, string _symbol, string _name) returns(bool) {\r\n        if (address(etoken2) != 0x0) {\r\n            return false;\r\n        }\r\n        etoken2 = _etoken2;\r\n        etoken2Symbol = _bytes32(_symbol);\r\n        name = _name;\r\n        symbol = _symbol;\r\n        return true;\r\n    }\r\n\r\n    \/**\r\n     * Only EToken2 is allowed to call.\r\n     *\/\r\n    modifier onlyEToken2() {\r\n        if (msg.sender == address(etoken2)) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    \/**\r\n     * Only current asset owner is allowed to call.\r\n     *\/\r\n    modifier onlyAssetOwner() {\r\n        if (etoken2.isOwner(msg.sender, etoken2Symbol)) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    \/**\r\n     * Returns asset implementation contract for current caller.\r\n     *\r\n     * @return asset implementation contract.\r\n     *\/\r\n    function _getAsset() internal returns(Asset) {\r\n        return Asset(getVersionFor(msg.sender));\r\n    }\r\n\r\n    function recoverTokens(uint _value) onlyAssetOwner() returns(bool) {\r\n        return this.transferWithReference(msg.sender, _value, 'Tokens recovery');\r\n    }\r\n\r\n    \/**\r\n     * Returns asset total supply.\r\n     *\r\n     * @return asset total supply.\r\n     *\/\r\n    function totalSupply() constant returns(uint) {\r\n        return etoken2.totalSupply(etoken2Symbol);\r\n    }\r\n\r\n    \/**\r\n     * Returns asset balance for a particular holder.\r\n     *\r\n     * @param _owner holder address.\r\n     *\r\n     * @return holder balance.\r\n     *\/\r\n    function balanceOf(address _owner) constant returns(uint) {\r\n        return etoken2.balanceOf(_owner, etoken2Symbol);\r\n    }\r\n\r\n    \/**\r\n     * Returns asset allowance from one holder to another.\r\n     *\r\n     * @param _from holder that allowed spending.\r\n     * @param _spender holder that is allowed to spend.\r\n     *\r\n     * @return holder to spender allowance.\r\n     *\/\r\n    function allowance(address _from, address _spender) constant returns(uint) {\r\n        return etoken2.allowance(_from, _spender, etoken2Symbol);\r\n    }\r\n\r\n    \/**\r\n     * Returns asset decimals.\r\n     *\r\n     * @return asset decimals.\r\n     *\/\r\n    function decimals() constant returns(uint8) {\r\n        return etoken2.baseUnit(etoken2Symbol);\r\n    }\r\n\r\n    \/**\r\n     * Transfers asset balance from the caller to specified receiver.\r\n     *\r\n     * @param _to holder address to give to.\r\n     * @param _value amount to transfer.\r\n     *\r\n     * @return success.\r\n     *\/\r\n    function transfer(address _to, uint _value) returns(bool) {\r\n        return transferWithReference(_to, _value, '');\r\n    }\r\n\r\n    \/**\r\n     * Transfers asset balance from the caller to specified receiver adding specified comment.\r\n     * Resolves asset implementation contract for the caller and forwards there arguments along with\r\n     * the caller address.\r\n     *\r\n     * @param _to holder address to give to.\r\n     * @param _value amount to transfer.\r\n     * @param _reference transfer comment to be included in a EToken2's Transfer event.\r\n     *\r\n     * @return success.\r\n     *\/\r\n    function transferWithReference(address _to, uint _value, string _reference) returns(bool) {\r\n        return _getAsset()._performTransferWithReference(_to, _value, _reference, msg.sender);\r\n    }\r\n\r\n    \/**\r\n     * Transfers asset balance from the caller to specified ICAP.\r\n     *\r\n     * @param _icap recipient ICAP to give to.\r\n     * @param _value amount to transfer.\r\n     *\r\n     * @return success.\r\n     *\/\r\n    function transferToICAP(bytes32 _icap, uint _value) returns(bool) {\r\n        return transferToICAPWithReference(_icap, _value, '');\r\n    }\r\n\r\n    \/**\r\n     * Transfers asset balance from the caller to specified ICAP adding specified comment.\r\n     * Resolves asset implementation contract for the caller and forwards there arguments along with\r\n     * the caller address.\r\n     *\r\n     * @param _icap recipient ICAP to give to.\r\n     * @param _value amount to transfer.\r\n     * @param _reference transfer comment to be included in a EToken2's Transfer event.\r\n     *\r\n     * @return success.\r\n     *\/\r\n    function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) {\r\n        return _getAsset()._performTransferToICAPWithReference(_icap, _value, _reference, msg.sender);\r\n    }\r\n\r\n    \/**\r\n     * Prforms allowance transfer of asset balance between holders.\r\n     *\r\n     * @param _from holder address to take from.\r\n     * @param _to holder address to give to.\r\n     * @param _value amount to transfer.\r\n     *\r\n     * @return success.\r\n     *\/\r\n    function transferFrom(address _from, address _to, uint _value) returns(bool) {\r\n        return transferFromWithReference(_from, _to, _value, '');\r\n    }\r\n\r\n    \/**\r\n     * Prforms allowance transfer of asset balance between holders adding specified comment.\r\n     * Resolves asset implementation contract for the caller and forwards there arguments along with\r\n     * the caller address.\r\n     *\r\n     * @param _from holder address to take from.\r\n     * @param _to holder address to give to.\r\n     * @param _value amount to transfer.\r\n     * @param _reference transfer comment to be included in a EToken2's Transfer event.\r\n     *\r\n     * @return success.\r\n     *\/\r\n    function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) {\r\n        return _getAsset()._performTransferFromWithReference(_from, _to, _value, _reference, msg.sender);\r\n    }\r\n\r\n    \/**\r\n     * Performs transfer call on the EToken2 by the name of specified sender.\r\n     *\r\n     * Can only be called by asset implementation contract assigned to sender.\r\n     *\r\n     * @param _from holder address to take from.\r\n     * @param _to holder address to give to.\r\n     * @param _value amount to transfer.\r\n     * @param _reference transfer comment to be included in a EToken2's Transfer event.\r\n     * @param _sender initial caller.\r\n     *\r\n     * @return success.\r\n     *\/\r\n    function _forwardTransferFromWithReference(address _from, address _to, uint _value, string _reference, address _sender) onlyImplementationFor(_sender) returns(bool) {\r\n        return etoken2.proxyTransferFromWithReference(_from, _to, _value, etoken2Symbol, _reference, _sender);\r\n    }\r\n\r\n    \/**\r\n     * Prforms allowance transfer of asset balance between holders.\r\n     *\r\n     * @param _from holder address to take from.\r\n     * @param _icap recipient ICAP address to give to.\r\n     * @param _value amount to transfer.\r\n     *\r\n     * @return success.\r\n     *\/\r\n    function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) {\r\n        return transferFromToICAPWithReference(_from, _icap, _value, '');\r\n    }\r\n\r\n    \/**\r\n     * Prforms allowance transfer of asset balance between holders adding specified comment.\r\n     * Resolves asset implementation contract for the caller and forwards there arguments along with\r\n     * the caller address.\r\n     *\r\n     * @param _from holder address to take from.\r\n     * @param _icap recipient ICAP address to give to.\r\n     * @param _value amount to transfer.\r\n     * @param _reference transfer comment to be included in a EToken2's Transfer event.\r\n     *\r\n     * @return success.\r\n     *\/\r\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) {\r\n        return _getAsset()._performTransferFromToICAPWithReference(_from, _icap, _value, _reference, msg.sender);\r\n    }\r\n\r\n    \/**\r\n     * Performs allowance transfer to ICAP call on the EToken2 by the name of specified sender.\r\n     *\r\n     * Can only be called by asset implementation contract assigned to sender.\r\n     *\r\n     * @param _from holder address to take from.\r\n     * @param _icap recipient ICAP address to give to.\r\n     * @param _value amount to transfer.\r\n     * @param _reference transfer comment to be included in a EToken2's Transfer event.\r\n     * @param _sender initial caller.\r\n     *\r\n     * @return success.\r\n     *\/\r\n    function _forwardTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference, address _sender) onlyImplementationFor(_sender) returns(bool) {\r\n        return etoken2.proxyTransferFromToICAPWithReference(_from, _icap, _value, _reference, _sender);\r\n    }\r\n\r\n    \/**\r\n     * Sets asset spending allowance for a specified spender.\r\n     * Resolves asset implementation contract for the caller and forwards there arguments along with\r\n     * the caller address.\r\n     *\r\n     * @param _spender holder address to set allowance to.\r\n     * @param _value amount to allow.\r\n     *\r\n     * @return success.\r\n     *\/\r\n    function approve(address _spender, uint _value) returns(bool) {\r\n        return _getAsset()._performApprove(_spender, _value, msg.sender);\r\n    }\r\n\r\n    \/**\r\n     * Performs allowance setting call on the EToken2 by the name of specified sender.\r\n     *\r\n     * Can only be called by asset implementation contract assigned to sender.\r\n     *\r\n     * @param _spender holder address to set allowance to.\r\n     * @param _value amount to allow.\r\n     * @param _sender initial caller.\r\n     *\r\n     * @return success.\r\n     *\/\r\n    function _forwardApprove(address _spender, uint _value, address _sender) onlyImplementationFor(_sender) returns(bool) {\r\n        return etoken2.proxyApprove(_spender, _value, etoken2Symbol, _sender);\r\n    }\r\n\r\n    \/**\r\n     * Emits ERC20 Transfer event on this contract.\r\n     *\r\n     * Can only be, and, called by assigned EToken2 when asset transfer happens.\r\n     *\/\r\n    function emitTransfer(address _from, address _to, uint _value) onlyEToken2() {\r\n        Transfer(_from, _to, _value);\r\n    }\r\n\r\n    \/**\r\n     * Emits ERC20 Approval event on this contract.\r\n     *\r\n     * Can only be, and, called by assigned EToken2 when asset allowance set happens.\r\n     *\/\r\n    function emitApprove(address _from, address _spender, uint _value) onlyEToken2() {\r\n        Approval(_from, _spender, _value);\r\n    }\r\n\r\n    \/**\r\n     * Resolves asset implementation contract for the caller and forwards there transaction data,\r\n     * along with the value. This allows for proxy interface growth.\r\n     *\/\r\n    function () payable {\r\n        bytes32 result = _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);\r\n        assembly {\r\n            mstore(0, result)\r\n            return(0, 32)\r\n        }\r\n    }\r\n\r\n    \/**\r\n     * Indicates an upgrade freeze-time start, and the next asset implementation contract.\r\n     *\/\r\n    event UpgradeProposal(address newVersion);\r\n\r\n    \/\/ Current asset implementation contract address.\r\n    address latestVersion;\r\n\r\n    \/\/ Proposed next asset implementation contract address.\r\n    address pendingVersion;\r\n\r\n    \/\/ Upgrade freeze-time start.\r\n    uint pendingVersionTimestamp;\r\n\r\n    \/\/ Timespan for users to review the new implementation and make decision.\r\n    uint constant UPGRADE_FREEZE_TIME = 3 days;\r\n\r\n    \/\/ Asset implementation contract address that user decided to stick with.\r\n    \/\/ 0x0 means that user uses latest version.\r\n    mapping(address => address) userOptOutVersion;\r\n\r\n    \/**\r\n     * Only asset implementation contract assigned to sender is allowed to call.\r\n     *\/\r\n    modifier onlyImplementationFor(address _sender) {\r\n        if (getVersionFor(_sender) == msg.sender) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    \/**\r\n     * Returns asset implementation contract address assigned to sender.\r\n     *\r\n     * @param _sender sender address.\r\n     *\r\n     * @return asset implementation contract address.\r\n     *\/\r\n    function getVersionFor(address _sender) constant returns(address) {\r\n        return userOptOutVersion[_sender] == 0 ? latestVersion : userOptOutVersion[_sender];\r\n    }\r\n\r\n    \/**\r\n     * Returns current asset implementation contract address.\r\n     *\r\n     * @return asset implementation contract address.\r\n     *\/\r\n    function getLatestVersion() constant returns(address) {\r\n        return latestVersion;\r\n    }\r\n\r\n    \/**\r\n     * Returns proposed next asset implementation contract address.\r\n     *\r\n     * @return asset implementation contract address.\r\n     *\/\r\n    function getPendingVersion() constant returns(address) {\r\n        return pendingVersion;\r\n    }\r\n\r\n    \/**\r\n     * Returns upgrade freeze-time start.\r\n     *\r\n     * @return freeze-time start.\r\n     *\/\r\n    function getPendingVersionTimestamp() constant returns(uint) {\r\n        return pendingVersionTimestamp;\r\n    }\r\n\r\n    \/**\r\n     * Propose next asset implementation contract address.\r\n     *\r\n     * Can only be called by current asset owner.\r\n     *\r\n     * Note: freeze-time should not be applied for the initial setup.\r\n     *\r\n     * @param _newVersion asset implementation contract address.\r\n     *\r\n     * @return success.\r\n     *\/\r\n    function proposeUpgrade(address _newVersion) onlyAssetOwner() returns(bool) {\r\n        \/\/ Should not already be in the upgrading process.\r\n        if (pendingVersion != 0x0) {\r\n            return false;\r\n        }\r\n        \/\/ New version address should be other than 0x0.\r\n        if (_newVersion == 0x0) {\r\n            return false;\r\n        }\r\n        \/\/ Don't apply freeze-time for the initial setup.\r\n        if (latestVersion == 0x0) {\r\n            latestVersion = _newVersion;\r\n            return true;\r\n        }\r\n        pendingVersion = _newVersion;\r\n        pendingVersionTimestamp = now;\r\n        UpgradeProposal(_newVersion);\r\n        return true;\r\n    }\r\n\r\n    \/**\r\n     * Cancel the pending upgrade process.\r\n     *\r\n     * Can only be called by current asset owner.\r\n     *\r\n     * @return success.\r\n     *\/\r\n    function purgeUpgrade() onlyAssetOwner() returns(bool) {\r\n        if (pendingVersion == 0x0) {\r\n            return false;\r\n        }\r\n        delete pendingVersion;\r\n        delete pendingVersionTimestamp;\r\n        return true;\r\n    }\r\n\r\n    \/**\r\n     * Finalize an upgrade process setting new asset implementation contract address.\r\n     *\r\n     * Can only be called after an upgrade freeze-time.\r\n     *\r\n     * @return success.\r\n     *\/\r\n    function commitUpgrade() returns(bool) {\r\n        if (pendingVersion == 0x0) {\r\n            return false;\r\n        }\r\n        if (pendingVersionTimestamp + UPGRADE_FREEZE_TIME > now) {\r\n            return false;\r\n        }\r\n        latestVersion = pendingVersion;\r\n        delete pendingVersion;\r\n        delete pendingVersionTimestamp;\r\n        return true;\r\n    }\r\n\r\n    \/**\r\n     * Disagree with proposed upgrade, and stick with current asset implementation\r\n     * until further explicit agreement to upgrade.\r\n     *\r\n     * @return success.\r\n     *\/\r\n    function optOut() returns(bool) {\r\n        if (userOptOutVersion[msg.sender] != 0x0) {\r\n            return false;\r\n        }\r\n        userOptOutVersion[msg.sender] = latestVersion;\r\n        return true;\r\n    }\r\n\r\n    \/**\r\n     * Implicitly agree to upgrade to current and future asset implementation upgrades,\r\n     * until further explicit disagreement.\r\n     *\r\n     * @return success.\r\n     *\/\r\n    function optIn() returns(bool) {\r\n        delete userOptOutVersion[msg.sender];\r\n        return true;\r\n    }\r\n\r\n    \/\/ Backwards compatibility.\r\n    function multiAsset() constant returns(EToken2) {\r\n        return etoken2;\r\n    }\r\n}",
      "officialLinks": {
        "Reddit": "",
        "Telegram": "https:\/\/t.me\/taasfund",
        "Website": "https:\/\/taas.fund",
        "Email": "",
        "Twitter": "https:\/\/twitter.com\/TaaSfund"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xe7775a6e9bcf904eb39da2b68c5efb4f9360e08c#code"
    }, {
      "contractId": 37,
      "title": "LunyrToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Lunyr",
      "code": "pragma solidity ^0.4.8;\r\n\r\n\/\/ accepted from zeppelin-solidity https:\/\/github.com\/OpenZeppelin\/zeppelin-solidity\r\n\/*\r\n * ERC20 interface\r\n * see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n *\/\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n\/\/ accepted from zeppelin-solidity https:\/\/github.com\/OpenZeppelin\/zeppelin-solidity\r\n\r\n\/**\r\n * Math operations with safety checks\r\n *\/\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a \/ b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n\/\/\/ @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\r\n\/\/\/ @author Stefan George - <[email\u00a0protected]>\r\ncontract MultiSigWallet {\r\n\r\n    \/\/ flag to determine if address is for a real contract or not\r\n    bool public isMultiSigWallet = false;\r\n\r\n    uint constant public MAX_OWNER_COUNT = 50;\r\n\r\n    event Confirmation(address indexed sender, uint indexed transactionId);\r\n    event Revocation(address indexed sender, uint indexed transactionId);\r\n    event Submission(uint indexed transactionId);\r\n    event Execution(uint indexed transactionId);\r\n    event ExecutionFailure(uint indexed transactionId);\r\n    event Deposit(address indexed sender, uint value);\r\n    event OwnerAddition(address indexed owner);\r\n    event OwnerRemoval(address indexed owner);\r\n    event RequirementChange(uint required);\r\n\r\n    mapping (uint => Transaction) public transactions;\r\n    mapping (uint => mapping (address => bool)) public confirmations;\r\n    mapping (address => bool) public isOwner;\r\n    address[] public owners;\r\n    uint public required;\r\n    uint public transactionCount;\r\n\r\n    struct Transaction {\r\n        address destination;\r\n        uint value;\r\n        bytes data;\r\n        bool executed;\r\n    }\r\n\r\n    modifier onlyWallet() {\r\n        if (msg.sender != address(this)) throw;\r\n        _;\r\n    }\r\n\r\n    modifier ownerDoesNotExist(address owner) {\r\n        if (isOwner[owner]) throw;\r\n        _;\r\n    }\r\n\r\n    modifier ownerExists(address owner) {\r\n        if (!isOwner[owner]) throw;\r\n        _;\r\n    }\r\n\r\n    modifier transactionExists(uint transactionId) {\r\n        if (transactions[transactionId].destination == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier confirmed(uint transactionId, address owner) {\r\n        if (!confirmations[transactionId][owner]) throw;\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmed(uint transactionId, address owner) {\r\n        if (confirmations[transactionId][owner]) throw;\r\n        _;\r\n    }\r\n\r\n    modifier notExecuted(uint transactionId) {\r\n        if (transactions[transactionId].executed) throw;\r\n        _;\r\n    }\r\n\r\n    modifier notNull(address _address) {\r\n        if (_address == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier validRequirement(uint ownerCount, uint _required) {\r\n        if (ownerCount > MAX_OWNER_COUNT) throw;\r\n        if (_required > ownerCount) throw;\r\n        if (_required == 0) throw;\r\n        if (ownerCount == 0) throw;\r\n        _;\r\n    }\r\n\r\n    \/\/\/ @dev Fallback function allows to deposit ether.\r\n    function()\r\n        payable\r\n    {\r\n        if (msg.value > 0)\r\n            Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    \/*\r\n     * Public functions\r\n     *\/\r\n    \/\/\/ @dev Contract constructor sets initial owners and required number of confirmations.\r\n    \/\/\/ @param _owners List of initial owners.\r\n    \/\/\/ @param _required Number of required confirmations.\r\n    function MultiSigWallet(address[] _owners, uint _required)\r\n        public\r\n        validRequirement(_owners.length, _required)\r\n    {\r\n        for (uint i=0; i<_owners.length; i++) {\r\n            if (isOwner[_owners[i]] || _owners[i] == 0) throw;\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n        isMultiSigWallet = true;\r\n        owners = _owners;\r\n        required = _required;\r\n    }\r\n\r\n    \/\/\/ @dev Allows to add a new owner. Transaction has to be sent by wallet.\r\n    \/\/\/ @param owner Address of new owner.\r\n    function addOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerDoesNotExist(owner)\r\n        notNull(owner)\r\n        validRequirement(owners.length + 1, required)\r\n    {\r\n        isOwner[owner] = true;\r\n        owners.push(owner);\r\n        OwnerAddition(owner);\r\n    }\r\n\r\n    \/\/\/ @dev Allows to remove an owner. Transaction has to be sent by wallet.\r\n    \/\/\/ @param owner Address of owner.\r\n    function removeOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n    {\r\n        isOwner[owner] = false;\r\n        for (uint i=0; i<owners.length - 1; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }\r\n        owners.length -= 1;\r\n        if (required > owners.length)\r\n            changeRequirement(owners.length);\r\n        OwnerRemoval(owner);\r\n    }\r\n\r\n    \/\/\/ @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\r\n    \/\/\/ @param owner Address of owner to be replaced.\r\n    \/\/\/ @param newOwner Address of new owner.\r\n    \/\/\/ @param index the indx of the owner to be replaced\r\n    function replaceOwnerIndexed(address owner, address newOwner, uint index)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n        ownerDoesNotExist(newOwner)\r\n    {\r\n        if (owners[index] != owner) throw;\r\n        owners[index] = newOwner;\r\n        isOwner[owner] = false;\r\n        isOwner[newOwner] = true;\r\n        OwnerRemoval(owner);\r\n        OwnerAddition(newOwner);\r\n    }\r\n\r\n\r\n    \/\/\/ @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\r\n    \/\/\/ @param _required Number of required confirmations.\r\n    function changeRequirement(uint _required)\r\n        public\r\n        onlyWallet\r\n        validRequirement(owners.length, _required)\r\n    {\r\n        required = _required;\r\n        RequirementChange(_required);\r\n    }\r\n\r\n    \/\/\/ @dev Allows an owner to submit and confirm a transaction.\r\n    \/\/\/ @param destination Transaction target address.\r\n    \/\/\/ @param value Transaction ether value.\r\n    \/\/\/ @param data Transaction data payload.\r\n    \/\/\/ @return Returns transaction ID.\r\n    function submitTransaction(address destination, uint value, bytes data)\r\n        public\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = addTransaction(destination, value, data);\r\n        confirmTransaction(transactionId);\r\n    }\r\n\r\n    \/\/\/ @dev Allows an owner to confirm a transaction.\r\n    \/\/\/ @param transactionId Transaction ID.\r\n    function confirmTransaction(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        transactionExists(transactionId)\r\n        notConfirmed(transactionId, msg.sender)\r\n    {\r\n        confirmations[transactionId][msg.sender] = true;\r\n        Confirmation(msg.sender, transactionId);\r\n        executeTransaction(transactionId);\r\n    }\r\n\r\n    \/\/\/ @dev Allows an owner to revoke a confirmation for a transaction.\r\n    \/\/\/ @param transactionId Transaction ID.\r\n    function revokeConfirmation(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        confirmations[transactionId][msg.sender] = false;\r\n        Revocation(msg.sender, transactionId);\r\n    }\r\n\r\n    \/\/\/ @dev Returns the confirmation status of a transaction.\r\n    \/\/\/ @param transactionId Transaction ID.\r\n    \/\/\/ @return Confirmation status.\r\n    function isConfirmed(uint transactionId)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        uint count = 0;\r\n        for (uint i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }\r\n    }\r\n\r\n    \/*\r\n     * Internal functions\r\n     *\/\r\n\r\n    \/\/\/ @dev Allows anyone to execute a confirmed transaction.\r\n    \/\/\/ @param transactionId Transaction ID.\r\n    function executeTransaction(uint transactionId)\r\n       internal\r\n       notExecuted(transactionId)\r\n    {\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction tx = transactions[transactionId];\r\n            tx.executed = true;\r\n            if (tx.destination.call.value(tx.value)(tx.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                tx.executed = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    \/\/\/ @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n    \/\/\/ @param destination Transaction target address.\r\n    \/\/\/ @param value Transaction ether value.\r\n    \/\/\/ @param data Transaction data payload.\r\n    \/\/\/ @return Returns transaction ID.\r\n    function addTransaction(address destination, uint value, bytes data)\r\n        internal\r\n        notNull(destination)\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = transactionCount;\r\n        transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false\r\n        });\r\n        transactionCount += 1;\r\n        Submission(transactionId);\r\n    }\r\n\r\n    \/*\r\n     * Web3 call functions\r\n     *\/\r\n    \/\/\/ @dev Returns number of confirmations of a transaction.\r\n    \/\/\/ @param transactionId Transaction ID.\r\n    \/\/\/ @return Number of confirmations.\r\n    function getConfirmationCount(uint transactionId)\r\n        public\r\n        constant\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n    }\r\n\r\n    \/\/\/ @dev Returns total number of transactions after filers are applied.\r\n    \/\/\/ @param pending Include pending transactions.\r\n    \/\/\/ @param executed Include executed transactions.\r\n    \/\/\/ @return Total number of transactions after filters are applied.\r\n    function getTransactionCount(bool pending, bool executed)\r\n        public\r\n        constant\r\n        returns (uint count)\r\n    {\r\n        for (uint i=0; i<transactionCount; i++)\r\n            if ((pending && !transactions[i].executed) ||\r\n                (executed && transactions[i].executed))\r\n                count += 1;\r\n    }\r\n\r\n    \/\/\/ @dev Returns list of owners.\r\n    \/\/\/ @return List of owner addresses.\r\n    function getOwners()\r\n        public\r\n        constant\r\n        returns (address[])\r\n    {\r\n        return owners;\r\n    }\r\n\r\n    \/\/\/ @dev Returns array with owner addresses, which confirmed transaction.\r\n    \/\/\/ @param transactionId Transaction ID.\r\n    \/\/\/ @return Returns array of owner addresses.\r\n    function getConfirmations(uint transactionId)\r\n        public\r\n        constant\r\n        returns (address[] _confirmations)\r\n    {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        _confirmations = new address[](count);\r\n        for (i=0; i<count; i++)\r\n            _confirmations[i] = confirmationsTemp[i];\r\n    }\r\n\r\n    \/\/\/ @dev Returns list of transaction IDs in defined range.\r\n    \/\/\/ @param from Index start position of transaction array.\r\n    \/\/\/ @param to Index end position of transaction array.\r\n    \/\/\/ @param pending Include pending transactions.\r\n    \/\/\/ @param executed Include executed transactions.\r\n    \/\/\/ @return Returns array of transaction IDs.\r\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n        public\r\n        constant\r\n        returns (uint[] _transactionIds)\r\n    {\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<transactionCount; i++)\r\n          if ((pending && !transactions[i].executed) ||\r\n              (executed && transactions[i].executed))\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        _transactionIds = new uint[](to - from);\r\n        for (i=from; i<to; i++)\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract NewToken is ERC20 {}\r\n\r\ncontract UpgradeAgent is SafeMath {\r\n  address public owner;\r\n  bool public isUpgradeAgent;\r\n  NewToken public newToken;\r\n  uint256 public originalSupply; \/\/ the original total supply of old tokens\r\n  bool public upgradeHasBegun;\r\n  function upgradeFrom(address _from, uint256 _value) public;\r\n}\r\n\r\n\/\/\/ @title Time-locked vault of tokens allocated to Lunyr after 180 days\r\ncontract LUNVault is SafeMath {\r\n\r\n    \/\/ flag to determine if address is for a real contract or not\r\n    bool public isLUNVault = false;\r\n\r\n    LunyrToken lunyrToken;\r\n    address lunyrMultisig;\r\n    uint256 unlockedAtBlockNumber;\r\n    \/\/uint256 public constant numBlocksLocked = 1110857;\r\n    \/\/ smaller lock for testing\r\n    uint256 public constant numBlocksLocked = 1110857;\r\n\r\n    \/\/\/ @notice Constructor function sets the Lunyr Multisig address and\r\n    \/\/\/ total number of locked tokens to transfer\r\n    function LUNVault(address _lunyrMultisig) internal {\r\n        if (_lunyrMultisig == 0x0) throw;\r\n        lunyrToken = LunyrToken(msg.sender);\r\n        lunyrMultisig = _lunyrMultisig;\r\n        isLUNVault = true;\r\n        unlockedAtBlockNumber = safeAdd(block.number, numBlocksLocked); \/\/ 180 days of blocks later\r\n    }\r\n\r\n    \/\/\/ @notice Transfer locked tokens to Lunyr's multisig wallet\r\n    function unlock() external {\r\n        \/\/ Wait your turn!\r\n        if (block.number < unlockedAtBlockNumber) throw;\r\n        \/\/ Will fail if allocation (and therefore toTransfer) is 0.\r\n        if (!lunyrToken.transfer(lunyrMultisig, lunyrToken.balanceOf(this))) throw;\r\n    }\r\n\r\n    \/\/ disallow payment this is for LUN not ether\r\n    function () { throw; }\r\n\r\n}\r\n\r\n\/\/\/ @title Lunyr crowdsale contract\r\ncontract LunyrToken is SafeMath, ERC20 {\r\n\r\n    \/\/ flag to determine if address is for a real contract or not\r\n    bool public isLunyrToken = false;\r\n\r\n    \/\/ State machine\r\n    enum State{PreFunding, Funding, Success, Failure}\r\n\r\n    \/\/ Token information\r\n    string public constant name = \"Lunyr Token\";\r\n    string public constant symbol = \"LUN\";\r\n    uint256 public constant decimals = 18;  \/\/ decimal places\r\n    uint256 public constant crowdfundPercentOfTotal = 78;\r\n    uint256 public constant vaultPercentOfTotal = 15;\r\n    uint256 public constant lunyrPercentOfTotal = 7;\r\n    uint256 public constant hundredPercent = 100;\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    \/\/ Upgrade information\r\n    address public upgradeMaster;\r\n    UpgradeAgent public upgradeAgent;\r\n    uint256 public totalUpgraded;\r\n\r\n    \/\/ Crowdsale information\r\n    bool public finalizedCrowdfunding = false;\r\n    uint256 public fundingStartBlock; \/\/ crowdsale start block\r\n    uint256 public fundingEndBlock; \/\/ crowdsale end block\r\n    uint256 public constant tokensPerEther = 44; \/\/ LUN:ETH exchange rate\r\n    uint256 public constant tokenCreationMax = safeMul(250000 ether, tokensPerEther);\r\n    uint256 public constant tokenCreationMin = safeMul(25000 ether, tokensPerEther);\r\n    \/\/ for testing on testnet\r\n    \/\/uint256 public constant tokenCreationMax = safeMul(10 ether, tokensPerEther);\r\n    \/\/uint256 public constant tokenCreationMin = safeMul(3 ether, tokensPerEther);\r\n\r\n    address public lunyrMultisig;\r\n    LUNVault public timeVault; \/\/ Lunyr's time-locked vault\r\n\r\n    event Upgrade(address indexed _from, address indexed _to, uint256 _value);\r\n    event Refund(address indexed _from, uint256 _value);\r\n    event UpgradeFinalized(address sender, address upgradeAgent);\r\n    event UpgradeAgentSet(address agent);\r\n\r\n    \/\/ For mainnet, startBlock = 3445888, endBlock = 3618688\r\n    function LunyrToken(address _lunyrMultisig,\r\n                        address _upgradeMaster,\r\n                        uint256 _fundingStartBlock,\r\n                        uint256 _fundingEndBlock) {\r\n\r\n        if (_lunyrMultisig == 0) throw;\r\n        if (_upgradeMaster == 0) throw;\r\n        if (_fundingStartBlock <= block.number) throw;\r\n        if (_fundingEndBlock   <= _fundingStartBlock) throw;\r\n        isLunyrToken = true;\r\n        upgradeMaster = _upgradeMaster;\r\n        fundingStartBlock = _fundingStartBlock;\r\n        fundingEndBlock = _fundingEndBlock;\r\n        timeVault = new LUNVault(_lunyrMultisig);\r\n        if (!timeVault.isLUNVault()) throw;\r\n        lunyrMultisig = _lunyrMultisig;\r\n        if (!MultiSigWallet(lunyrMultisig).isMultiSigWallet()) throw;\r\n    }\r\n\r\n    function balanceOf(address who) constant returns (uint) {\r\n        return balances[who];\r\n    }\r\n\r\n    \/\/\/ @notice Transfer `value` LUN tokens from sender's account\r\n    \/\/\/ `msg.sender` to provided account address `to`.\r\n    \/\/\/ @notice This function is disabled during the funding.\r\n    \/\/\/ @dev Required state: Success\r\n    \/\/\/ @param to The address of the recipient\r\n    \/\/\/ @param value The number of LUN to transfer\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transfer(address to, uint256 value) returns (bool ok) {\r\n        if (getState() != State.Success) throw; \/\/ Abort if crowdfunding was not a success.\r\n        if (to == 0x0) throw;\r\n        if (to == address(upgradeAgent)) throw;\r\n        \/\/if (to == address(upgradeAgent.newToken())) throw;\r\n        uint256 senderBalance = balances[msg.sender];\r\n        if (senderBalance >= value && value > 0) {\r\n            senderBalance = safeSub(senderBalance, value);\r\n            balances[msg.sender] = senderBalance;\r\n            balances[to] = safeAdd(balances[to], value);\r\n            Transfer(msg.sender, to, value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    \/\/\/ @notice Transfer `value` LUN tokens from sender 'from'\r\n    \/\/\/ to provided account address `to`.\r\n    \/\/\/ @notice This function is disabled during the funding.\r\n    \/\/\/ @dev Required state: Success\r\n    \/\/\/ @param from The address of the sender\r\n    \/\/\/ @param to The address of the recipient\r\n    \/\/\/ @param value The number of LUN to transfer\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transferFrom(address from, address to, uint value) returns (bool ok) {\r\n        if (getState() != State.Success) throw; \/\/ Abort if not in Success state.\r\n        if (to == 0x0) throw;\r\n        if (to == address(upgradeAgent)) throw;\r\n        \/\/if (to == address(upgradeAgent.newToken())) throw;\r\n        if (balances[from] >= value &&\r\n            allowed[from][msg.sender] >= value)\r\n        {\r\n            balances[to] = safeAdd(balances[to], value);\r\n            balances[from] = safeSub(balances[from], value);\r\n            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], value);\r\n            Transfer(from, to, value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    \/\/\/ @notice `msg.sender` approves `spender` to spend `value` tokens\r\n    \/\/\/ @param spender The address of the account able to transfer the tokens\r\n    \/\/\/ @param value The amount of wei to be approved for transfer\r\n    \/\/\/ @return Whether the approval was successful or not\r\n    function approve(address spender, uint256 value) returns (bool ok) {\r\n        if (getState() != State.Success) throw; \/\/ Abort if not in Success state.\r\n        allowed[msg.sender][spender] = value;\r\n        Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    \/\/\/ @param owner The address of the account owning tokens\r\n    \/\/\/ @param spender The address of the account able to transfer the tokens\r\n    \/\/\/ @return Amount of remaining tokens allowed to spent\r\n    function allowance(address owner, address spender) constant returns (uint) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    \/\/ Token upgrade functionality\r\n\r\n    \/\/\/ @notice Upgrade tokens to the new token contract.\r\n    \/\/\/ @dev Required state: Success\r\n    \/\/\/ @param value The number of tokens to upgrade\r\n    function upgrade(uint256 value) external {\r\n        if (getState() != State.Success) throw; \/\/ Abort if not in Success state.\r\n        if (upgradeAgent.owner() == 0x0) throw; \/\/ need a real upgradeAgent address\r\n\r\n        \/\/ Validate input value.\r\n        if (value == 0) throw;\r\n        if (value > balances[msg.sender]) throw;\r\n\r\n        \/\/ update the balances here first before calling out (reentrancy)\r\n        balances[msg.sender] = safeSub(balances[msg.sender], value);\r\n        totalSupply = safeSub(totalSupply, value);\r\n        totalUpgraded = safeAdd(totalUpgraded, value);\r\n        upgradeAgent.upgradeFrom(msg.sender, value);\r\n        Upgrade(msg.sender, upgradeAgent, value);\r\n    }\r\n\r\n    \/\/\/ @notice Set address of upgrade target contract and enable upgrade\r\n    \/\/\/ process.\r\n    \/\/\/ @dev Required state: Success\r\n    \/\/\/ @param agent The address of the UpgradeAgent contract\r\n    function setUpgradeAgent(address agent) external {\r\n        if (getState() != State.Success) throw; \/\/ Abort if not in Success state.\r\n        if (agent == 0x0) throw; \/\/ don't set agent to nothing\r\n        if (msg.sender != upgradeMaster) throw; \/\/ Only a master can designate the next agent\r\n        if (address(upgradeAgent) != 0x0 && upgradeAgent.upgradeHasBegun()) throw; \/\/ Don't change the upgrade agent\r\n        upgradeAgent = UpgradeAgent(agent);\r\n        \/\/ upgradeAgent must be created and linked to LunyrToken after crowdfunding is over\r\n        if (upgradeAgent.originalSupply() != totalSupply) throw;\r\n        UpgradeAgentSet(upgradeAgent);\r\n    }\r\n\r\n    \/\/\/ @notice Set address of upgrade target contract and enable upgrade\r\n    \/\/\/ process.\r\n    \/\/\/ @dev Required state: Success\r\n    \/\/\/ @param master The address that will manage upgrades, not the upgradeAgent contract address\r\n    function setUpgradeMaster(address master) external {\r\n        if (getState() != State.Success) throw; \/\/ Abort if not in Success state.\r\n        if (master == 0x0) throw;\r\n        if (msg.sender != upgradeMaster) throw; \/\/ Only a master can designate the next master\r\n        upgradeMaster = master;\r\n    }\r\n\r\n    function setMultiSigWallet(address newWallet) external {\r\n      if (msg.sender != lunyrMultisig) throw;\r\n      MultiSigWallet wallet = MultiSigWallet(newWallet);\r\n      if (!wallet.isMultiSigWallet()) throw;\r\n      lunyrMultisig = newWallet;\r\n    }\r\n\r\n    \/\/ Crowdfunding:\r\n\r\n    \/\/ don't just send ether to the contract expecting to get tokens\r\n    function() { throw; }\r\n\r\n\r\n    \/\/\/ @notice Create tokens when funding is active.\r\n    \/\/\/ @dev Required state: Funding\r\n    \/\/\/ @dev State transition: -> Funding Success (only if cap reached)\r\n    function create() payable external {\r\n        \/\/ Abort if not in Funding Active state.\r\n        \/\/ The checks are split (instead of using or operator) because it is\r\n        \/\/ cheaper this way.\r\n        if (getState() != State.Funding) throw;\r\n\r\n        \/\/ Do not allow creating 0 or more than the cap tokens.\r\n        if (msg.value == 0) throw;\r\n\r\n        \/\/ multiply by exchange rate to get newly created token amount\r\n        uint256 createdTokens = safeMul(msg.value, tokensPerEther);\r\n\r\n        \/\/ we are creating tokens, so increase the totalSupply\r\n        totalSupply = safeAdd(totalSupply, createdTokens);\r\n\r\n        \/\/ don't go over the limit!\r\n        if (totalSupply > tokenCreationMax) throw;\r\n\r\n        \/\/ Assign new tokens to the sender\r\n        balances[msg.sender] = safeAdd(balances[msg.sender], createdTokens);\r\n\r\n        \/\/ Log token creation event\r\n        Transfer(0, msg.sender, createdTokens);\r\n    }\r\n\r\n    \/\/\/ @notice Finalize crowdfunding\r\n    \/\/\/ @dev If cap was reached or crowdfunding has ended then:\r\n    \/\/\/ create LUN for the Lunyr Multisig and developer,\r\n    \/\/\/ transfer ETH to the Lunyr Multisig address.\r\n    \/\/\/ @dev Required state: Success\r\n    function finalizeCrowdfunding() external {\r\n        \/\/ Abort if not in Funding Success state.\r\n        if (getState() != State.Success) throw; \/\/ don't finalize unless we won\r\n        if (finalizedCrowdfunding) throw; \/\/ can't finalize twice (so sneaky!)\r\n\r\n        \/\/ prevent more creation of tokens\r\n        finalizedCrowdfunding = true;\r\n\r\n        \/\/ Endowment: 15% of total goes to vault, timelocked for 6 months\r\n        \/\/ uint256 vaultTokens = safeDiv(safeMul(totalSupply, vaultPercentOfTotal), hundredPercent);\r\n        uint256 vaultTokens = safeDiv(safeMul(totalSupply, vaultPercentOfTotal), crowdfundPercentOfTotal);\r\n        balances[timeVault] = safeAdd(balances[timeVault], vaultTokens);\r\n        Transfer(0, timeVault, vaultTokens);\r\n\r\n        \/\/ Endowment: 7% of total goes to lunyr for marketing and bug bounty\r\n        uint256 lunyrTokens = safeDiv(safeMul(totalSupply, lunyrPercentOfTotal), crowdfundPercentOfTotal);\r\n        balances[lunyrMultisig] = safeAdd(balances[lunyrMultisig], lunyrTokens);\r\n        Transfer(0, lunyrMultisig, lunyrTokens);\r\n\r\n        totalSupply = safeAdd(safeAdd(totalSupply, vaultTokens), lunyrTokens);\r\n\r\n        \/\/ Transfer ETH to the Lunyr Multisig address.\r\n        if (!lunyrMultisig.send(this.balance)) throw;\r\n    }\r\n\r\n    \/\/\/ @notice Get back the ether sent during the funding in case the funding\r\n    \/\/\/ has not reached the minimum level.\r\n    \/\/\/ @dev Required state: Failure\r\n    function refund() external {\r\n        \/\/ Abort if not in Funding Failure state.\r\n        if (getState() != State.Failure) throw;\r\n\r\n        uint256 lunValue = balances[msg.sender];\r\n        if (lunValue == 0) throw;\r\n        balances[msg.sender] = 0;\r\n        totalSupply = safeSub(totalSupply, lunValue);\r\n\r\n        uint256 ethValue = safeDiv(lunValue, tokensPerEther); \/\/ lunValue % tokensPerEther == 0\r\n        Refund(msg.sender, ethValue);\r\n        if (!msg.sender.send(ethValue)) throw;\r\n    }\r\n\r\n    \/\/\/ @notice This manages the crowdfunding state machine\r\n    \/\/\/ We make it a function and do not assign the result to a variable\r\n    \/\/\/ So there is no chance of the variable being stale\r\n    function getState() public constant returns (State){\r\n      \/\/ once we reach success, lock in the state\r\n      if (finalizedCrowdfunding) return State.Success;\r\n      if (block.number < fundingStartBlock) return State.PreFunding;\r\n      else if (block.number <= fundingEndBlock && totalSupply < tokenCreationMax) return State.Funding;\r\n      else if (totalSupply >= tokenCreationMin) return State.Success;\r\n      else return State.Failure;\r\n    }\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/Lunyr",
        "Telegram": "",
        "Website": "https:\/\/lunyr.com\/",
        "Email": "mailto:support@lunyr.com",
        "Twitter": "https:\/\/twitter.com\/LunyrInc"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xfa05a73ffe78ef8f1a739473e462c54bae6567d9#code"
    }, {
      "contractId": 38,
      "title": "HumaniqToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Humaniq",
      "code": "pragma solidity ^0.4.6;\r\n\r\n\r\n\/**\r\n * Math operations with safety checks\r\n *\/\r\ncontract SafeMath {\r\n  function mul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a \/ b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\/\/\/ Implements ERC 20 Token standard: https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n\/\/\/ @title Abstract token contract - Functions to be implemented by token contracts.\r\ncontract AbstractToken {\r\n    \/\/ This is not an abstract function, because solc won't recognize generated getter functions for public variables as functions\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n    function balanceOf(address owner) constant returns (uint256 balance);\r\n    function transfer(address to, uint256 value) returns (bool success);\r\n    function transferFrom(address from, address to, uint256 value) returns (bool success);\r\n    function approve(address spender, uint256 value) returns (bool success);\r\n    function allowance(address owner, address spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Issuance(address indexed to, uint256 value);\r\n}\r\n\r\n\r\ncontract StandardToken is AbstractToken {\r\n\r\n    \/*\r\n     *  Data structures\r\n     *\/\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n\r\n    \/*\r\n     *  Read and write storage functions\r\n     *\/\r\n    \/\/\/ @dev Transfers sender's tokens to a given address. Returns success.\r\n    \/\/\/ @param _to Address of token receiver.\r\n    \/\/\/ @param _value Number of tokens to transfer.\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    \/\/\/ @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\r\n    \/\/\/ @param _from Address from where tokens are withdrawn.\r\n    \/\/\/ @param _to Address to where tokens are sent.\r\n    \/\/\/ @param _value Number of tokens to transfer.\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    \/\/\/ @dev Returns number of tokens owned by given address.\r\n    \/\/\/ @param _owner Address of token owner.\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    \/\/\/ @dev Sets approved amount of tokens for spender. Returns success.\r\n    \/\/\/ @param _spender Address of allowed account.\r\n    \/\/\/ @param _value Number of approved tokens.\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    \/*\r\n     * Read storage functions\r\n     *\/\r\n    \/\/\/ @dev Returns number of allowed tokens for given address.\r\n    \/\/\/ @param _owner Address of token owner.\r\n    \/\/\/ @param _spender Address of token spender.\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\n\r\n\/\/\/ @title Token contract - Implements Standard Token Interface with HumaniQ features.\r\n\/\/\/ @author Evgeny Yurtaev - <[email\u00a0protected]>\r\n\/\/\/ @author Alexey Bashlykov - <[email\u00a0protected]>\r\ncontract HumaniqToken is StandardToken, SafeMath {\r\n\r\n    \/*\r\n     * External contracts\r\n     *\/\r\n    address public minter;\r\n\r\n    \/*\r\n     * Token meta data\r\n     *\/\r\n    string constant public name = \"Humaniq\";\r\n    string constant public symbol = \"HMQ\";\r\n    uint8 constant public decimals = 8;\r\n\r\n    \/\/ Address of the founder of Humaniq.\r\n    address public founder = 0xc890b1f532e674977dfdb791cafaee898dfa9671;\r\n\r\n    \/\/ Multisig address of the founders\r\n    address public multisig = 0xa2c9a7578e2172f32a36c5c0e49d64776f9e7883;\r\n\r\n    \/\/ Address where all tokens created during ICO stage initially allocated\r\n    address constant public allocationAddressICO = 0x1111111111111111111111111111111111111111;\r\n\r\n    \/\/ Address where all tokens created during preICO stage initially allocated\r\n    address constant public allocationAddressPreICO = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    \/\/ 31 820 314 tokens were minted during preICO\r\n    uint constant public preICOSupply = mul(31820314, 100000000);\r\n\r\n    \/\/ 131 038 286 tokens were minted during ICO\r\n    uint constant public ICOSupply = mul(131038286, 100000000);\r\n\r\n    \/\/ Max number of tokens that can be minted\r\n    uint public maxTotalSupply;\r\n\r\n    \/*\r\n     * Modifiers\r\n     *\/\r\n    modifier onlyFounder() {\r\n        \/\/ Only founder is allowed to do this action.\r\n        if (msg.sender != founder) {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyMinter() {\r\n        \/\/ Only minter is allowed to proceed.\r\n        if (msg.sender != minter) {\r\n            throw;\r\n        }\r\n        _;\r\n    }\r\n\r\n    \/*\r\n     * Contract functions\r\n     *\/\r\n\r\n    \/\/\/ @dev Crowdfunding contract issues new tokens for address. Returns success.\r\n    \/\/\/ @param _for Address of receiver.\r\n    \/\/\/ @param tokenCount Number of tokens to issue.\r\n    function issueTokens(address _for, uint tokenCount)\r\n        external\r\n        payable\r\n        onlyMinter\r\n        returns (bool)\r\n    {\r\n        if (tokenCount == 0) {\r\n            return false;\r\n        }\r\n\r\n        if (add(totalSupply, tokenCount) > maxTotalSupply) {\r\n            throw;\r\n        }\r\n\r\n        totalSupply = add(totalSupply, tokenCount);\r\n        balances[_for] = add(balances[_for], tokenCount);\r\n        Issuance(_for, tokenCount);\r\n        return true;\r\n    }\r\n\r\n    \/\/\/ @dev Function to change address that is allowed to do emission.\r\n    \/\/\/ @param newAddress Address of new emission contract.\r\n    function changeMinter(address newAddress)\r\n        public\r\n        onlyFounder\r\n        returns (bool)\r\n    {   \r\n        \/\/ Forbid previous emission contract to distribute tokens minted during ICO stage\r\n        delete allowed[allocationAddressICO][minter];\r\n\r\n        minter = newAddress;\r\n\r\n        \/\/ Allow emission contract to distribute tokens minted during ICO stage\r\n        allowed[allocationAddressICO][minter] = balanceOf(allocationAddressICO);\r\n    }\r\n\r\n    \/\/\/ @dev Function to change founder address.\r\n    \/\/\/ @param newAddress Address of new founder.\r\n    function changeFounder(address newAddress)\r\n        public\r\n        onlyFounder\r\n        returns (bool)\r\n    {   \r\n        founder = newAddress;\r\n    }\r\n\r\n    \/\/\/ @dev Function to change multisig address.\r\n    \/\/\/ @param newAddress Address of new multisig.\r\n    function changeMultisig(address newAddress)\r\n        public\r\n        onlyFounder\r\n        returns (bool)\r\n    {\r\n        multisig = newAddress;\r\n    }\r\n\r\n    \/\/\/ @dev Contract constructor function sets initial token balances.\r\n    function HumaniqToken(address founderAddress)\r\n    {   \r\n        \/\/ Set founder address\r\n        founder = founderAddress;\r\n\r\n        \/\/ Allocate all created tokens during ICO stage to allocationAddressICO.\r\n        balances[allocationAddressICO] = ICOSupply;\r\n\r\n        \/\/ Allocate all created tokens during preICO stage to allocationAddressPreICO.\r\n        balances[allocationAddressPreICO] = preICOSupply;\r\n\r\n        \/\/ Allow founder to distribute tokens minted during preICO stage\r\n        allowed[allocationAddressPreICO][founder] = preICOSupply;\r\n\r\n        \/\/ Give 14 percent of all tokens to founders.\r\n        balances[multisig] = div(mul(ICOSupply, 14), 86);\r\n\r\n        \/\/ Set correct totalSupply and limit maximum total supply.\r\n        totalSupply = add(ICOSupply, balances[multisig]);\r\n        totalSupply = add(totalSupply, preICOSupply);\r\n        maxTotalSupply = mul(totalSupply, 5);\r\n    }\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/Humaniq\/",
        "Telegram": "",
        "Website": "https:\/\/humaniq.co\/",
        "Email": "mailto:info@humaniq.com",
        "Twitter": "https:\/\/twitter.com\/Humaniq"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xcbcc0f036ed4788f63fc0fee32873d6a7487b908#code"
    }, {
      "contractId": 39,
      "title": "TokenCard Token",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "TokenCard",
      "code": "pragma solidity >=0.4.4;\r\n\r\n\/\/ Copyright 2017 Alchemy Limited LLC, Do not distribute\r\n\r\ncontract Constants {\r\n    uint DECIMALS = 8;\r\n}\r\n\r\n\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) throw;\r\n        _;\r\n    }\r\n\r\n    address newOwner;\r\n\r\n    function changeOwner(address _newOwner) onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() {\r\n        if (msg.sender == newOwner) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\n\/\/from Zeppelin\r\ncontract SafeMath {\r\n    function safeMul(uint a, uint b) internal returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c \/ a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n\r\n    function assert(bool assertion) internal {\r\n        if (!assertion) throw;\r\n    }\r\n}\r\n\r\n\r\n\r\n\/\/Copyright 2017 Alchemy Limited LLC DO not distribute\r\n\/\/ERC20 token\r\n\r\ncontract Token is SafeMath, Owned, Constants {\r\n    uint public currentSupply;\r\n    uint public remainingOwner;\r\n    uint public remainingAuctionable;\r\n    uint public ownerTokensFreeDay;\r\n    bool public launched = false;\r\n\r\n    bool public remaindersSet = false;\r\n    bool public mintingDone = false;\r\n\r\n    address public controller;\r\n\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n\r\n    modifier onlyController() {\r\n        if (msg.sender != controller) throw;\r\n        _;\r\n    }\r\n\r\n    modifier isLaunched() {\r\n        assert(launched == true);\r\n        _;\r\n    }\r\n\r\n    modifier onlyPayloadSize(uint numwords) {\r\n        assert(msg.data.length == numwords * 32 + 4);\r\n        _;\r\n    }\r\n\r\n    function Token() {\r\n        owner = msg.sender;\r\n        name = \"Monolith TKN\";\r\n        decimals = uint8(DECIMALS);\r\n        symbol = \"TKN\";\r\n    }\r\n\r\n    function Launch() onlyOwner {\r\n        launched = true;\r\n    }\r\n\r\n    function setOwnerFreeDay(uint day) onlyOwner {\r\n        if (ownerTokensFreeDay != 0) throw;\r\n\r\n        ownerTokensFreeDay = day;\r\n    }\r\n\r\n    function totalSupply() constant returns(uint) {\r\n        return currentSupply + remainingOwner;\r\n    }\r\n\r\n    function setRemainders(uint _remainingOwner, uint _remainingAuctionable) onlyOwner {\r\n        if (remaindersSet) { throw; }\r\n\r\n        remainingOwner = _remainingOwner;\r\n        remainingAuctionable = _remainingAuctionable;\r\n    }\r\n\r\n    function finalizeRemainders() onlyOwner {\r\n        remaindersSet = true;\r\n    }\r\n\r\n    function setController(address _controller) onlyOwner {\r\n        controller = _controller;\r\n    }\r\n\r\n    function claimOwnerSupply() onlyOwner {\r\n        if (now < ownerTokensFreeDay) throw;\r\n        if (remainingOwner == 0) throw;\r\n        if (!remaindersSet) throw; \/\/ must finalize remainders\r\n\r\n        balanceOf[owner] = safeAdd(balanceOf[owner], remainingOwner);\r\n        remainingOwner = 0;\r\n    }\r\n\r\n    function claimAuctionableTokens(uint amount) onlyController {\r\n        if (amount > remainingAuctionable) throw;\r\n\r\n        balanceOf[controller] = safeAdd(balanceOf[controller], amount);\r\n        currentSupply = safeAdd(currentSupply, amount);\r\n        remainingAuctionable = safeSub(remainingAuctionable,amount);\r\n\r\n        Transfer(0, controller, amount);\r\n    }\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n    function mint(address addr, uint amount) onlyOwner onlyPayloadSize(2) {\r\n        if (mintingDone) throw;\r\n\r\n        balanceOf[addr] = safeAdd(balanceOf[addr], amount);\r\n\r\n        currentSupply = safeAdd(currentSupply, amount);\r\n\r\n        Transfer(0, addr, amount);\r\n    }\r\n\r\n\r\n    uint constant D160 = 0x0010000000000000000000000000000000000000000;\r\n\r\n    \/\/ We don't use safe math in this function\r\n    \/\/ because this will be called for the owner before the contract\r\n    \/\/ is published and we need to save gas.\r\n    function multiMint(uint[] data) onlyOwner {\r\n        if (mintingDone) throw;\r\n\r\n        uint supplyAdd;\r\n        for (uint i = 0; i < data.length; i++ ) {\r\n            address addr = address( data[i] & (D160-1) );\r\n            uint amount = data[i] \/ D160;\r\n\r\n            balanceOf[addr] += amount;\r\n            supplyAdd += amount;\r\n            Transfer(0, addr, amount);\r\n        }\r\n        currentSupply += supplyAdd;\r\n    }\r\n\r\n    function completeMinting() onlyOwner {\r\n        mintingDone = true;\r\n    }\r\n\r\n    mapping(address => uint) public balanceOf;\r\n    mapping(address => mapping (address => uint)) public allowance;\r\n\r\n    function transfer(address _to, uint _value) isLaunched notPaused\r\n    onlyPayloadSize(2)\r\n    returns (bool success) {\r\n        if (balanceOf[msg.sender] < _value) return false;\r\n        if (_to == 0x0) return false;\r\n\r\n        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);\r\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value)  isLaunched notPaused\r\n    onlyPayloadSize(3)\r\n    returns (bool success) {\r\n        if (_to == 0x0) return false;\r\n        if (balanceOf[_from] < _value) return false;\r\n\r\n        var allowed = allowance[_from][msg.sender];\r\n        if (allowed < _value) return false;\r\n\r\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\r\n        balanceOf[_from] = safeSub(balanceOf[_from], _value);\r\n        allowance[_from][msg.sender] = safeSub(allowed, _value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint _value)\r\n    onlyPayloadSize(2)\r\n    returns (bool success) {\r\n        \/\/require user to set to zero before resetting to nonzero\r\n        if ((_value != 0) && (allowance[msg.sender][_spender] != 0)) {\r\n            return false;\r\n        }\r\n\r\n        allowance[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval (address _spender, uint _addedValue)\r\n    onlyPayloadSize(2)\r\n    returns (bool success) {\r\n        uint oldValue = allowance[msg.sender][_spender];\r\n        allowance[msg.sender][_spender] = safeAdd(oldValue, _addedValue);\r\n        Approval(msg.sender, _spender, allowance[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval (address _spender, uint _subtractedValue)\r\n    onlyPayloadSize(2)\r\n    returns (bool success) {\r\n        uint oldValue = allowance[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowance[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowance[msg.sender][_spender] = safeSub(oldValue, _subtractedValue);\r\n        }\r\n        Approval(msg.sender, _spender, allowance[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    \/\/\/ @notice `msg.sender` approves `_spender` to send `_amount` tokens on\r\n    \/\/\/  its behalf, and then a function is triggered in the contract that is\r\n    \/\/\/  being approved, `_spender`. This allows users to use their tokens to\r\n    \/\/\/  interact with contracts in one function call instead of two\r\n    \/\/\/ @param _spender The address of the contract able to transfer the tokens\r\n    \/\/\/ @param _amount The amount of tokens to be approved for transfer\r\n    \/\/\/ @return True if the function call was successful\r\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\r\n    ) returns (bool success) {\r\n        if (!approve(_spender, _amount)) throw;\r\n\r\n        ApproveAndCallFallBack(_spender).receiveApproval(\r\n            msg.sender,\r\n            _amount,\r\n            this,\r\n            _extraData\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    \/\/Holds accumulated dividend tokens other than TKN\r\n    TokenHolder public tokenholder;\r\n\r\n    \/\/once locked, can no longer upgrade tokenholder\r\n    bool public lockedTokenHolder;\r\n\r\n    function lockTokenHolder() onlyOwner {\r\n        lockedTokenHolder = true;\r\n    }\r\n\r\n    function setTokenHolder(address _th) onlyOwner {\r\n        if (lockedTokenHolder) throw;\r\n        tokenholder = TokenHolder(_th);\r\n    }\r\n\r\n    function burn(uint _amount) notPaused returns (bool result)  {\r\n        if (_amount > balanceOf[msg.sender]) return false;\r\n\r\n        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _amount);\r\n        currentSupply  = safeSub(currentSupply, _amount);\r\n        result = tokenholder.burn(msg.sender, _amount);\r\n        if (!result) throw;\r\n        Transfer(msg.sender, 0, _amount);\r\n    }\r\n\r\n    \/\/ Peterson's Law Protection\r\n    event logTokenTransfer(address token, address to, uint amount);\r\n\r\n    function claimTokens(address _token) onlyOwner {\r\n        if (_token == 0x0) {\r\n            owner.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        Token token = Token(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(owner, balance);\r\n        logTokenTransfer(_token, owner, balance);\r\n    }\r\n\r\n    \/\/ Pause mechanism\r\n\r\n    bool public pausingMechanismLocked = false;\r\n    bool public paused = false;\r\n\r\n    modifier notPaused() {\r\n        if (paused) throw;\r\n        _;\r\n    }\r\n\r\n    function pause() onlyOwner {\r\n        if (pausingMechanismLocked) throw;\r\n        paused = true;\r\n    }\r\n\r\n    function unpause() onlyOwner {\r\n        if (pausingMechanismLocked) throw;\r\n        paused = false;\r\n    }\r\n\r\n    function neverPauseAgain() onlyOwner {\r\n        pausingMechanismLocked = true;\r\n    }\r\n}\r\n\r\ncontract TokenHolder {\r\n    function burn(address , uint )\r\n    returns (bool result) {\r\n        return false;\r\n    }\r\n}\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 _amount, address _token, bytes _data);\r\n}",
      "officialLinks": {
        "Reddit": "",
        "Telegram": "",
        "Website": "https:\/\/tokencard.io\/#token",
        "Email": "mailto:hello@tokencard.io",
        "Twitter": "https:\/\/twitter.com\/monolith_web3"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xaaaf91d9b90df800df4f55c205fd6989c977e73a#code"
    }, {
      "contractId": 40,
      "title": "GUPToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Guppy",
      "code": "pragma solidity ^0.4.8;\r\n\r\n\r\ncontract SafeMath {\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) throw;\r\n  }\r\n\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a \/ b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract StandardTokenProtocol {\r\n\r\n    function totalSupply() constant returns (uint256 totalSupply) {}\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n    function transfer(address _recipient, uint256 _value) returns (bool success) {}\r\n    function transferFrom(address _from, address _recipient, uint256 _value) returns (bool success) {}\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _recipient, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\n\r\ncontract StandardToken is StandardTokenProtocol {\r\n\r\n    modifier when_can_transfer(address _from, uint256 _value) {\r\n        if (balances[_from] >= _value) _;\r\n    }\r\n\r\n    modifier when_can_receive(address _recipient, uint256 _value) {\r\n        if (balances[_recipient] + _value > balances[_recipient]) _;\r\n    }\r\n\r\n    modifier when_is_allowed(address _from, address _delegate, uint256 _value) {\r\n        if (allowed[_from][_delegate] >= _value) _;\r\n    }\r\n\r\n    function transfer(address _recipient, uint256 _value)\r\n        when_can_transfer(msg.sender, _value)\r\n        when_can_receive(_recipient, _value)\r\n        returns (bool o_success)\r\n    {\r\n        balances[msg.sender] -= _value;\r\n        balances[_recipient] += _value;\r\n        Transfer(msg.sender, _recipient, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _recipient, uint256 _value)\r\n        when_can_transfer(_from, _value)\r\n        when_can_receive(_recipient, _value)\r\n        when_is_allowed(_from, msg.sender, _value)\r\n        returns (bool o_success)\r\n    {\r\n        allowed[_from][msg.sender] -= _value;\r\n        balances[_from] -= _value;\r\n        balances[_recipient] += _value;\r\n        Transfer(_from, _recipient, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool o_success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 o_remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n\r\n}\r\n\r\ncontract GUPToken is StandardToken {\r\n\r\n\t\/\/FIELDS\r\n\tstring public name = \"Guppy\";\r\n    string public symbol = \"GUP\";\r\n    uint public decimals = 3;\r\n\r\n\t\/\/CONSTANTS\r\n\tuint public constant LOCKOUT_PERIOD = 1 years; \/\/time after end date that illiquid GUP can be transferred\r\n\r\n\t\/\/ASSIGNED IN INITIALIZATION\r\n\tuint public endMintingTime; \/\/Timestamp after which no more tokens can be created\r\n\taddress public minter; \/\/address of the account which may mint new tokens\r\n\r\n\tmapping (address => uint) public illiquidBalance; \/\/Balance of 'Frozen funds'\r\n\r\n\t\/\/MODIFIERS\r\n\t\/\/Can only be called by contribution contract.\r\n\tmodifier only_minter {\r\n\t\tif (msg.sender != minter) throw;\r\n\t\t_;\r\n\t}\r\n\r\n\t\/\/ Can only be called if illiquid tokens may be transformed into liquid.\r\n\t\/\/ This happens when `LOCKOUT_PERIOD` of time passes after `endMintingTime`.\r\n\tmodifier when_thawable {\r\n\t\tif (now < endMintingTime + LOCKOUT_PERIOD) throw;\r\n\t\t_;\r\n\t}\r\n\r\n\t\/\/ Can only be called if (liquid) tokens may be transferred. Happens\r\n\t\/\/ immediately after `endMintingTime`.\r\n\tmodifier when_transferable {\r\n\t\tif (now < endMintingTime) throw;\r\n\t\t_;\r\n\t}\r\n\r\n\t\/\/ Can only be called if the `crowdfunder` is allowed to mint tokens. Any\r\n\t\/\/ time before `endMintingTime`.\r\n\tmodifier when_mintable {\r\n\t\tif (now >= endMintingTime) throw;\r\n\t\t_;\r\n\t}\r\n\r\n\t\/\/ Initialization contract assigns address of crowdfund contract and end time.\r\n\tfunction GUPToken(address _minter, uint _endMintingTime) {\r\n\t\tendMintingTime = _endMintingTime;\r\n\t\tminter = _minter;\r\n\t}\r\n\r\n\t\/\/ Create new tokens when called by the crowdfund contract.\r\n\t\/\/ Only callable before the end time.\r\n\tfunction createToken(address _recipient, uint _value)\r\n\t\twhen_mintable\r\n\t\tonly_minter\r\n\t\treturns (bool o_success)\r\n\t{\r\n\t\tbalances[_recipient] += _value;\r\n\t\ttotalSupply += _value;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t\/\/ Create an illiquidBalance which cannot be traded until end of lockout period.\r\n\t\/\/ Can only be called by crowdfund contract before the end time.\r\n\tfunction createIlliquidToken(address _recipient, uint _value)\r\n\t\twhen_mintable\r\n\t\tonly_minter\r\n\t\treturns (bool o_success)\r\n\t{\r\n\t\tilliquidBalance[_recipient] += _value;\r\n\t\ttotalSupply += _value;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t\/\/ Make sender's illiquid balance liquid when called after lockout period.\r\n\tfunction makeLiquid()\r\n\t\twhen_thawable\r\n\t{\r\n\t\tbalances[msg.sender] += illiquidBalance[msg.sender];\r\n\t\tilliquidBalance[msg.sender] = 0;\r\n\t}\r\n\r\n\t\/\/ Transfer amount of tokens from sender account to recipient.\r\n\t\/\/ Only callable after the crowd fund end date.\r\n\tfunction transfer(address _recipient, uint _amount)\r\n\t\twhen_transferable\r\n\t\treturns (bool o_success)\r\n\t{\r\n\t\treturn super.transfer(_recipient, _amount);\r\n\t}\r\n\r\n\t\/\/ Transfer amount of tokens from a specified address to a recipient.\r\n\t\/\/ Only callable after the crowd fund end date.\r\n\tfunction transferFrom(address _from, address _recipient, uint _amount)\r\n\t\twhen_transferable\r\n\t\treturns (bool o_success)\r\n\t{\r\n\t\treturn super.transferFrom(_from, _recipient, _amount);\r\n\t}\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/Matchpool",
        "Telegram": "https:\/\/t.me\/matchpool",
        "Website": "https:\/\/matchpool.co\/",
        "Email": "",
        "Twitter": "https:\/\/twitter.com\/matchpool"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xf7b098298f7c69fc14610bf71d5e02c60792894c#code"
    }, {
      "contractId": 41,
      "title": "XaurumToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Xaurum",
      "code": "contract ERC20TokenInterface {\r\n\r\n    \/\/\/ @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    \/\/\/ @param _owner The address from which the balance will be retrieved\r\n    \/\/\/ @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    \/\/\/ @notice send `_value` token to `_to` from `msg.sender`\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _value The amount of token to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    \/\/\/ @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    \/\/\/ @param _from The address of the sender\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _value The amount of token to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    \/\/\/ @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @param _value The amount of wei to be approved for transfer\r\n    \/\/\/ @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    \/\/\/ @param _owner The address of the account owning tokens\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}   \r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract XaurumProxyERC20 is ERC20TokenInterface {\r\n\r\n    bool public xaurumProxyWorking;\r\n\r\n    XaurumToken xaurumTokenReference; \r\n\r\n    address proxyCurrator;\r\n    address owner;\r\n    address dev;\r\n\r\n    \/* Public variables of the token *\/\r\n    string public standard = 'XaurumERCProxy';\r\n    string public name = 'Xaurum';\r\n    string public symbol = 'XAUR';\r\n    uint8 public decimals = 8;\r\n\r\n\r\n    modifier isWorking(){\r\n        if (xaurumProxyWorking && !xaurumTokenReference.lockdown()){\r\n            _\r\n        }\r\n    }\r\n\r\n    function XaurumProxyERC20(){\r\n        dev = msg.sender;\r\n        xaurumProxyWorking = true;\r\n    }\r\n\r\n    function setTokenReference(address _xaurumTokenAress) returns (bool){\r\n        if (msg.sender == proxyCurrator){\r\n            xaurumTokenReference = XaurumToken(_xaurumTokenAress);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function EnableDisableTokenProxy() returns (bool){\r\n        if (msg.sender == proxyCurrator){        \r\n            xaurumProxyWorking = !xaurumProxyWorking;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function setProxyCurrator(address _newCurratorAdress) returns (bool){\r\n        if (msg.sender == owner || msg.sender == dev){        \r\n            proxyCurrator = _newCurratorAdress;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function setOwner(address _newOwnerAdress) returns (bool){\r\n        if ( msg.sender == dev ){        \r\n            owner = _newOwnerAdress;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function totalSupply() constant returns (uint256 supply) {\r\n        return xaurumTokenReference.totalSupply();\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return xaurumTokenReference.balanceOf(_owner);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) isWorking returns (bool success) {\r\n        bool answerStatus;\r\n        address sentFrom;\r\n        address sentTo;\r\n        uint256 sentToAmount;\r\n        address burningAddress;\r\n        uint256 burningAmount;\r\n\r\n        (answerStatus, sentFrom, sentTo, sentToAmount, burningAddress, burningAmount) = xaurumTokenReference.transferViaProxy(msg.sender, _to, _value);\r\n        if(answerStatus){\r\n            Transfer(sentFrom, sentTo, sentToAmount);\r\n            Transfer(sentFrom, burningAddress, burningAmount);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) isWorking returns (bool success) {\r\n        bool answerStatus;\r\n        address sentFrom;\r\n        address sentTo;\r\n        uint256 sentToAmount;\r\n        address burningAddress;\r\n        uint256 burningAmount;\r\n\r\n        (answerStatus, sentFrom, sentTo, sentToAmount, burningAddress, burningAmount) = xaurumTokenReference.transferFromViaProxy(msg.sender, _from, _to, _value);\r\n        if(answerStatus){\r\n            Transfer(sentFrom, sentTo, sentToAmount);\r\n            Transfer(sentFrom, burningAddress, burningAmount);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) isWorking returns (bool success) {\r\n        if (xaurumTokenReference.approveFromProxy(msg.sender, _spender, _value)){\r\n            Approval(msg.sender, _spender, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return xaurumTokenReference.allowanceFromProxy(msg.sender, _owner, _spender);\r\n    } \r\n}\r\n\r\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\r\n\r\ncontract XaurumToken {\r\n    \r\n    \/* Public variables of the token *\/\r\n    string public standard = 'Xaurum v1.0';\r\n    string public name = 'Xaurum';\r\n    string public symbol = 'XAUR';\r\n    uint8 public decimals = 8;\r\n\r\n    uint256 public totalSupply = 0;\r\n    uint256 public totalGoldSupply = 0;\r\n    bool public lockdown = false;\r\n    uint256 numberOfCoinages;\r\n\r\n    \/* Private variabiles for the token *\/\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    mapping (address => uint) lockedAccounts;\r\n\r\n    \/* Events *\/\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    event Burn(address from, uint256 value, BurningType burningType);\r\n    event Melt(uint256 xaurAmount, uint256 goldAmount);\r\n    event Coinage(uint256 coinageId, uint256 usdAmount, uint256 xaurAmount, uint256 goldAmount, uint256 totalGoldSupply, uint256 totalSupply);\r\n\r\n    \/*enums*\/\r\n    enum BurningType { TxtFee, AllyDonation, ServiceFee }\r\n\r\n   \/* Contracts *\/\r\n    XaurumMeltingContract public meltingContract;\r\n    function setMeltingContract(address _meltingContractAddress){\r\n        if (msg.sender == owner || msg.sender == dev){\r\n            meltingContract = XaurumMeltingContract(_meltingContractAddress);\r\n        }\r\n    }\r\n\r\n    XaurumDataContract public dataContract;\r\n    function setDataContract(address _dataContractAddress){\r\n        if (msg.sender == owner || msg.sender == dev){\r\n            dataContract = XaurumDataContract(_dataContractAddress);\r\n        }\r\n    }\r\n\r\n    XaurumCoinageContract public coinageContract;\r\n    function setCoinageContract(address _coinageContractAddress){\r\n        if (msg.sender == owner || msg.sender == dev){\r\n            coinageContract = XaurumCoinageContract(_coinageContractAddress);\r\n        }\r\n    }\r\n\r\n    XaurmProxyContract public proxyContract;\r\n    function setProxyContract(address _proxyContractAddress){\r\n        if (msg.sender == owner || msg.sender == dev){\r\n            proxyContract = XaurmProxyContract(_proxyContractAddress);\r\n        }\r\n    }\r\n\r\n    XaurumAlliesContract public alliesContract;\r\n    function setAlliesContract(address _alliesContractAddress){\r\n        if (msg.sender == owner || msg.sender == dev){\r\n            alliesContract = XaurumAlliesContract(_alliesContractAddress);\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n\r\n    \/* owner *\/\r\n    address public owner;\r\n    function setOwner(address _newOwnerAdress) returns (bool){\r\n        if ( msg.sender == dev ){        \r\n            owner = _newOwnerAdress;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    address public dev;\r\n\r\n    \/* Xaur for gas *\/\r\n    address xaurForGasCurrator;\r\n    function setXauForGasCurrator(address _curratorAddress){\r\n        if (msg.sender == owner || msg.sender == dev){\r\n            xaurForGasCurrator = _curratorAddress;\r\n        }\r\n    }\r\n\r\n    \/* Burrning *\/\r\n    address public burningAdress;\r\n\r\n    \/* Constructor *\/\r\n    function XaurumToken(address _burningAddress) { \r\n        burningAdress = _burningAddress;\r\n        lockdown = false;\r\n        dev = msg.sender;\r\n       \r\n        \r\n        \/\/ initial\r\n         numberOfCoinages += 1;\r\n         balances[0x097B7b672fe0dc3eF61f53B954B3DCC86382e7B9] += 5999319593600000;\r\n         totalSupply += 5999319593600000;\r\n         totalGoldSupply += 1696620000000;\r\n         Coinage(numberOfCoinages, 0, 5999319593600000, 1696620000000, totalGoldSupply, totalSupply);      \r\n\t\t\r\n\r\n        \/\/ Mint 1\r\n         numberOfCoinages += 1;\r\n         balances[0x097B7b672fe0dc3eF61f53B954B3DCC86382e7B9] += 1588947591000000;\r\n         totalSupply += 1588947591000000;\r\n         totalGoldSupply += 1106042126000;\r\n         Coinage(numberOfCoinages, 60611110000000, 1588947591000000, 1106042126000, totalGoldSupply, totalSupply);\r\n        \t\t\r\n\t\t\r\n        \/\/ Mint 2\r\n         numberOfCoinages += 1;\r\n         balances[0x097B7b672fe0dc3eF61f53B954B3DCC86382e7B9] += 151127191000000;\r\n         totalSupply += 151127191000000;\r\n         totalGoldSupply += 110134338200;\r\n         Coinage(numberOfCoinages, 6035361000000, 151127191000000, 110134338200, totalGoldSupply, totalSupply);\r\n        \r\n\t\t\r\n\t\t   \/\/ Mint 3\r\n         numberOfCoinages += 1;\r\n         balances[0x097B7b672fe0dc3eF61f53B954B3DCC86382e7B9] += 63789854418800;\r\n         totalSupply += 63789854418800;\r\n         totalGoldSupply +=  46701000000;\r\n         Coinage(numberOfCoinages, 2559215000000, 63789854418800, 46701000000, totalGoldSupply, totalSupply);\r\n        \r\n\r\n\t\t   \/\/ Mint 4\r\n         numberOfCoinages += 1;\r\n         balances[0x097B7b672fe0dc3eF61f53B954B3DCC86382e7B9] +=  393015011191000;\r\n         totalSupply += 393015011191000;\r\n         totalGoldSupply +=  290692000000;\r\n         Coinage(numberOfCoinages, 15929931000000, 393015011191000, 290692000000, totalGoldSupply, totalSupply);\r\n        \r\n\r\n\t\t   \/\/ Mint 5\r\n         numberOfCoinages += 1;\r\n         balances[0x097B7b672fe0dc3eF61f53B954B3DCC86382e7B9] +=  49394793870000;\r\n         totalSupply += 49394793870000;\r\n         totalGoldSupply +=  36891368614;\r\n         Coinage(numberOfCoinages, 2021647000000, 49394793870000, 36891368614, totalGoldSupply, totalSupply);\r\n    }\r\n    \r\n    function freezeCoin(){\r\n        if (msg.sender == owner || msg.sender == dev){\r\n            lockdown = !lockdown;\r\n        }\r\n    }\r\n\r\n    \/* Get balance of the account *\/\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    \/* Send coins *\/\r\n    function transfer(address _to, uint256 _amount) returns (bool status) {\r\n        uint256 goldFee = dataContract.goldFee();\r\n\r\n        if (balances[msg.sender] >= _amount &&                                  \/\/ Check if the sender has enough\r\n            balances[_to] + _amount > balances[_to] &&                          \/\/ Check for overflows\r\n            _amount > goldFee &&                                                \/\/ Check if there is something left after burning fee\r\n            !lockdown &&                                                        \/\/ Check if coin is on lockdown\r\n            lockedAccounts[msg.sender] <= block.number) {                       \/\/ Check if the account is locked\r\n            balances[msg.sender] -= _amount;                                    \/\/ Subtract from the sender minus the fee\r\n            balances[_to] += (_amount - goldFee );                              \/\/ Add the same to the recipient\r\n            Transfer(msg.sender, _to, (_amount - goldFee ));                    \/\/ Notify anyone listening that this transfer took place\r\n            doBurn(msg.sender, goldFee, BurningType.TxtFee);                    \/\/ Notify anyone listening that this burn took place\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    \/* A contract attempts to get the coins and sends them*\/\r\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool status) {\r\n        uint256 goldFee = dataContract.goldFee();\r\n\r\n        if (balances[_from] >= _amount &&                                  \/\/ Check if the sender has enough\r\n            balances[_to] + _amount > balances[_to] &&                          \/\/ Check for overflows\r\n            _amount > goldFee &&                                                \/\/ Check if there is something left after burning fee\r\n            !lockdown &&                                                        \/\/ Check if coin is on lockdown\r\n            lockedAccounts[_from] <= block.number) {                       \/\/ Check if the account is locked\r\n            if (_amount > allowed[_from][msg.sender]){                          \/\/ Check allowance\r\n                return false;\r\n            }\r\n            balances[_from] -= _amount;                                    \/\/ Subtract from the sender minus the fee\r\n            balances[_to] += (_amount - goldFee);                               \/\/ Add the same to the recipient\r\n            Transfer(_from, _to, (_amount - goldFee));                     \/\/ Notify anyone listening that this transfer took place\r\n            doBurn(_from, goldFee, BurningType.TxtFee);                    \r\n            allowed[_from][msg.sender] -= _amount;                              \/\/ Update allowance\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    \/* Allow another contract to spend some tokens in your behalf *\/\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n        returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n        return true;\r\n    }\r\n\r\n     function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    \/* Send coins via proxy *\/\r\n    function transferViaProxy(address _source, address _to, uint256 _amount) returns (bool status, address sendFrom, address sentTo, uint256 sentToAmount, address burnAddress, uint256 burnAmount){\r\n        if (!proxyContract.isProxyLegit(msg.sender)){                                        \/\/ Check if proxy is legit\r\n            return (false, 0, 0, 0, 0, 0);\r\n        }\r\n\r\n        uint256 goldFee = dataContract.goldFee();\r\n\r\n        if (balances[_source] >= _amount &&                                     \/\/ Check if the sender has enough\r\n            balances[_to] + _amount > balances[_to] &&                          \/\/ Check for overflows\r\n            _amount > goldFee &&                                                \/\/ Check if there is something left after burning fee\r\n            !lockdown &&                                                        \/\/ Check if coin is on lockdown\r\n            lockedAccounts[_source] <= block.number) {                          \/\/ Check if the account is locked\r\n            \r\n            balances[_source] -= _amount;                                       \/\/ Subtract from the sender minus the fee\r\n            balances[_to] += (_amount - goldFee );                              \/\/ Add the same to the recipient\r\n            Transfer(_source, _to, ( _amount - goldFee ));                    \/\/ Notify anyone listening that this transfer took place\r\n            doBurn(_source, goldFee, BurningType.TxtFee);                         \/\/ Notify anyone listening that this burn took place\r\n        \r\n            return (true, _source, _to, (_amount - goldFee), burningAdress, goldFee);\r\n        } else {\r\n            return (false, 0, 0, 0, 0, 0);\r\n        }\r\n    }\r\n    \r\n    \/* a contract attempts to get the coins and sends them via proxy *\/\r\n    function transferFromViaProxy(address _source, address _from, address _to, uint256 _amount) returns (bool status, address sendFrom, address sentTo, uint256 sentToAmount, address burnAddress, uint256 burnAmount) {\r\n        if (!proxyContract.isProxyLegit(msg.sender)){                                            \/\/ Check if proxy is legit\r\n            return (false, 0, 0, 0, 0, 0);\r\n        }\r\n\r\n        uint256 goldFee = dataContract.goldFee();\r\n\r\n        if (balances[_from] >= _amount &&                                       \/\/ Check if the sender has enough\r\n            balances[_to] + _amount > balances[_to] &&                          \/\/ Check for overflows\r\n            _amount > goldFee &&                                                \/\/ Check if there is something left after burning fee\r\n            !lockdown &&                                                        \/\/ Check if coin is on lockdown\r\n            lockedAccounts[_from] <= block.number) {                            \/\/ Check if the account is locked\r\n\r\n            if (_amount > allowed[_from][_source]){                             \/\/ Check allowance\r\n                return (false, 0, 0, 0, 0, 0); \r\n            }               \r\n\r\n            balances[_from] -= _amount;                                         \/\/ Subtract from the sender minus the fee\r\n            balances[_to] += ( _amount - goldFee );                             \/\/ Add the same to the recipient\r\n            Transfer(_from, _to, ( _amount - goldFee ));                        \/\/ Notify anyone listening that this transfer took place\r\n            doBurn(_from, goldFee, BurningType.TxtFee);\r\n            allowed[_from][_source] -= _amount;                                 \/\/ Update allowance\r\n            return (true, _from, _to, (_amount - goldFee), burningAdress, goldFee);\r\n        } else {\r\n            return (false, 0, 0, 0, 0, 0);\r\n        }\r\n    }\r\n    \r\n     function approveFromProxy(address _source, address _spender, uint256 _value) returns (bool success) {\r\n        if (!proxyContract.isProxyLegit(msg.sender)){                                        \/\/ Check if proxy is legit\r\n            return false;\r\n        }\r\n        allowed[_source][_spender] = _value;\r\n        Approval(_source, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowanceFromProxy(address _source, address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n    \r\n    \/* -----------------------------------------------------------------------*\/\r\n    \r\n    \/* Lock account for X amount of blocks *\/\r\n    function lockAccount(uint _block) returns (bool answer){\r\n        if (lockedAccounts[msg.sender] < block.number + _block){\r\n            lockedAccounts[msg.sender] = block.number + _block;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function isAccountLocked(address _accountAddress) returns (bool){\r\n        if (lockedAccounts[_accountAddress] > block.number){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    \/\/\/\r\n    \/\/\/ Xaur for gas region\r\n    \/\/\/\r\n\r\n    \/* user get small amout of wei for a small amout of Xaur *\/\r\n    function getGasForXau(address _to) returns (bool sucess){\r\n        uint256 xaurForGasLimit = dataContract.xaurForGasLimit();\r\n        uint256 weiForXau = dataContract.weiForXau();\r\n\r\n        if (balances[msg.sender] > xaurForGasLimit && \r\n            balances[xaurForGasCurrator] < balances[xaurForGasCurrator]  + xaurForGasLimit &&\r\n            this.balance > dataContract.weiForXau()) {\r\n            if (_to.send(dataContract.weiForXau())){\r\n                balances[msg.sender] -= xaurForGasLimit;\r\n                balances[xaurForGasCurrator] += xaurForGasLimit;\r\n                return true;\r\n            }\r\n        } \r\n        return false;\r\n    }\r\n    \r\n    \/* Currator fills eth through this function *\/\r\n    function fillGas(){\r\n        if (msg.sender != xaurForGasCurrator) { \r\n            throw; \r\n        }\r\n    }\r\n\r\n    \/\/\/\r\n    \/\/\/ Melting region\r\n    \/\/\/\r\n\r\n    function doMelt(uint256 _xaurAmount, uint256 _goldAmount) returns (bool){\r\n        if (msg.sender == address(meltingContract)){\r\n            totalSupply -= _xaurAmount;\r\n            totalGoldSupply -= _goldAmount;\r\n            Melt(_xaurAmount, _goldAmount);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    \/\/\/\r\n    \/\/\/ Proxy region\r\n    \/\/\/\r\n\r\n    \r\n\r\n    \/\/\/\r\n    \/\/\/ Coinage region\r\n    \/\/\/\r\n    function doCoinage(address[] _coinageAddresses, uint256[] _coinageAmounts, uint256 _usdAmount, uint256 _xaurCoined, uint256 _goldBought) returns (bool){\r\n        if (msg.sender == address(coinageContract) && \r\n            _coinageAddresses.length == _coinageAmounts.length){\r\n            \r\n            totalSupply += _xaurCoined;\r\n            totalGoldSupply += _goldBought;\r\n            numberOfCoinages += 1;\r\n            Coinage(numberOfCoinages, _usdAmount, _xaurCoined, _goldBought, totalGoldSupply, totalSupply);\r\n            for (uint256 cnt = 0; cnt < _coinageAddresses.length; cnt++){\r\n                balances[_coinageAddresses[cnt]] += _coinageAmounts[cnt]; \r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    \/\/\/\r\n    \/\/\/ Burining region\r\n    \/\/\/\r\n    function doBurn(address _from, uint256 _amountToBurn, BurningType _burningType) internal {\r\n        balances[burningAdress] += _amountToBurn;                              \/\/ Burn the fee\r\n        totalSupply -= _amountToBurn;                                          \/\/ Edit total supply\r\n        Burn(_from, _amountToBurn, _burningType);                              \/\/ Notify anyone listening that this burn took place\r\n    }\r\n\r\n    function doBurnFromContract(address _from, uint256 _amount) returns (bool){\r\n        if (msg.sender == address(alliesContract)){\r\n            balances[_from] -= _amount;\r\n            doBurn(_from, _amount, BurningType.AllyDonation);\r\n            return true;\r\n        }\r\n        else if(msg.sender == address(coinageContract)){\r\n            balances[_from] -= _amount;\r\n            doBurn(_from, _amount, BurningType.ServiceFee);\r\n            return true;\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n\r\n    }\r\n\r\n    \/* This unnamed function is called whenever someone tries to send ether to it *\/\r\n    function () {\r\n        throw;     \/\/ Prevents accidental sending of ether\r\n    }\r\n}\r\n\r\ncontract XaurumMeltingContract {}\r\n\r\ncontract XaurumAlliesContract {}\r\n\r\ncontract XaurumCoinageContract {}\r\n\r\ncontract XaurmProxyContract{\r\n\r\n    address public owner;\r\n    address public curator;\r\n    address public dev;\r\n\r\n    function XaurmProxyContract(){\r\n        dev = msg.sender;\r\n    }\r\n\r\n    function setProxyCurrator(address _newCurratorAdress) returns (bool){\r\n        if (msg.sender == owner || msg.sender == dev){        \r\n            curator = _newCurratorAdress;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function setOwner(address _newOwnerAdress) returns (bool){\r\n        if ( msg.sender == dev ){        \r\n            owner = _newOwnerAdress;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    \/* Proxy Contract *\/\r\n    \r\n    address[] approvedProxys; \r\n    mapping (address => bool) proxyList;\r\n    \r\n    \/* Adds new proxy to proxy lists and grants him the permission to use transferViaProxy *\/\r\n    function addNewProxy(address _proxyAdress){\r\n        if(msg.sender == curator){\r\n            proxyList[_proxyAdress] = true;\r\n            approvedProxys.push(_proxyAdress);\r\n        }\r\n    }\r\n\r\n    function isProxyLegit(address _proxyAddress) returns (bool){\r\n        return proxyList[_proxyAddress];\r\n    }\r\n    \r\n    function getApprovedProxys() returns (address[] proxys){\r\n        return approvedProxys;\r\n    }\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n}\r\n\r\ncontract XaurumDataContract {\r\n\r\n    \/* Minting data *\/\r\n    uint256 public xauToEur;\r\n    uint256 public goldToEur;\r\n    uint256 public mintingDataUpdatedAtBlock;\r\n\r\n    \/* Gas for xaur data *\/\r\n    uint256 public xaurForGasLimit;\r\n    uint256 public weiForXau;\r\n    uint256 public gasForXaurDataUpdateAtBlock;\r\n\r\n    \/* Other data *\/\r\n    uint256 public goldFee;\r\n    uint256 public goldFeeDataUpdatedAtBlock;\r\n\r\n    address public owner;\r\n    address public curator;\r\n    address public dev;\r\n\r\n    function XaurumDataContract(){\r\n        xaurForGasLimit = 100000000;\r\n        weiForXau = 100000000000000000;\r\n        goldFee = 50000000;\r\n       \/\/ dev = _dev;\r\n\t   dev = msg.sender;\r\n    }\r\n\r\n    function setProxyCurrator(address _newCurratorAdress) returns (bool){\r\n        if (msg.sender == owner || msg.sender == dev){        \r\n            curator = _newCurratorAdress;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function setOwner(address _newOwnerAdress) returns (bool){\r\n        if ( msg.sender == dev ){        \r\n            owner = _newOwnerAdress;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function updateMintingData(uint256 _xauToEur, uint256 _goldToEur) returns (bool status){\r\n        if (msg.sender == curator || msg.sender == dev){\r\n            xauToEur = _xauToEur;\r\n            goldToEur = _goldToEur;\r\n            mintingDataUpdatedAtBlock = block.number;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function updateGasForXaurData(uint256 _xaurForGasLimit, uint256 _weiForXau) returns (bool status){\r\n        if (msg.sender == curator || msg.sender == dev){\r\n            xaurForGasLimit = _xaurForGasLimit;\r\n            weiForXau = _weiForXau;\r\n            gasForXaurDataUpdateAtBlock = block.number;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function updateGoldFeeData(uint256 _goldFee) returns (bool status){\r\n        if (msg.sender == curator || msg.sender == dev){\r\n            goldFee = _goldFee;\r\n            goldFeeDataUpdatedAtBlock = block.number;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n}",
      "officialLinks": {
        "Reddit": "",
        "Telegram": "",
        "Website": "https:\/\/www.xaurum.org\/",
        "Email": "",
        "Twitter": "https:\/\/www.twitter.com\/urumproject"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x4DF812F6064def1e5e029f1ca858777CC98D2D81#code"
    }, {
      "contractId": 42,
      "title": "CofounditToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Cofoundit",
      "code": "pragma solidity ^0.4.11;\r\n\r\ncontract owned {\r\n\r\n\taddress public owner;\r\n\r\n\tfunction owned() {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\tmodifier onlyOwner {\r\n\t\tif (msg.sender != owner) throw;\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction transferOwnership(address newOwner) onlyOwner {\r\n\t\towner = newOwner;\r\n\t}\r\n}\r\n\r\ncontract tokenRecipient { \r\n\tfunction receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); \r\n} \r\n\r\ncontract IERC20Token {     \r\n\r\n\t\/\/\/ @return total amount of tokens     \r\n\tfunction totalSupply() constant returns (uint256 totalSupply);     \r\n\r\n\t\/\/\/ @param _owner The address from which the balance will be retrieved     \r\n\t\/\/\/ @return The balance     \r\n\tfunction balanceOf(address _owner) constant returns (uint256 balance) {}     \r\n\r\n\t\/\/\/ @notice send `_value` token to `_to` from `msg.sender`     \r\n\t\/\/\/ @param _to The address of the recipient     \r\n\t\/\/\/ @param _value The amount of token to be transferred     \r\n\t\/\/\/ @return Whether the transfer was successful or not     \r\n\tfunction transfer(address _to, uint256 _value) returns (bool success) {}     \r\n\r\n\t\/\/\/ @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`     \r\n\t\/\/\/ @param _from The address of the sender     \r\n\t\/\/\/ @param _to The address of the recipient     \r\n\t\/\/\/ @param _value The amount of token to be transferred     \r\n\t\/\/\/ @return Whether the transfer was successful or not     \r\n\tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}     \r\n\r\n\t\/\/\/ @notice `msg.sender` approves `_addr` to spend `_value` tokens     \r\n\t\/\/\/ @param _spender The address of the account able to transfer the tokens     \r\n\t\/\/\/ @param _value The amount of wei to be approved for transfer     \r\n\t\/\/\/ @return Whether the approval was successful or not     \r\n\tfunction approve(address _spender, uint256 _value) returns (bool success) {}     \r\n\r\n\t\/\/\/ @param _owner The address of the account owning tokens     \r\n\t\/\/\/ @param _spender The address of the account able to transfer the tokens     \r\n\t\/\/\/ @return Amount of remaining tokens allowed to spent     \r\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {}       \r\n\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);     \r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value); \r\n} \r\n\r\ncontract CofounditToken is IERC20Token, owned{         \r\n\r\n\t\/* Public variables of the token *\/     \r\n\tstring public standard = \"Cofoundit token v1.0\";     \r\n\tstring public name = \"Cofoundit\";     \r\n\tstring public symbol = \"CFI\";     \r\n\tuint8 public decimals = 18;     \r\n\taddress public icoContractAddress;     \r\n\tuint256 public tokenFrozenUntilBlock;     \r\n\r\n\t\/* Private variables of the token *\/     \r\n\tuint256 supply = 0;     \r\n\tmapping (address => uint256) balances;     \r\n\tmapping (address => mapping (address => uint256)) allowances;     \r\n\tmapping (address => bool) restrictedAddresses;     \r\n\r\n\t\/* Events *\/       \r\n\tevent Mint(address indexed _to, uint256 _value);     \r\n\tevent TokenFrozen(uint256 _frozenUntilBlock, string _reason);     \r\n\r\n\t\/* Initializes contract and  sets restricted addresses *\/     \r\n\tfunction CofounditToken(address _icoAddress) {         \r\n\t\trestrictedAddresses[0x0] = true;\t\t\t\/\/ Users cannot send tokens to 0x0 address         \r\n\t\trestrictedAddresses[_icoAddress] = true;\t\/\/ Users cannot send tokens to ico contract         \r\n\t\trestrictedAddresses[address(this)] = true;\t\/\/ Users cannot sent tokens to this contracts address                 \r\n\t\ticoContractAddress = _icoAddress;\t\t\t\/\/ Sets ico contract address from where mints will happen     \r\n\t}         \r\n\r\n\t\/* Get total supply of issued coins *\/     \r\n\tfunction totalSupply() constant returns (uint256 totalSupply) {         \r\n\t\treturn supply;     \r\n\t}         \r\n\r\n\t\/* Get balance of specific address *\/     \r\n\tfunction balanceOf(address _owner) constant returns (uint256 balance) {         \r\n\t\treturn balances[_owner];     \r\n\t}     \r\n\r\n\t\/* Send coins *\/     \r\n\tfunction transfer(address _to, uint256 _value) returns (bool success) {     \t\r\n\t\tif (block.number < tokenFrozenUntilBlock) throw;\t\/\/ Throw is token is frozen in case of emergency         \r\n\t\tif (restrictedAddresses[_to]) throw;                \/\/ Prevent transfer to restricted addresses         \r\n\t\tif (balances[msg.sender] < _value) throw;           \/\/ Check if the sender has enough         \r\n\t\tif (balances[_to] + _value < balances[_to]) throw;  \/\/ Check for overflows         \r\n\t\tbalances[msg.sender] -= _value;                     \/\/ Subtract from the sender         \r\n\t\tbalances[_to] += _value;                            \/\/ Add the same to the recipient         \r\n\t\tTransfer(msg.sender, _to, _value);                  \/\/ Notify anyone listening that this transfer took place         \r\n\t\treturn true;     \r\n\t}     \r\n\r\n\t\/* Allow another contract to spend some tokens in your behalf *\/     \r\n\tfunction approve(address _spender, uint256 _value) returns (bool success) {     \t\r\n\t\tif (block.number < tokenFrozenUntilBlock) throw;\t\/\/ Throw is token is frozen in case of emergency         \r\n\t\tallowances[msg.sender][_spender] = _value;          \/\/ Set allowance         \r\n\t\tApproval(msg.sender, _spender, _value);             \/\/ Raise Approval event         \r\n\t\treturn true;     \r\n\t}     \r\n\r\n\t\/* Approve and then comunicate the approved contract in a single tx *\/     \r\n\tfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {            \r\n\t\ttokenRecipient spender = tokenRecipient(_spender);              \/\/ Cast spender to tokenRecipient contract         \r\n\t\tapprove(_spender, _value);                                      \/\/ Set approval to contract for _value         \r\n\t\tspender.receiveApproval(msg.sender, _value, this, _extraData);  \/\/ Raise method on _spender contract         \r\n\t\treturn true;     \r\n\t}     \r\n\r\n\t\/* A contract attempts to get the coins *\/     \r\n\tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {     \t\r\n\t\tif (block.number < tokenFrozenUntilBlock) throw;\t\/\/ Throw is token is frozen in case of emergency         \r\n\t\tif (restrictedAddresses[_to]) throw;                \/\/ Prevent transfer to restricted addresses         \r\n\t\tif (balances[_from] < _value) throw;                \/\/ Check if the sender has enough         \r\n\t\tif (balances[_to] + _value < balances[_to]) throw;  \/\/ Check for overflows         \r\n\t\tif (_value > allowances[_from][msg.sender]) throw;  \/\/ Check allowance         \r\n\t\tbalances[_from] -= _value;                          \/\/ Subtract from the sender         \r\n\t\tbalances[_to] += _value;                            \/\/ Add the same to the recipient         \r\n\t\tallowances[_from][msg.sender] -= _value;            \/\/ Deduct allowance for this address         \r\n\t\tTransfer(_from, _to, _value);                       \/\/ Notify anyone listening that this transfer took place         \r\n\t\treturn true;     \r\n\t}         \r\n\r\n\t\/* Get the ammount of remaining tokens to spend *\/     \r\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {         \r\n\t\treturn allowances[_owner][_spender];     \r\n\t}         \r\n\r\n\t\/* Create new tokens*\/     \r\n\tfunction mintTokens(address _to, uint256 _amount, string _reason) {         \r\n\t\tif (msg.sender != icoContractAddress) throw;\t\t\t\/\/ Check if minter is ico Contract address         \r\n\t\tif (restrictedAddresses[_to]) throw;                    \/\/ Prevent transfer to restricted addresses         \r\n\t\tif (_amount == 0 || sha3(_reason) == sha3(\"\")) throw;   \/\/ Check if values are not null;         \r\n\t\tif (balances[_to] + _amount < balances[_to]) throw;     \/\/ Check for overflows         \r\n\t\tsupply += _amount;                                      \/\/ Update total supply         \r\n\t\tbalances[_to] += _amount;                    \t\t    \/\/ Set minted coins to target         \r\n\t\tMint(_to, _amount);                          \t\t    \/\/ Create Mint event         \r\n\t\tTransfer(0x0, _to, _amount);                            \/\/ Create Transfer event from 0x     \r\n\t}     \r\n\r\n\t\/* Stops all token transfers in case of emergency *\/     \r\n\tfunction freezeTransfersUntil(uint256 _frozenUntilBlock, string _reason) onlyOwner {     \t\r\n\t\ttokenFrozenUntilBlock = _frozenUntilBlock;     \t\r\n\t\tTokenFrozen(_frozenUntilBlock, _reason);     \r\n\t}     \r\n\t\r\n\t\/* Owner can add new restricted address or removes one *\/\r\n\tfunction editRestrictedAddress(address _newRestrictedAddress) onlyOwner {\r\n\t\trestrictedAddresses[_newRestrictedAddress] = !restrictedAddresses[_newRestrictedAddress];\r\n\t}\r\n\r\n\tfunction isRestrictedAddress(address _querryAddress) constant returns (bool answer){\r\n\t\treturn restrictedAddresses[_querryAddress];\r\n\t}\r\n\r\n\t\/* This unnamed function is called whenever someone tries to send ether to it *\/     \r\n\r\n\tfunction () {         \r\n\t\tthrow;     \/\/ Prevents accidental sending of ether     \r\n\t} \r\n\r\n\t\/\/\r\n\t\/* This part is here only for testing and will not be included into final version *\/\r\n\t\/\/\r\n\r\n\t\/\/function changeICOAddress(address _newAddress) onlyOwner{\r\n\t\/\/\ticoContractAddress = _newAddress;\r\n\t\/\/}\r\n\r\n\t\/\/function killContract() onlyOwner{\r\n\t\/\/\tselfdestruct(msg.sender);\r\n\t\/\/}\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/cofoundit\/",
        "Telegram": "",
        "Website": "https:\/\/cofound.it\/",
        "Email": "mailto:info@cofound.it",
        "Twitter": "https:\/\/twitter.com\/cofound_it"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x12FEF5e57bF45873Cd9B62E9DBd7BFb99e32D73e#code"
    }, {
      "contractId": 43,
      "title": "SAN",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "SAN",
      "code": "pragma solidity ^0.4.11;\r\n\r\n\/\/ ==== DISCLAIMER ====\r\n\/\/\r\n\/\/ ETHEREUM IS STILL AN EXPEREMENTAL TECHNOLOGY.\r\n\/\/ ALTHOUGH THIS SMART CONTRACT WAS CREATED WITH GREAT CARE AND IN THE HOPE OF BEING USEFUL, NO GUARANTEES OF FLAWLESS OPERATION CAN BE GIVEN.\r\n\/\/ IN PARTICULAR - SUBTILE BUGS, HACKER ATTACKS OR MALFUNCTION OF UNDERLYING TECHNOLOGY CAN CAUSE UNINTENTIONAL BEHAVIOUR.\r\n\/\/ YOU ARE STRONGLY ENCOURAGED TO STUDY THIS SMART CONTRACT CAREFULLY IN ORDER TO UNDERSTAND POSSIBLE EDGE CASES AND RISKS.\r\n\/\/ DON'T USE THIS SMART CONTRACT IF YOU HAVE SUBSTANTIAL DOUBTS OR IF YOU DON'T KNOW WHAT YOU ARE DOING.\r\n\/\/\r\n\/\/ THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\r\n\/\/ AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\r\n\/\/ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\r\n\/\/ OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n\/\/ OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\/\/ ====\r\n\/\/\r\n\r\n\/\/\/ @author Santiment LLC\r\n\/\/\/ @title  SAN - santiment token\r\n\r\ncontract Base {\r\n\r\n    function max(uint a, uint b) returns (uint) { return a >= b ? a : b; }\r\n    function min(uint a, uint b) returns (uint) { return a <= b ? a : b; }\r\n\r\n    modifier only(address allowed) {\r\n        if (msg.sender != allowed) throw;\r\n        _;\r\n    }\r\n\r\n\r\n    \/\/\/@return True if `_addr` is a contract\r\n    function isContract(address _addr) constant internal returns (bool) {\r\n        if (_addr == 0) return false;\r\n        uint size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return (size > 0);\r\n    }\r\n\r\n    \/\/ *************************************************\r\n    \/\/ *          reentrancy handling                  *\r\n    \/\/ *************************************************\r\n\r\n    \/\/@dev predefined locks (up to uint bit length, i.e. 256 possible)\r\n    uint constant internal L00 = 2 ** 0;\r\n    uint constant internal L01 = 2 ** 1;\r\n    uint constant internal L02 = 2 ** 2;\r\n    uint constant internal L03 = 2 ** 3;\r\n    uint constant internal L04 = 2 ** 4;\r\n    uint constant internal L05 = 2 ** 5;\r\n\r\n    \/\/prevents reentrancy attacs: specific locks\r\n    uint private bitlocks = 0;\r\n    modifier noReentrancy(uint m) {\r\n        var _locks = bitlocks;\r\n        if (_locks & m > 0) throw;\r\n        bitlocks |= m;\r\n        _;\r\n        bitlocks = _locks;\r\n    }\r\n\r\n    modifier noAnyReentrancy {\r\n        var _locks = bitlocks;\r\n        if (_locks > 0) throw;\r\n        bitlocks = uint(-1);\r\n        _;\r\n        bitlocks = _locks;\r\n    }\r\n\r\n    \/\/\/@dev empty marking modifier signaling to user of the marked function , that it can cause an reentrant call.\r\n    \/\/\/     developer should make the caller function reentrant-safe if it use a reentrant function.\r\n    modifier reentrant { _; }\r\n\r\n}\r\n\r\ncontract Owned is Base {\r\n\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) only(owner) {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() only(newOwner) {\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n}\r\n\r\n\r\ncontract ERC20 is Owned {\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function transfer(address _to, uint256 _value) isStartedOnly returns (bool success) {\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) isStartedOnly returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) isStartedOnly returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    uint256 public totalSupply;\r\n    bool    public isStarted = false;\r\n\r\n    modifier onlyHolder(address holder) {\r\n        if (balanceOf(holder) == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier isStartedOnly() {\r\n        if (!isStarted) throw;\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract SubscriptionModule {\r\n    function attachToken(address addr) public ;\r\n}\r\n\r\ncontract SAN is Owned, ERC20 {\r\n\r\n    string public constant name     = \"SANtiment network token\";\r\n    string public constant symbol   = \"SAN\";\r\n    uint8  public constant decimals = 18;\r\n\r\n    address CROWDSALE_MINTER = 0xDa2Cf810c5718135247628689D84F94c61B41d6A;\r\n    address public SUBSCRIPTION_MODULE = 0x00000000;\r\n    address public beneficiary;\r\n\r\n    uint public PLATFORM_FEE_PER_10000 = 1; \/\/0.01%\r\n    uint public totalOnDeposit;\r\n    uint public totalInCirculation;\r\n\r\n    \/\/\/@dev constructor\r\n    function SAN() {\r\n        beneficiary = owner = msg.sender;\r\n    }\r\n\r\n    \/\/ ------------------------------------------------------------------------\r\n    \/\/ Don't accept ethers\r\n    \/\/ ------------------------------------------------------------------------\r\n    function () {\r\n        throw;\r\n    }\r\n\r\n    \/\/======== SECTION Configuration: Owner only ========\r\n    \/\/\r\n    \/\/\/@notice set beneficiary - the account receiving platform fees.\r\n    function setBeneficiary(address newBeneficiary)\r\n    external\r\n    only(owner) {\r\n        beneficiary = newBeneficiary;\r\n    }\r\n\r\n\r\n    \/\/\/@notice attach module managing subscriptions. if subModule==0x0, then disables subscription functionality for this token.\r\n    \/\/\/ detached module can usually manage subscriptions, but all operations changing token balances are disabled.\r\n    function attachSubscriptionModule(SubscriptionModule subModule)\r\n    noAnyReentrancy\r\n    external\r\n    only(owner) {\r\n        SUBSCRIPTION_MODULE = subModule;\r\n        if (address(subModule) > 0) subModule.attachToken(this);\r\n    }\r\n\r\n    \/\/\/@notice set platform fee denominated in 1\/10000 of SAN token. Thus \"1\" means 0.01% of SAN token.\r\n    function setPlatformFeePer10000(uint newFee)\r\n    external\r\n    only(owner) {\r\n        require (newFee <= 10000); \/\/formally maximum fee is 100% (completely insane but technically possible)\r\n        PLATFORM_FEE_PER_10000 = newFee;\r\n    }\r\n\r\n    function startToken()\r\n    isNotStartedOnly\r\n    only(owner) {\r\n        totalInCirculation = totalSupply;\r\n        isStarted = true;\r\n    }\r\n\r\n    \/\/======== Interface XRateProvider: a trivial exchange rate provider. Rate is 1:1 and SAN symbol as the code\r\n    \/\/\r\n    \/\/\/@dev used as a default XRateProvider (id==0) by subscription module.\r\n    \/\/\/@notice returns always 1 because exchange rate of the token to itself is always 1.\r\n    function getRate() returns(uint32 ,uint32) { return (1,1);  }\r\n    function getCode() public returns(string)  { return symbol; }\r\n\r\n\r\n    \/\/==== Interface ERC20ModuleSupport: Subscription, Deposit and Payment Support =====\r\n    \/\/\/\r\n    \/\/\/@dev used by subscription module to operate on token balances.\r\n    \/\/\/@param msg_sender should be an original msg.sender provided to subscription module.\r\n    function _fulfillPreapprovedPayment(address _from, address _to, uint _value, address msg_sender)\r\n    public\r\n    onlyTrusted\r\n    returns(bool success) {\r\n        success = _from != msg_sender && allowed[_from][msg_sender] >= _value;\r\n        if (!success) {\r\n            Payment(_from, _to, _value, _fee(_value), msg_sender, PaymentStatus.APPROVAL_ERROR, 0);\r\n        } else {\r\n            success = _fulfillPayment(_from, _to, _value, 0, msg_sender);\r\n            if (success) {\r\n                allowed[_from][msg_sender] -= _value;\r\n            }\r\n        }\r\n        return success;\r\n    }\r\n\r\n    \/\/\/@dev used by subscription module to operate on token balances.\r\n    \/\/\/@param msg_sender should be an original msg.sender provided to subscription module.\r\n    function _fulfillPayment(address _from, address _to, uint _value, uint subId, address msg_sender)\r\n    public\r\n    onlyTrusted\r\n    returns (bool success) {\r\n        var fee = _fee(_value);\r\n        assert (fee <= _value); \/\/internal sanity check\r\n        if (balances[_from] >= _value && balances[_to] + _value > balances[_to]) {\r\n            balances[_from] -= _value;\r\n            balances[_to] += _value - fee;\r\n            balances[beneficiary] += fee;\r\n            Payment(_from, _to, _value, fee, msg_sender, PaymentStatus.OK, subId);\r\n            return true;\r\n        } else {\r\n            Payment(_from, _to, _value, fee, msg_sender, PaymentStatus.BALANCE_ERROR, subId);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _fee(uint _value) internal constant returns (uint fee) {\r\n        return _value * PLATFORM_FEE_PER_10000 \/ 10000;\r\n    }\r\n\r\n    \/\/\/@notice used by subscription module to re-create token from returning deposit.\r\n    \/\/\/@dev a subscription module is responsible to correct deposit management.\r\n    function _mintFromDeposit(address owner, uint amount)\r\n    public\r\n    onlyTrusted {\r\n        balances[owner] += amount;\r\n        totalOnDeposit -= amount;\r\n        totalInCirculation += amount;\r\n    }\r\n\r\n    \/\/\/@notice used by subscription module to burn token while creating a new deposit.\r\n    \/\/\/@dev a subscription module is responsible to create and maintain the deposit record.\r\n    function _burnForDeposit(address owner, uint amount)\r\n    public\r\n    onlyTrusted\r\n    returns (bool success) {\r\n        if (balances[owner] >= amount) {\r\n            balances[owner] -= amount;\r\n            totalOnDeposit += amount;\r\n            totalInCirculation -= amount;\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    \r\n    \/\/========= Crowdsale Only ===============\r\n    \/\/\/@notice mint new token for given account in crowdsale stage\r\n    \/\/\/@dev allowed only if token not started yet and only for registered minter.\r\n    \/\/\/@dev tokens are become in circulation after token start.\r\n    function mint(uint amount, address account)\r\n    onlyCrowdsaleMinter\r\n    isNotStartedOnly\r\n    {\r\n        totalSupply += amount;\r\n        balances[account]+=amount;\r\n    }\r\n\r\n    \/\/\/@notice start normal operation of the token. No minting is possible after this point.\r\n    function start()\r\n    onlyCrowdsaleMinter\r\n    isNotStartedOnly {\r\n        totalInCirculation = totalSupply;\r\n        isStarted = true;\r\n    }\r\n\r\n    \/\/========= SECTION: Modifier ===============\r\n\r\n    modifier onlyCrowdsaleMinter() {\r\n        if (msg.sender != CROWDSALE_MINTER) throw;\r\n        _;\r\n    }\r\n\r\n    modifier onlyTrusted() {\r\n        if (msg.sender != SUBSCRIPTION_MODULE) throw;\r\n        _;\r\n    }\r\n\r\n    \/\/\/@dev token not started means minting is possible, but usual token operations are not.\r\n    modifier isNotStartedOnly() {\r\n        if (isStarted) throw;\r\n        _;\r\n    }\r\n\r\n    enum PaymentStatus {OK, BALANCE_ERROR, APPROVAL_ERROR}\r\n    \/\/\/@notice event issued on any fee based payment (made of failed).\r\n    \/\/\/@param subId - related subscription Id if any, or zero otherwise.\r\n    event Payment(address _from, address _to, uint _value, uint _fee, address caller, PaymentStatus status, uint subId);\r\n\r\n}\/\/contract SAN",
      "officialLinks": {
        "Reddit": "",
        "Telegram": "",
        "Website": "https:\/\/santiment.net\/",
        "Email": "",
        "Twitter": "https:\/\/twitter.com\/santimentfeed"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x7c5a0ce9267ed19b22f8cae653f198e3e8daf098#code"
    }, {
      "contractId": 44,
      "title": "MelonToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Melon",
      "code": "pragma solidity ^0.4.8;\r\n\r\n\/\/\/ @title Assertive contract\r\n\/\/\/ @author Melonport AG <[email\u00a0protected]>\r\n\/\/\/ @notice Asserts function\r\ncontract Assertive {\r\n\r\n  function assert(bool assertion) internal {\r\n      if (!assertion) throw;\r\n  }\r\n\r\n}\r\n\r\n\/\/\/ @title Overflow aware uint math functions.\r\n\/\/\/ @author Melonport AG <[email\u00a0protected]>\r\n\/\/\/ @notice Inspired by https:\/\/github.com\/MakerDAO\/maker-otc\/blob\/master\/contracts\/simple_market.sol\r\ncontract SafeMath is Assertive{\r\n\r\n    function safeMul(uint a, uint b) internal returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c \/ a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\n\/\/\/ @title ERC20 Token Protocol\r\n\/\/\/ @author Melonport AG <[email\u00a0protected]>\r\n\/\/\/ @notice See https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\ncontract ERC20Protocol {\r\n\r\n    function totalSupply() constant returns (uint256 totalSupply) {}\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\n\/\/\/ @title ERC20 Token\r\n\/\/\/ @author Melonport AG <[email\u00a0protected]>\r\n\/\/\/ @notice Original taken from https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n\/\/\/ @notice Checked against integer overflow\r\ncontract ERC20 is ERC20Protocol {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    uint256 public totalSupply;\r\n\r\n}\r\n\r\n\r\n\/\/\/ @title Melon Token Contract\r\n\/\/\/ @author Melonport AG <[email\u00a0protected]>\r\ncontract MelonToken is ERC20, SafeMath {\r\n\r\n    \/\/ FIELDS\r\n\r\n    \/\/ Constant token specific fields\r\n    string public constant name = \"Melon Token\";\r\n    string public constant symbol = \"MLN\";\r\n    uint public constant decimals = 18;\r\n    uint public constant THAWING_DURATION = 2 years; \/\/ Time needed for iced tokens to thaw into liquid tokens\r\n    uint public constant MAX_TOTAL_TOKEN_AMOUNT_OFFERED_TO_PUBLIC = 1000000 * 10 ** decimals; \/\/ Max amount of tokens offered to the public\r\n    uint public constant MAX_TOTAL_TOKEN_AMOUNT = 1250000 * 10 ** decimals; \/\/ Max amount of total tokens raised during all contributions (includes stakes of patrons)\r\n\r\n    \/\/ Fields that are only changed in constructor\r\n    address public minter; \/\/ Contribution contract(s)\r\n    address public melonport; \/\/ Can change to other minting contribution contracts but only until total amount of token minted\r\n    uint public startTime; \/\/ Contribution start time in seconds\r\n    uint public endTime; \/\/ Contribution end time in seconds\r\n\r\n    \/\/ Fields that can be changed by functions\r\n    mapping (address => uint) lockedBalances;\r\n\r\n    \/\/ MODIFIERS\r\n\r\n    modifier only_minter {\r\n        assert(msg.sender == minter);\r\n        _;\r\n    }\r\n\r\n    modifier only_melonport {\r\n        assert(msg.sender == melonport);\r\n        _;\r\n    }\r\n\r\n    modifier is_later_than(uint x) {\r\n        assert(now > x);\r\n        _;\r\n    }\r\n\r\n    modifier max_total_token_amount_not_reached(uint amount) {\r\n        assert(safeAdd(totalSupply, amount) <= MAX_TOTAL_TOKEN_AMOUNT);\r\n        _;\r\n    }\r\n\r\n    \/\/ CONSTANT METHODS\r\n\r\n    function lockedBalanceOf(address _owner) constant returns (uint balance) {\r\n        return lockedBalances[_owner];\r\n    }\r\n\r\n    \/\/ METHODS\r\n\r\n    \/\/\/ Pre: All fields, except { minter, melonport, startTime, endTime } are valid\r\n    \/\/\/ Post: All fields, including { minter, melonport, startTime, endTime } are valid\r\n    function MelonToken(address setMinter, address setMelonport, uint setStartTime, uint setEndTime) {\r\n        minter = setMinter;\r\n        melonport = setMelonport;\r\n        startTime = setStartTime;\r\n        endTime = setEndTime;\r\n    }\r\n\r\n    \/\/\/ Pre: Address of contribution contract (minter) is set\r\n    \/\/\/ Post: Mints token into tradeable tranche\r\n    function mintLiquidToken(address recipient, uint amount)\r\n        external\r\n        only_minter\r\n        max_total_token_amount_not_reached(amount)\r\n    {\r\n        balances[recipient] = safeAdd(balances[recipient], amount);\r\n        totalSupply = safeAdd(totalSupply, amount);\r\n    }\r\n\r\n    \/\/\/ Pre: Address of contribution contract (minter) is set\r\n    \/\/\/ Post: Mints Token into iced tranche. Become liquid after completion of the melonproject or two years.\r\n    function mintIcedToken(address recipient, uint amount)\r\n        external\r\n        only_minter\r\n        max_total_token_amount_not_reached(amount)\r\n    {\r\n        lockedBalances[recipient] = safeAdd(lockedBalances[recipient], amount);\r\n        totalSupply = safeAdd(totalSupply, amount);\r\n    }\r\n\r\n    \/\/\/ Pre: Thawing period has passed - iced funds have turned into liquid ones\r\n    \/\/\/ Post: All funds available for trade\r\n    function unlockBalance(address recipient)\r\n        is_later_than(endTime + THAWING_DURATION)\r\n    {\r\n        balances[recipient] = safeAdd(balances[recipient], lockedBalances[recipient]);\r\n        lockedBalances[recipient] = 0;\r\n    }\r\n\r\n    \/\/\/ Pre: Prevent transfers until contribution period is over.\r\n    \/\/\/ Post: Transfer MLN from msg.sender\r\n    \/\/\/ Note: ERC20 interface\r\n    function transfer(address recipient, uint amount)\r\n        is_later_than(endTime)\r\n        returns (bool success)\r\n    {\r\n        return super.transfer(recipient, amount);\r\n    }\r\n\r\n    \/\/\/ Pre: Prevent transfers until contribution period is over.\r\n    \/\/\/ Post: Transfer MLN from arbitrary address\r\n    \/\/\/ Note: ERC20 interface\r\n    function transferFrom(address sender, address recipient, uint amount)\r\n        is_later_than(endTime)\r\n        returns (bool success)\r\n    {\r\n        return super.transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    \/\/\/ Pre: Melonport address is set. Restricted to melonport.\r\n    \/\/\/ Post: New minter can now create tokens up to MAX_TOTAL_TOKEN_AMOUNT.\r\n    \/\/\/ Note: This allows additional contribution periods at a later stage, while still using the same ERC20 compliant contract.\r\n    function changeMintingAddress(address newAddress) only_melonport { minter = newAddress; }\r\n\r\n    \/\/\/ Pre: Melonport address is set. Restricted to melonport.\r\n    \/\/\/ Post: New address set. This address controls the setting of the minter address\r\n    function changeMelonportAddress(address newAddress) only_melonport { melonport = newAddress; }\r\n}\r\n\r\n\r\n\/\/\/ @title Contribution Contract\r\n\/\/\/ @author Melonport AG <[email\u00a0protected]>\r\n\/\/\/ @notice This follows Condition-Orientated Programming as outlined here:\r\n\/\/\/ @notice   https:\/\/medium.com\/@gavofyork\/condition-orientated-programming-969f6ba0161a#.saav3bvva\r\ncontract Contribution is SafeMath {\r\n\r\n    \/\/ FIELDS\r\n\r\n    \/\/ Constant fields\r\n    uint public constant ETHER_CAP = 227000 ether; \/\/ Max amount raised during first contribution; targeted amount CHF 2.5MN\r\n    uint public constant MAX_CONTRIBUTION_DURATION = 4 weeks; \/\/ Max amount in seconds of contribution period\r\n    uint public constant BTCS_ETHER_CAP = ETHER_CAP * 25 \/ 100; \/\/ Max melon token allocation for btcs before contribution period starts\r\n    \/\/ Price Rates\r\n    uint public constant PRICE_RATE_FIRST = 2200; \/\/ Four price tiers, each valid for two weeks\r\n    uint public constant PRICE_RATE_SECOND = 2150;\r\n    uint public constant PRICE_RATE_THIRD = 2100;\r\n    uint public constant PRICE_RATE_FOURTH = 2050;\r\n    uint public constant DIVISOR_PRICE = 1000; \/\/ Price rates are divided by this number\r\n    \/\/ Addresses of Patrons\r\n    address public constant FOUNDER_ONE = 0x009beAE06B0c0C536ad1eA43D6f61DCCf0748B1f;\r\n    address public constant FOUNDER_TWO = 0xB1EFca62C555b49E67363B48aE5b8Af3C7E3e656;\r\n    address public constant EXT_COMPANY_ONE = 0x00779e0e4c6083cfd26dE77B4dbc107A7EbB99d2;\r\n    address public constant EXT_COMPANY_TWO = 0x1F06B976136e94704D328D4d23aae7259AaC12a2;\r\n    address public constant EXT_COMPANY_THREE = 0xDD91615Ea8De94bC48231c4ae9488891F1648dc5;\r\n    address public constant ADVISOR_ONE = 0x0001126FC94AE0be2B685b8dE434a99B2552AAc3;\r\n    address public constant ADVISOR_TWO = 0x4f2AF8d2614190Cc80c6E9772B0C367db8D9753C;\r\n    address public constant ADVISOR_THREE = 0x715a70a7c7d76acc8d5874862e381c1940c19cce;\r\n    address public constant ADVISOR_FOUR = 0x8615F13C12c24DFdca0ba32511E2861BE02b93b2;\r\n    address public constant AMBASSADOR_ONE = 0xd3841FB80CE408ca7d0b41D72aA91CA74652AF47;\r\n    address public constant AMBASSADOR_TWO = 0xDb775577538018a689E4Ad2e8eb5a7Ae7c34722B;\r\n    address public constant AMBASSADOR_THREE = 0xaa967e0ce6A1Ff5F9c124D15AD0412F137C99767;\r\n    address public constant AMBASSADOR_FOUR = 0x910B41a6568a645437bC286A5C733f3c501d8c88;\r\n    address public constant AMBASSADOR_FIVE = 0xb1d16BFE840E66E3c81785551832aAACB4cf69f3;\r\n    address public constant AMBASSADOR_SIX = 0x5F6ff16364BfEf546270325695B6e90cc89C497a;\r\n    address public constant AMBASSADOR_SEVEN = 0x58656e8872B0d266c2acCD276cD23F4C0B5fEfb9;\r\n    address public constant SPECIALIST_ONE = 0x8a815e818E617d1f93BE7477D179258aC2d25310;\r\n    address public constant SPECIALIST_TWO = 0x1eba6702ba21cfc1f6c87c726364b60a5e444901;\r\n    address public constant SPECIALIST_THREE = 0x82eae6c30ed9606e2b389ae65395648748c6a17f;\r\n    \/\/ Stakes of Patrons\r\n    uint public constant MELONPORT_COMPANY_STAKE = 1000; \/\/ 10% of all created melon token allocated to melonport company\r\n    uint public constant FOUNDER_STAKE = 445; \/\/ 4.45% of all created melon token allocated to founder\r\n    uint public constant EXT_COMPANY_STAKE_ONE = 150; \/\/ 1.5% of all created melon token allocated to external company\r\n    uint public constant EXT_COMPANY_STAKE_TWO = 100; \/\/ 1% of all created melon token allocated to external company\r\n    uint public constant EXT_COMPANY_STAKE_THREE = 50; \/\/ 0.5% of all created melon token allocated to external company\r\n    uint public constant ADVISOR_STAKE_ONE = 150; \/\/ 1.5% of all created melon token allocated to advisor\r\n    uint public constant ADVISOR_STAKE_TWO = 50; \/\/ 0.5% of all created melon token allocated to advisor\r\n    uint public constant ADVISOR_STAKE_THREE = 25; \/\/ 0.25% of all created melon token allocated to advisor\r\n    uint public constant ADVISOR_STAKE_FOUR = 10; \/\/ 0.1% of all created melon token allocated to advisor\r\n    uint public constant AMBASSADOR_STAKE = 5; \/\/ 0.05% of all created melon token allocated to ambassadors\r\n    uint public constant SPECIALIST_STAKE_ONE = 25; \/\/ 0.25% of all created melon token allocated to specialist\r\n    uint public constant SPECIALIST_STAKE_TWO = 10; \/\/ 0.1% of all created melon token allocated to specialist\r\n    uint public constant SPECIALIST_STAKE_THREE = 5; \/\/ 0.05% of all created melon token allocated to specialist\r\n    uint public constant DIVISOR_STAKE = 10000; \/\/ Stakes are divided by this number; Results to one basis point\r\n\r\n    \/\/ Fields that are only changed in constructor\r\n    address public melonport; \/\/ All deposited ETH will be instantly forwarded to this address.\r\n    address public btcs; \/\/ Bitcoin Suisse address for their allocation option\r\n    address public signer; \/\/ Signer address as on https:\/\/contribution.melonport.com\r\n    uint public startTime; \/\/ Contribution start time in seconds\r\n    uint public endTime; \/\/ Contribution end time in seconds\r\n    MelonToken public melonToken; \/\/ Contract of the ERC20 compliant melon token\r\n\r\n    \/\/ Fields that can be changed by functions\r\n    uint public etherRaised; \/\/ This will keep track of the Ether raised during the contribution\r\n    bool public halted; \/\/ The melonport address can set this to true to halt the contribution due to an emergency\r\n\r\n    \/\/ EVENTS\r\n\r\n    event TokensBought(address indexed sender, uint eth, uint amount);\r\n\r\n    \/\/ MODIFIERS\r\n\r\n    modifier is_signer_signature(uint8 v, bytes32 r, bytes32 s) {\r\n        bytes32 hash = sha256(msg.sender);\r\n        assert(ecrecover(hash, v, r, s) == signer);\r\n        _;\r\n    }\r\n\r\n    modifier only_melonport {\r\n        assert(msg.sender == melonport);\r\n        _;\r\n    }\r\n\r\n    modifier only_btcs {\r\n        assert(msg.sender == btcs);\r\n        _;\r\n    }\r\n\r\n    modifier is_not_halted {\r\n        assert(!halted);\r\n        _;\r\n    }\r\n\r\n    modifier ether_cap_not_reached {\r\n        assert(safeAdd(etherRaised, msg.value) <= ETHER_CAP);\r\n        _;\r\n    }\r\n\r\n    modifier btcs_ether_cap_not_reached {\r\n        assert(safeAdd(etherRaised, msg.value) <= BTCS_ETHER_CAP);\r\n        _;\r\n    }\r\n\r\n    modifier is_not_earlier_than(uint x) {\r\n        assert(now >= x);\r\n        _;\r\n    }\r\n\r\n    modifier is_earlier_than(uint x) {\r\n        assert(now < x);\r\n        _;\r\n    }\r\n\r\n    \/\/ CONSTANT METHODS\r\n\r\n    \/\/\/ Pre: startTime, endTime specified in constructor,\r\n    \/\/\/ Post: Price rate at given blockTime; One ether equals priceRate() \/ DIVISOR_PRICE of melon tokens\r\n    function priceRate() constant returns (uint) {\r\n        \/\/ Four price tiers\r\n        if (startTime <= now && now < startTime + 1 weeks)\r\n            return PRICE_RATE_FIRST;\r\n        if (startTime + 1 weeks <= now && now < startTime + 2 weeks)\r\n            return PRICE_RATE_SECOND;\r\n        if (startTime + 2 weeks <= now && now < startTime + 3 weeks)\r\n            return PRICE_RATE_THIRD;\r\n        if (startTime + 3 weeks <= now && now < endTime)\r\n            return PRICE_RATE_FOURTH;\r\n        \/\/ Should not be called before or after contribution period\r\n        assert(false);\r\n    }\r\n\r\n    \/\/ NON-CONSTANT METHODS\r\n\r\n    \/\/\/ Pre: All fields, except { melonport, btcs, signer, startTime } are valid\r\n    \/\/\/ Post: All fields, including { melonport, btcs, signer, startTime } are valid\r\n    function Contribution(address setMelonport, address setBTCS, address setSigner, uint setStartTime) {\r\n        melonport = setMelonport;\r\n        btcs = setBTCS;\r\n        signer = setSigner;\r\n        startTime = setStartTime;\r\n        endTime = startTime + MAX_CONTRIBUTION_DURATION;\r\n        melonToken = new MelonToken(this, melonport, startTime, endTime); \/\/ Create Melon Token Contract\r\n        var maxTotalTokenAmountOfferedToPublic = melonToken.MAX_TOTAL_TOKEN_AMOUNT_OFFERED_TO_PUBLIC();\r\n        uint stakeMultiplier = maxTotalTokenAmountOfferedToPublic \/ DIVISOR_STAKE;\r\n        \/\/ Mint liquid tokens for melonport company, liquid means tradeale\r\n        melonToken.mintLiquidToken(melonport,       MELONPORT_COMPANY_STAKE * stakeMultiplier);\r\n        \/\/ Mint iced tokens that are unable to trade for two years and allocate according to relevant stakes\r\n        melonToken.mintIcedToken(FOUNDER_ONE,       FOUNDER_STAKE *           stakeMultiplier);\r\n        melonToken.mintIcedToken(FOUNDER_TWO,       FOUNDER_STAKE *           stakeMultiplier);\r\n        melonToken.mintIcedToken(EXT_COMPANY_ONE,   EXT_COMPANY_STAKE_ONE *   stakeMultiplier);\r\n        melonToken.mintIcedToken(EXT_COMPANY_TWO,   EXT_COMPANY_STAKE_TWO *   stakeMultiplier);\r\n        melonToken.mintIcedToken(EXT_COMPANY_THREE, EXT_COMPANY_STAKE_THREE * stakeMultiplier);\r\n        melonToken.mintIcedToken(ADVISOR_ONE,       ADVISOR_STAKE_ONE *       stakeMultiplier);\r\n        melonToken.mintIcedToken(ADVISOR_TWO,       ADVISOR_STAKE_TWO *       stakeMultiplier);\r\n        melonToken.mintIcedToken(ADVISOR_THREE,     ADVISOR_STAKE_THREE *     stakeMultiplier);\r\n        melonToken.mintIcedToken(ADVISOR_FOUR,      ADVISOR_STAKE_FOUR *      stakeMultiplier);\r\n        melonToken.mintIcedToken(AMBASSADOR_ONE,    AMBASSADOR_STAKE *        stakeMultiplier);\r\n        melonToken.mintIcedToken(AMBASSADOR_TWO,    AMBASSADOR_STAKE *        stakeMultiplier);\r\n        melonToken.mintIcedToken(AMBASSADOR_THREE,  AMBASSADOR_STAKE *        stakeMultiplier);\r\n        melonToken.mintIcedToken(AMBASSADOR_FOUR,   AMBASSADOR_STAKE *        stakeMultiplier);\r\n        melonToken.mintIcedToken(AMBASSADOR_FIVE,   AMBASSADOR_STAKE *        stakeMultiplier);\r\n        melonToken.mintIcedToken(AMBASSADOR_SIX,    AMBASSADOR_STAKE *        stakeMultiplier);\r\n        melonToken.mintIcedToken(AMBASSADOR_SEVEN,  AMBASSADOR_STAKE *        stakeMultiplier);\r\n        melonToken.mintIcedToken(SPECIALIST_ONE,    SPECIALIST_STAKE_ONE *    stakeMultiplier);\r\n        melonToken.mintIcedToken(SPECIALIST_TWO,    SPECIALIST_STAKE_TWO *    stakeMultiplier);\r\n        melonToken.mintIcedToken(SPECIALIST_THREE,  SPECIALIST_STAKE_THREE *  stakeMultiplier);\r\n    }\r\n\r\n    \/\/\/ Pre: Valid signature received from https:\/\/contribution.melonport.com\r\n    \/\/\/ Post: Bought melon tokens according to priceRate() and msg.value\r\n    function buy(uint8 v, bytes32 r, bytes32 s) payable { buyRecipient(msg.sender, v, r, s); }\r\n\r\n    \/\/\/ Pre: Valid signature received from https:\/\/contribution.melonport.com\r\n    \/\/\/ Post: Bought melon tokens according to priceRate() and msg.value on behalf of recipient\r\n    function buyRecipient(address recipient, uint8 v, bytes32 r, bytes32 s)\r\n        payable\r\n        is_signer_signature(v, r, s)\r\n        is_not_earlier_than(startTime)\r\n        is_earlier_than(endTime)\r\n        is_not_halted\r\n        ether_cap_not_reached\r\n    {\r\n        uint amount = safeMul(msg.value, priceRate()) \/ DIVISOR_PRICE;\r\n        melonToken.mintLiquidToken(recipient, amount);\r\n        etherRaised = safeAdd(etherRaised, msg.value);\r\n        assert(melonport.send(msg.value));\r\n        TokensBought(recipient, msg.value, amount);\r\n    }\r\n\r\n    \/\/\/ Pre: BTCS before contribution period, BTCS has exclusive right to buy up to 25% of all melon tokens\r\n    \/\/\/ Post: Bought melon tokens according to PRICE_RATE_FIRST and msg.value on behalf of recipient\r\n    function btcsBuyRecipient(address recipient)\r\n        payable\r\n        only_btcs\r\n        is_earlier_than(startTime)\r\n        is_not_halted\r\n        btcs_ether_cap_not_reached\r\n    {\r\n        uint amount = safeMul(msg.value, PRICE_RATE_FIRST) \/ DIVISOR_PRICE;\r\n        melonToken.mintLiquidToken(recipient, amount);\r\n        etherRaised = safeAdd(etherRaised, msg.value);\r\n        assert(melonport.send(msg.value));\r\n        TokensBought(recipient, msg.value, amount);\r\n    }\r\n\r\n    \/\/\/ Pre: Emergency situation that requires contribution period to stop.\r\n    \/\/\/ Post: Contributing not possible anymore.\r\n    function halt() only_melonport { halted = true; }\r\n\r\n    \/\/\/ Pre: Emergency situation resolved.\r\n    \/\/\/ Post: Contributing becomes possible again withing the outlined restrictions.\r\n    function unhalt() only_melonport { halted = false; }\r\n\r\n    \/\/\/ Pre: Restricted to melonport.\r\n    \/\/\/ Post: New address set. To halt contribution and\/or change minter in MelonToken contract.\r\n    function changeMelonportAddress(address newAddress) only_melonport { melonport = newAddress; }\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/melonproject\/",
        "Telegram": "",
        "Website": "https:\/\/melonport.com\/",
        "Email": "mailto:team@melonport.com",
        "Twitter": "https:\/\/twitter.com\/melonport"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xBEB9eF514a379B997e0798FDcC901Ee474B6D9A1#code"
    }, {
      "contractId": 45,
      "title": "NEToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "NimiqNetwork",
      "code": "pragma solidity ^0.4.11;\r\n\r\n\/* taking ideas from FirstBlood token *\/\r\ncontract SafeMath {\r\n\r\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\r\n        uint256 z = x + y;\r\n        assert((z >= x) && (z >= y));\r\n        return z;\r\n    }\r\n\r\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\r\n        assert(x >= y);\r\n        uint256 z = x - y;\r\n        return z;\r\n    }\r\n\r\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\r\n        uint256 z = x * y;\r\n        assert((x == 0)||(z\/x == y));\r\n        return z;\r\n    }\r\n}\r\n\r\ncontract Token {\r\n    uint256 public totalSupply;\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\/*  ERC 20 token *\/\r\ncontract StandardToken is Token, SafeMath {\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    modifier onlyPayloadSize(uint numwords) {\r\n        assert(msg.data.length == numwords * 32 + 4);\r\n        _;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value)\r\n    returns (bool success)\r\n    {\r\n        if (balances[msg.sender] >= _value && _value > 0 && balances[_to] + _value > balances[_to]) {\r\n            balances[msg.sender] = safeSubtract(balances[msg.sender], _value);\r\n            balances[_to] = safeAdd(balances[_to], _value);\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n    returns (bool success)\r\n    {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0 && balances[_to] + _value > balances[_to]) {\r\n            balances[_to] = safeAdd(balances[_to], _value);\r\n            balances[_from] = safeSubtract(balances[_from], _value);\r\n            allowed[_from][msg.sender] = safeSubtract(allowed[_from][msg.sender], _value);\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value)\r\n    onlyPayloadSize(2)\r\n    returns (bool success)\r\n    {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender)\r\n    constant\r\n    onlyPayloadSize(2)\r\n    returns (uint256 remaining)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\n\/* Taking ideas from BAT token *\/\r\ncontract NEToken is StandardToken {\r\n\r\n    \/\/ Token metadata\r\n    string public constant name = \"Nimiq Network Interim Token\";\r\n    string public constant symbol = \"NET\";\r\n    uint256 public constant decimals = 18;\r\n    string public version = \"0.8\";\r\n\r\n    \/\/ Deposit address of Multisig account controlled by the creators\r\n    address public ethFundDeposit;\r\n\r\n    \/\/ Fundraising parameters\r\n    enum ContractState { Fundraising, Finalized, Redeeming, Paused }\r\n    ContractState public state;           \/\/ Current state of the contract\r\n    ContractState private savedState;     \/\/ State of the contract before pause\r\n\r\n    uint256 public fundingStartBlock;        \/\/ These two blocks need to be chosen to comply with the\r\n    uint256 public fundingEndBlock;          \/\/ start date and 28 day duration requirements\r\n    uint256 public exchangeRateChangesBlock; \/\/ block number that triggers the exchange rate change\r\n\r\n    uint256 public constant TOKEN_FIRST_EXCHANGE_RATE = 175; \/\/ 175 NETs per 1 ETH\r\n    uint256 public constant TOKEN_SECOND_EXCHANGE_RATE = 125; \/\/ 125 NETs per 1 ETH\r\n    uint256 public constant TOKEN_CREATION_CAP = 10.5 * (10**6) * 10**decimals; \/\/ 10.5 million NETs\r\n    uint256 public constant ETH_RECEIVED_CAP = 60 * (10**3) * 10**decimals; \/\/ 60 000 ETH\r\n    uint256 public constant ETH_RECEIVED_MIN = 5 * (10**3) * 10**decimals; \/\/ 5 000 ETH\r\n    uint256 public constant TOKEN_MIN = 1 * 10**decimals; \/\/ 1 NET\r\n\r\n    \/\/ We need to keep track of how much ether have been contributed, since we have a cap for ETH too\r\n    uint256 public totalReceivedEth = 0;\r\n\r\n    \/\/ Since we have different exchange rates at different stages, we need to keep track\r\n    \/\/ of how much ether each contributed in case that we need to issue a refund\r\n    mapping (address => uint256) private ethBalances;\r\n\r\n    \/\/ Events used for logging\r\n    event LogRefund(address indexed _to, uint256 _value);\r\n    event LogCreateNET(address indexed _to, uint256 _value);\r\n    event LogRedeemNET(address indexed _to, uint256 _value, bytes32 _nimiqAddress);\r\n\r\n    modifier isFinalized() {\r\n        require(state == ContractState.Finalized);\r\n        _;\r\n    }\r\n\r\n    modifier isFundraising() {\r\n        require(state == ContractState.Fundraising);\r\n        _;\r\n    }\r\n\r\n    modifier isRedeeming() {\r\n        require(state == ContractState.Redeeming);\r\n        _;\r\n    }\r\n\r\n    modifier isPaused() {\r\n        require(state == ContractState.Paused);\r\n        _;\r\n    }\r\n\r\n    modifier notPaused() {\r\n        require(state != ContractState.Paused);\r\n        _;\r\n    }\r\n\r\n    modifier isFundraisingIgnorePaused() {\r\n        require(state == ContractState.Fundraising || (state == ContractState.Paused && savedState == ContractState.Fundraising));\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == ethFundDeposit);\r\n        _;\r\n    }\r\n\r\n    modifier minimumReached() {\r\n        require(totalReceivedEth >= ETH_RECEIVED_MIN);\r\n        _;\r\n    }\r\n\r\n    \/\/ Constructor\r\n    function NEToken(\r\n    address _ethFundDeposit,\r\n    uint256 _fundingStartBlock,\r\n    uint256 _fundingEndBlock,\r\n    uint256 _exchangeRateChangesBlock)\r\n    {\r\n        \/\/ Check that the parameters make sense\r\n        require(block.number <= _fundingStartBlock); \/\/ The start of the fundraising should happen in the future\r\n        require(_fundingStartBlock <= _exchangeRateChangesBlock); \/\/ The exchange rate change should happen after the start of the fundraising\r\n        require(_exchangeRateChangesBlock <= _fundingEndBlock); \/\/ And the end of the fundraising should happen after the exchange rate change\r\n\r\n        \/\/ Contract state\r\n        state = ContractState.Fundraising;\r\n        savedState = ContractState.Fundraising;\r\n\r\n        ethFundDeposit = _ethFundDeposit;\r\n        fundingStartBlock = _fundingStartBlock;\r\n        fundingEndBlock = _fundingEndBlock;\r\n        exchangeRateChangesBlock = _exchangeRateChangesBlock;\r\n        totalSupply = 0;\r\n    }\r\n\r\n    \/\/ Overridden method to check for end of fundraising before allowing transfer of tokens\r\n    function transfer(address _to, uint256 _value)\r\n    isFinalized \/\/ Only allow token transfer after the fundraising has ended\r\n    onlyPayloadSize(2)\r\n    returns (bool success)\r\n    {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n\r\n    \/\/ Overridden method to check for end of fundraising before allowing transfer of tokens\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n    isFinalized \/\/ Only allow token transfer after the fundraising has ended\r\n    onlyPayloadSize(3)\r\n    returns (bool success)\r\n    {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n\r\n    \/\/\/ @dev Accepts ether and creates new NET tokens\r\n    function createTokens()\r\n    payable\r\n    external\r\n    isFundraising\r\n    {\r\n        require(block.number >= fundingStartBlock);\r\n        require(block.number <= fundingEndBlock);\r\n        require(msg.value > 0);\r\n\r\n        \/\/ First we check the ETH cap, as it's easier to calculate, return\r\n        \/\/ the contribution if the cap has been reached already\r\n        uint256 checkedReceivedEth = safeAdd(totalReceivedEth, msg.value);\r\n        require(checkedReceivedEth <= ETH_RECEIVED_CAP);\r\n\r\n        \/\/ If all is fine with the ETH cap, we continue to check the\r\n        \/\/ minimum amount of tokens and the cap for how many tokens\r\n        \/\/ have been generated so far\r\n        uint256 tokens = safeMult(msg.value, getCurrentTokenPrice());\r\n        require(tokens >= TOKEN_MIN);\r\n        uint256 checkedSupply = safeAdd(totalSupply, tokens);\r\n        require(checkedSupply <= TOKEN_CREATION_CAP);\r\n\r\n        \/\/ Only when all the checks have passed, then we update the state (ethBalances,\r\n        \/\/ totalReceivedEth, totalSupply, and balances) of the contract\r\n        ethBalances[msg.sender] = safeAdd(ethBalances[msg.sender], msg.value);\r\n        totalReceivedEth = checkedReceivedEth;\r\n        totalSupply = checkedSupply;\r\n        balances[msg.sender] += tokens;  \/\/ safeAdd not needed; bad semantics to use here\r\n\r\n        \/\/ Log the creation of this tokens\r\n        LogCreateNET(msg.sender, tokens);\r\n    }\r\n\r\n\r\n    \/\/\/ @dev Returns the current token price\r\n    function getCurrentTokenPrice()\r\n    private\r\n    constant\r\n    returns (uint256 currentPrice)\r\n    {\r\n        if (block.number < exchangeRateChangesBlock) {\r\n            return TOKEN_FIRST_EXCHANGE_RATE;\r\n        } else {\r\n            return TOKEN_SECOND_EXCHANGE_RATE;\r\n        }\r\n    }\r\n\r\n\r\n    \/\/\/ @dev Redeems NETs and records the Nimiq address of the sender\r\n    function redeemTokens(bytes32 nimiqAddress)\r\n    external\r\n    isRedeeming\r\n    {\r\n        uint256 netVal = balances[msg.sender];\r\n        require(netVal >= TOKEN_MIN); \/\/ At least TOKEN_MIN tokens have to be redeemed\r\n\r\n        \/\/ Move the tokens of the caller to Nimiq's address\r\n        if (!super.transfer(ethFundDeposit, netVal)) throw;\r\n\r\n        \/\/ Log the redeeming of this tokens\r\n        LogRedeemNET(msg.sender, netVal, nimiqAddress);\r\n    }\r\n\r\n\r\n    \/\/\/ @dev Allows to transfer ether from the contract as soon as the minimum is reached\r\n    function retrieveEth(uint256 _value)\r\n    external\r\n    minimumReached\r\n    onlyOwner\r\n    {\r\n        require(_value <= this.balance);\r\n\r\n        \/\/ send the eth to Nimiq Creators\r\n        ethFundDeposit.transfer(_value);\r\n    }\r\n\r\n\r\n    \/\/\/ @dev Ends the fundraising period and sends the ETH to the Multisig wallet\r\n    function finalize()\r\n    external\r\n    isFundraising\r\n    minimumReached\r\n    onlyOwner \/\/ Only the owner of the ethFundDeposit address can finalize the contract\r\n    {\r\n        require(block.number > fundingEndBlock || totalSupply >= TOKEN_CREATION_CAP || totalReceivedEth >= ETH_RECEIVED_CAP); \/\/ Only allow to finalize the contract before the ending block if we already reached any of the two caps\r\n\r\n        \/\/ Move the contract to Finalized state\r\n        state = ContractState.Finalized;\r\n        savedState = ContractState.Finalized;\r\n\r\n        \/\/ Send the ETH to Nimiq Creators\r\n        ethFundDeposit.transfer(this.balance);\r\n    }\r\n\r\n\r\n    \/\/\/ @dev Starts the redeeming period\r\n    function startRedeeming()\r\n    external\r\n    isFinalized \/\/ The redeeming period can only be started after the contract is finalized\r\n    onlyOwner   \/\/ Only the owner of the ethFundDeposit address can start the redeeming period\r\n    {\r\n        \/\/ Move the contract to Redeeming state\r\n        state = ContractState.Redeeming;\r\n        savedState = ContractState.Redeeming;\r\n    }\r\n\r\n\r\n    \/\/\/ @dev Pauses the contract\r\n    function pause()\r\n    external\r\n    notPaused   \/\/ Prevent the contract getting stuck in the Paused state\r\n    onlyOwner   \/\/ Only the owner of the ethFundDeposit address can pause the contract\r\n    {\r\n        \/\/ Move the contract to Paused state\r\n        savedState = state;\r\n        state = ContractState.Paused;\r\n    }\r\n\r\n\r\n    \/\/\/ @dev Proceeds with the contract\r\n    function proceed()\r\n    external\r\n    isPaused\r\n    onlyOwner   \/\/ Only the owner of the ethFundDeposit address can proceed with the contract\r\n    {\r\n        \/\/ Move the contract to the previous state\r\n        state = savedState;\r\n    }\r\n\r\n\r\n    \/\/\/ @dev Allows contributors to recover their ether in case the minimum funding goal is not reached\r\n    function refund()\r\n    external\r\n    isFundraisingIgnorePaused \/\/ Refunding is only possible in the fundraising phase (no matter if paused) by definition\r\n    {\r\n        require(block.number > fundingEndBlock); \/\/ Prevents refund until fundraising period is over\r\n        require(totalReceivedEth < ETH_RECEIVED_MIN);  \/\/ No refunds if the minimum has been reached\r\n\r\n        uint256 netVal = balances[msg.sender];\r\n        require(netVal > 0);\r\n        uint256 ethVal = ethBalances[msg.sender];\r\n        require(ethVal > 0);\r\n\r\n        \/\/ Update the state only after all the checks have passed\r\n        balances[msg.sender] = 0;\r\n        ethBalances[msg.sender] = 0;\r\n        totalSupply = safeSubtract(totalSupply, netVal); \/\/ Extra safe\r\n\r\n        \/\/ Log this refund\r\n        LogRefund(msg.sender, ethVal);\r\n\r\n        \/\/ Send the contributions only after we have updated all the balances\r\n        \/\/ If you're using a contract, make sure it works with .transfer() gas limits\r\n        msg.sender.transfer(ethVal);\r\n    }\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/Nimiq\/",
        "Telegram": "",
        "Website": "https:\/\/nimiq.com",
        "Email": "",
        "Twitter": "https:\/\/twitter.com\/nimiqnetwork"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xcfb98637bcae43C13323EAa1731cED2B716962fD#code"
    }, {
      "contractId": 46,
      "title": "ExchangeUnion Token",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "ExchangeUnion",
      "code": "\/*\r\n * ERC20 interface\r\n * see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n *\/\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\/**\r\n * Math operations with safety checks\r\n *\/\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a \/ b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n\/**\r\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\r\n *\r\n * Based on code by FirstBlood:\r\n * https:\/\/github.com\/Firstbloodio\/token\/blob\/master\/smart_contract\/FirstBloodToken.sol\r\n *\/\r\ncontract StandardToken is ERC20, SafeMath {\r\n\r\n  \/* Actual balances of token holders *\/\r\n  mapping(address => uint) balances;\r\n\r\n  \/* approve() allowances *\/\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  \/* Interface declaration *\/\r\n  function isToken() public constant returns (bool weAre) {\r\n    return true;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) returns (bool success) {\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n    uint _allowance = allowed[_from][msg.sender];\r\n\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n\r\n    \/\/ To change the approve amount you first have to reduce the addresses`\r\n    \/\/  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    \/\/  already 0 to mitigate the race condition described here:\r\n    \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\n\r\n\/**\r\n * Upgrade agent interface inspired by Lunyr.\r\n *\r\n * Upgrade agent transfers tokens to a new version of a token contract.\r\n * Upgrade agent can be set on a token by the upgrade master.\r\n *\r\n * Steps are\r\n * - Upgradeabletoken.upgradeMaster calls UpgradeableToken.setUpgradeAgent()\r\n * - Individual token holders can now call UpgradeableToken.upgrade()\r\n *   -> This results to call UpgradeAgent.upgradeFrom() that issues new tokens\r\n *   -> UpgradeableToken.upgrade() reduces the original total supply based on amount of upgraded tokens\r\n *\r\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\r\n *\/\r\ncontract UpgradeAgent {\r\n\r\n  uint public originalSupply;\r\n\r\n  \/** Interface marker *\/\r\n  function isUpgradeAgent() public constant returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   * Upgrade amount of tokens to a new version.\r\n   *\r\n   * Only callable by UpgradeableToken.\r\n   *\r\n   * @param _tokenHolder Address that wants to upgrade its tokens\r\n   * @param _amount Number of tokens to upgrade. The address may consider to hold back some amount of tokens in the old version.\r\n   *\/\r\n  function upgradeFrom(address _tokenHolder, uint256 _amount) external;\r\n}\r\n\r\n\r\n\/**\r\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\r\n *\r\n * First envisioned by Golem and Lunyr projects.\r\n *\/\r\ncontract UpgradeableToken is StandardToken {\r\n\r\n  \/** Contract \/ person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. *\/\r\n  address public upgradeMaster;\r\n\r\n  \/** The next contract where the tokens will be migrated. *\/\r\n  UpgradeAgent public upgradeAgent;\r\n\r\n  \/** How many tokens we have upgraded by now. *\/\r\n  uint256 public totalUpgraded;\r\n\r\n  \/**\r\n   * Upgrade states.\r\n   *\r\n   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\r\n   * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet\r\n   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet\r\n   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\r\n   *\r\n   *\/\r\n  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\r\n\r\n  \/**\r\n   * Somebody has upgraded some of his tokens.\r\n   *\/\r\n  event Upgrade(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n  \/**\r\n   * New upgrade agent available.\r\n   *\/\r\n  event UpgradeAgentSet(address agent);\r\n\r\n  \/**\r\n   * Upgrade master updated.\r\n   *\/\r\n  event NewUpgradeMaster(address upgradeMaster);\r\n\r\n  \/**\r\n   * Do not allow construction without upgrade master set.\r\n   *\/\r\n  function UpgradeableToken(address _upgradeMaster) {\r\n    upgradeMaster = _upgradeMaster;\r\n    NewUpgradeMaster(upgradeMaster);\r\n  }\r\n\r\n  \/**\r\n   * Allow the token holder to upgrade some of their tokens to a new contract.\r\n   *\/\r\n  function upgrade(uint256 value) public {\r\n\r\n      UpgradeState state = getUpgradeState();\r\n      if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\r\n        \/\/ Called in a bad state\r\n        throw;\r\n      }\r\n\r\n      \/\/ Validate input value.\r\n      if (value == 0) throw;\r\n\r\n      balances[msg.sender] = safeSub(balances[msg.sender], value);\r\n\r\n      \/\/ Take tokens out from circulation\r\n      totalSupply = safeSub(totalSupply, value);\r\n      totalUpgraded = safeAdd(totalUpgraded, value);\r\n\r\n      \/\/ Upgrade agent reissues the tokens\r\n      upgradeAgent.upgradeFrom(msg.sender, value);\r\n      Upgrade(msg.sender, upgradeAgent, value);\r\n  }\r\n\r\n  \/**\r\n   * Set an upgrade agent that handles\r\n   *\/\r\n  function setUpgradeAgent(address agent) external {\r\n\r\n      if(!canUpgrade()) {\r\n        \/\/ The token is not yet in a state that we could think upgrading\r\n        throw;\r\n      }\r\n\r\n      if (agent == 0x0) throw;\r\n      \/\/ Only a master can designate the next agent\r\n      if (msg.sender != upgradeMaster) throw;\r\n      \/\/ Upgrade has already begun for an agent\r\n      if (getUpgradeState() == UpgradeState.Upgrading) throw;\r\n\r\n      upgradeAgent = UpgradeAgent(agent);\r\n\r\n      \/\/ Bad interface\r\n      if(!upgradeAgent.isUpgradeAgent()) throw;\r\n      \/\/ Make sure that token supplies match in source and target\r\n      if (upgradeAgent.originalSupply() != totalSupply) throw;\r\n\r\n      UpgradeAgentSet(upgradeAgent);\r\n  }\r\n\r\n  \/**\r\n   * Get the state of the token upgrade.\r\n   *\/\r\n  function getUpgradeState() public constant returns(UpgradeState) {\r\n    if(!canUpgrade()) return UpgradeState.NotAllowed;\r\n    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\r\n    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\r\n    else return UpgradeState.Upgrading;\r\n  }\r\n\r\n  \/**\r\n   * Change the upgrade master.\r\n   *\r\n   * This allows us to set a new owner for the upgrade mechanism.\r\n   *\/\r\n  function setUpgradeMaster(address master) public {\r\n      if (master == 0x0) throw;\r\n      if (msg.sender != upgradeMaster) throw;\r\n      upgradeMaster = master;\r\n      NewUpgradeMaster(upgradeMaster);\r\n  }\r\n\r\n  \/**\r\n   * Child contract can enable to provide the condition when the upgrade can begun.\r\n   *\/\r\n  function canUpgrade() public constant returns(bool) {\r\n     return true;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\/**\r\n * Centrally issued Ethereum token.\r\n *\r\n * We mix in burnable and upgradeable traits.\r\n *\r\n * Token supply is created in the token contract creation and allocated to owner.\r\n * The owner can then transfer from its supply to crowdsale participants.\r\n * The owner, or anybody, can burn any excessive tokens they are holding.\r\n *\r\n *\/\r\ncontract CentrallyIssuedToken is UpgradeableToken {\r\n\r\n  \/\/ Token meta information\r\n  string public name;\r\n  string public symbol;\r\n  uint public decimals;\r\n\r\n  \/\/ Token release switch\r\n  bool public released = false;\r\n\r\n  \/\/ The date before the release must be finalized or upgrade path will be forced\r\n  uint public releaseFinalizationDate;\r\n\r\n  \/** Name and symbol were updated. *\/\r\n  event UpdatedTokenInformation(string newName, string newSymbol);\r\n\r\n  function CentrallyIssuedToken(address _owner, string _name, string _symbol, uint _totalSupply, uint _decimals, uint _releaseFinalizationDate)  UpgradeableToken(_owner) {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    totalSupply = _totalSupply;\r\n    decimals = _decimals;\r\n\r\n    \/\/ Allocate initial balance to the owner\r\n    balances[_owner] = _totalSupply;\r\n\r\n    releaseFinalizationDate = _releaseFinalizationDate;\r\n  }\r\n\r\n  \/**\r\n   * Owner can update token information here.\r\n   *\r\n   * It is often useful to conceal the actual token association, until\r\n   * the token operations, like central issuance or reissuance have been completed.\r\n   * In this case the initial token can be supplied with empty name and symbol information.\r\n   *\r\n   * This function allows the token owner to rename the token after the operations\r\n   * have been completed and then point the audience to use the token contract.\r\n   *\/\r\n  function setTokenInformation(string _name, string _symbol) {\r\n\r\n    if(msg.sender != upgradeMaster) {\r\n      throw;\r\n    }\r\n\r\n    if(bytes(name).length > 0 || bytes(symbol).length > 0) {\r\n      \/\/ Information already set\r\n      \/\/ Allow owner to set this information only once\r\n      throw;\r\n    }\r\n\r\n    name = _name;\r\n    symbol = _symbol;\r\n    UpdatedTokenInformation(name, symbol);\r\n  }\r\n\r\n\r\n  \/**\r\n   * Kill switch for the token in the case of distribution issue.\r\n   *\r\n   *\/\r\n  function transfer(address _to, uint _value) returns (bool success) {\r\n\r\n    if(now > releaseFinalizationDate) {\r\n      if(!released) {\r\n        throw;\r\n      }\r\n    }\r\n\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  \/**\r\n   * One way function to perform the final token release.\r\n   *\/\r\n  function releaseTokenTransfer() {\r\n    if(msg.sender != upgradeMaster) {\r\n      throw;\r\n    }\r\n\r\n    released = true;\r\n  }\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/ExchangeUnion\/",
        "Telegram": "https:\/\/t.me\/exchangeunioncoin",
        "Website": "https:\/\/www.exchangeunion.com\/",
        "Email": "",
        "Twitter": "https:\/\/twitter.com\/exchange_union"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xc324a2f6b05880503444451b8b27e6f9e63287cb#code"
    }, {
      "contractId": 47,
      "title": "IndorseToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Indorse",
      "code": "pragma solidity ^0.4.11;\r\n\r\n\/\/ ================= Ownable Contract start =============================\r\n\/*\r\n * Ownable\r\n *\r\n * Base contract with an owner.\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\n *\/\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    \r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n}\r\n\/\/ ================= Ownable Contract end ===============================\r\n\r\n\/\/ ================= Safemath Contract start ============================\r\n\/* taking ideas from FirstBlood token *\/\r\ncontract SafeMath {\r\n\r\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\r\n      uint256 z = x + y;\r\n      assert((z >= x) && (z >= y));\r\n      return z;\r\n    }\r\n\r\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\r\n      assert(x >= y);\r\n      uint256 z = x - y;\r\n      return z;\r\n    }\r\n\r\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\r\n      uint256 z = x * y;\r\n      assert((x == 0)||(z\/x == y));\r\n      return z;\r\n    }\r\n}\r\n\/\/ ================= Safemath Contract end ==============================\r\n\r\n\/\/ ================= ERC20 Token Contract start =========================\r\n\/*\r\n * ERC20 interface\r\n * see https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n *\/\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\/\/ ================= ERC20 Token Contract end ===========================\r\n\r\n\/\/ ================= Standard Token Contract start ======================\r\ncontract StandardToken is ERC20, SafeMath {\r\n\r\n  \/**\r\n   * @dev Fix for the ERC20 short address attack.\r\n   *\/\r\n  modifier onlyPayloadSize(uint size) {\r\n     require(msg.data.length >= size + 4) ;\r\n     _;\r\n  }\r\n\r\n  mapping(address => uint) balances;\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32)  returns (bool success){\r\n    balances[msg.sender] = safeSubtract(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) returns (bool success) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    \/\/ Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met\r\n    \/\/ if (_value > _allowance) throw;\r\n\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSubtract(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSubtract(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n}\r\n\/\/ ================= Standard Token Contract end ========================\r\n\r\n\/\/ ================= Pausable Token Contract start ======================\r\n\/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n *\/\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  \/**\r\n   * @dev modifier to allow actions only when the contract IS paused\r\n   *\/\r\n  modifier whenNotPaused() {\r\n    require (!paused);\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev modifier to allow actions only when the contract IS NOT paused\r\n   *\/\r\n  modifier whenPaused {\r\n    require (paused) ;\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   *\/\r\n  function pause() onlyOwner whenNotPaused returns (bool) {\r\n    paused = true;\r\n    Pause();\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   *\/\r\n  function unpause() onlyOwner whenPaused returns (bool) {\r\n    paused = false;\r\n    Unpause();\r\n    return true;\r\n  }\r\n}\r\n\/\/ ================= Pausable Token Contract end ========================\r\n\r\n\/\/ ================= Indorse Token Contract start =======================\r\ncontract IndorseToken is SafeMath, StandardToken, Pausable {\r\n    \/\/ metadata\r\n    string public constant name = \"Indorse Token\";\r\n    string public constant symbol = \"IND\";\r\n    uint256 public constant decimals = 18;\r\n    string public version = \"1.0\";\r\n\r\n    \/\/ contracts\r\n    address public indSaleDeposit        = 0x0053B91E38B207C97CBff06f48a0f7Ab2Dd81449;      \/\/ deposit address for Indorse Sale contract\r\n    address public indSeedDeposit        = 0x0083fdFB328fC8D07E2a7933e3013e181F9798Ad;      \/\/ deposit address for Indorse Seed Contributors\r\n    address public indPresaleDeposit     = 0x007AB99FBf023Cb41b50AE7D24621729295EdBFA;      \/\/ deposit address for Indorse Presale Contributors\r\n    address public indVestingDeposit     = 0x0011349f715cf59F75F0A00185e7B1c36f55C3ab;      \/\/ deposit address for Indorse Vesting for team and advisors\r\n    address public indCommunityDeposit   = 0x0097ec8840E682d058b24E6e19E68358d97A6E5C;      \/\/ deposit address for Indorse Marketing, etc\r\n    address public indFutureDeposit      = 0x00d1bCbCDE9Ca431f6dd92077dFaE98f94e446e4;      \/\/ deposit address for Indorse Future token sale\r\n    address public indInflationDeposit   = 0x00D31206E625F1f30039d1Fa472303E71317870A;      \/\/ deposit address for Indorse Inflation pool\r\n    \r\n    uint256 public constant indSale      = 31603785 * 10**decimals;                         \r\n    uint256 public constant indSeed      = 3566341  * 10**decimals; \r\n    uint256 public constant indPreSale   = 22995270 * 10**decimals;                       \r\n    uint256 public constant indVesting   = 28079514 * 10**decimals;  \r\n    uint256 public constant indCommunity = 10919811 * 10**decimals;  \r\n    uint256 public constant indFuture    = 58832579 * 10**decimals;  \r\n    uint256 public constant indInflation = 14624747 * 10**decimals;  \r\n   \r\n    \/\/ constructor\r\n    function IndorseToken()\r\n    {\r\n      balances[indSaleDeposit]           = indSale;                                         \/\/ Deposit IND share\r\n      balances[indSeedDeposit]           = indSeed;                                         \/\/ Deposit IND share\r\n      balances[indPresaleDeposit]        = indPreSale;                                      \/\/ Deposit IND future share\r\n      balances[indVestingDeposit]        = indVesting;                                      \/\/ Deposit IND future share\r\n      balances[indCommunityDeposit]      = indCommunity;                                    \/\/ Deposit IND future share\r\n      balances[indFutureDeposit]         = indFuture;                                       \/\/ Deposit IND future share\r\n      balances[indInflationDeposit]      = indInflation;                                    \/\/ Deposit for inflation\r\n\r\n      totalSupply = indSale + indSeed + indPreSale + indVesting + indCommunity + indFuture + indInflation;\r\n\r\n      Transfer(0x0,indSaleDeposit,indSale);\r\n      Transfer(0x0,indSeedDeposit,indSeed);\r\n      Transfer(0x0,indPresaleDeposit,indPreSale);\r\n      Transfer(0x0,indVestingDeposit,indVesting);\r\n      Transfer(0x0,indCommunityDeposit,indCommunity);\r\n      Transfer(0x0,indFutureDeposit,indFuture);\r\n      Transfer(0x0,indInflationDeposit,indInflation);\r\n   }\r\n\r\n  function transfer(address _to, uint _value) whenNotPaused returns (bool success)  {\r\n    return super.transfer(_to,_value);\r\n  }\r\n\r\n  function approve(address _spender, uint _value) whenNotPaused returns (bool success)  {\r\n    return super.approve(_spender,_value);\r\n  }\r\n}\r\n\/\/ ================= Indorse Token Contract end =======================\r\n\r\n\/\/ ================= Actual Sale Contract Start ====================\r\ncontract IndorseSaleContract is  Ownable,SafeMath,Pausable {\r\n    IndorseToken    ind;\r\n\r\n    \/\/ crowdsale parameters\r\n    uint256 public fundingStartTime = 1502193600;\r\n    uint256 public fundingEndTime   = 1504785600;\r\n    uint256 public totalSupply;\r\n    address public ethFundDeposit   = 0x26967201d4D1e1aA97554838dEfA4fC4d010FF6F;      \/\/ deposit address for ETH for Indorse Fund\r\n    address public indFundDeposit   = 0x0053B91E38B207C97CBff06f48a0f7Ab2Dd81449;      \/\/ deposit address for Indorse reserve\r\n    address public indAddress       = 0xf8e386EDa857484f5a12e4B5DAa9984E06E73705;\r\n\r\n    bool public isFinalized;                                                            \/\/ switched to true in operational state\r\n    uint256 public constant decimals = 18;                                              \/\/ #dp in Indorse contract\r\n    uint256 public tokenCreationCap;\r\n    uint256 public constant tokenExchangeRate = 1000;                                   \/\/ 1000 IND tokens per 1 ETH\r\n    uint256 public constant minContribution = 0.05 ether;\r\n    uint256 public constant maxTokens = 1 * (10 ** 6) * 10**decimals;\r\n    uint256 public constant MAX_GAS_PRICE = 50000000000 wei;                            \/\/ maximum gas price for contribution transactions\r\n \r\n    function IndorseSaleContract() {\r\n        ind = IndorseToken(indAddress);\r\n        tokenCreationCap = ind.balanceOf(indFundDeposit);\r\n        isFinalized = false;\r\n    }\r\n\r\n    event MintIND(address from, address to, uint256 val);\r\n    event LogRefund(address indexed _to, uint256 _value);\r\n\r\n    function CreateIND(address to, uint256 val) internal returns (bool success){\r\n        MintIND(indFundDeposit,to,val);\r\n        return ind.transferFrom(indFundDeposit,to,val);\r\n    }\r\n\r\n    function () payable {    \r\n        createTokens(msg.sender,msg.value);\r\n    }\r\n\r\n    \/\/\/ @dev Accepts ether and creates new IND tokens.\r\n    function createTokens(address _beneficiary, uint256 _value) internal whenNotPaused {\r\n      require (tokenCreationCap > totalSupply);                                         \/\/ CAP reached no more please\r\n      require (now >= fundingStartTime);\r\n      require (now <= fundingEndTime);\r\n      require (_value >= minContribution);                                              \/\/ To avoid spam transactions on the network    \r\n      require (!isFinalized);\r\n      require (tx.gasprice <= MAX_GAS_PRICE);\r\n\r\n      uint256 tokens = safeMult(_value, tokenExchangeRate);                             \/\/ check that we're not over totals\r\n      uint256 checkedSupply = safeAdd(totalSupply, tokens);\r\n\r\n      require (ind.balanceOf(msg.sender) + tokens <= maxTokens);\r\n      \r\n      \/\/ DA 8\/6\/2017 to fairly allocate the last few tokens\r\n      if (tokenCreationCap < checkedSupply) {        \r\n        uint256 tokensToAllocate = safeSubtract(tokenCreationCap,totalSupply);\r\n        uint256 tokensToRefund   = safeSubtract(tokens,tokensToAllocate);\r\n        totalSupply = tokenCreationCap;\r\n        uint256 etherToRefund = tokensToRefund \/ tokenExchangeRate;\r\n\r\n        require(CreateIND(_beneficiary,tokensToAllocate));                              \/\/ Create IND\r\n        msg.sender.transfer(etherToRefund);\r\n        LogRefund(msg.sender,etherToRefund);\r\n        ethFundDeposit.transfer(this.balance);\r\n        return;\r\n      }\r\n      \/\/ DA 8\/6\/2017 end of fair allocation code\r\n\r\n      totalSupply = checkedSupply;\r\n      require(CreateIND(_beneficiary, tokens));                                         \/\/ logs token creation\r\n      ethFundDeposit.transfer(this.balance);\r\n    }\r\n    \r\n    \/\/\/ @dev Ends the funding period and sends the ETH home\r\n    function finalize() external onlyOwner {\r\n      require (!isFinalized);\r\n      \/\/ move to operational\r\n      isFinalized = true;\r\n      ethFundDeposit.transfer(this.balance);                                            \/\/ send the eth to Indorse multi-sig\r\n    }\r\n}",
      "officialLinks": {
        "Reddit": "",
        "Telegram": "",
        "Website": "https:\/\/indorse.io\/",
        "Email": "mailto:info@indorse.io",
        "Twitter": "https:\/\/twitter.com\/joinIndorse"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xf8e386EDa857484f5a12e4B5DAa9984E06E73705#code"
    }, {
      "contractId": 48,
      "title": "HelloGoldToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "HelloGold",
      "code": "pragma solidity ^0.4.11;\r\n\r\n\r\ncontract DoNotDeployThisGetTheRightOneCosParityPutsThisOnTop {\r\n    uint256 nothing;\r\n\r\n    function DoNotDeployThisGetTheRightOneCosParityPutsThisOnTop() {\r\n        nothing = 27;\r\n    }\r\n}\r\n\r\n\r\n\/\/*************** Ownable\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    \r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\/\/***********Pausible\r\n\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n  \/**\r\n   * @dev modifier to allow actions only when the contract IS paused\r\n   *\/\r\n  modifier whenNotPaused() {\r\n    require (!paused);\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev modifier to allow actions only when the contract IS NOT paused\r\n   *\/\r\n  modifier whenPaused {\r\n    require (paused) ;\r\n    _;\r\n  }\r\n\r\n  \/**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   *\/\r\n  function pause() onlyOwner whenNotPaused returns (bool) {\r\n    paused = true;\r\n    Pause();\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   *\/\r\n  function unpause() onlyOwner whenPaused returns (bool) {\r\n    paused = false;\r\n    Unpause();\r\n    return true;\r\n  }\r\n}\r\n\r\n\/\/*************ERC20\r\n\r\ncontract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\/\/*************** SafeMath\r\n\r\ncontract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c \/ a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a \/ b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n}\r\n\r\n\/\/**************** StandardToken\r\n\r\ncontract StandardToken is ERC20, SafeMath {\r\n\r\n  \/**\r\n   * @dev Fix for the ERC20 short address attack.\r\n   *\/\r\n  modifier onlyPayloadSize(uint size) {\r\n     require(msg.data.length >= size + 4);\r\n     _;\r\n  }\r\n\r\n  mapping(address => uint) balances;\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32)  returns (bool success){\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) returns (bool success) {\r\n    var _allowance = allowed[_from][msg.sender];\r\n\r\n    \/\/ Check is not needed because safeSub(_allowance, _value) will already throw if this condition is not met\r\n    \/\/ if (_value > _allowance) throw;\r\n\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n}\r\n\r\ncontract GBT {\r\n  function parentChange(address,uint);\r\n  function parentFees(address);\r\n  function setHGT(address _hgt);\r\n}\r\n\r\n\/\/************ HELLOGOLDTOKEN\r\n\r\ncontract HelloGoldToken is ERC20, SafeMath, Pausable, StandardToken {\r\n\r\n  string public name;\r\n  string public symbol;\r\n  uint8  public decimals;\r\n\r\n  GBT  goldtoken;\r\n  \r\n\r\n  function setGBT(address gbt_) onlyOwner {\r\n    goldtoken = GBT(gbt_);\r\n  }\r\n\r\n  function GBTAddress() constant returns (address) {\r\n    return address(goldtoken);\r\n  }\r\n\r\n  function HelloGoldToken(address _reserve) {\r\n    name = \"HelloGold Token\";\r\n    symbol = \"HGT\";\r\n    decimals = 8;\r\n \r\n    totalSupply = 1 * 10 ** 9 * 10 ** uint256(decimals);\r\n    balances[_reserve] = totalSupply;\r\n  }\r\n\r\n\r\n  function parentChange(address _to) internal {\r\n    require(address(goldtoken) != 0x0);\r\n    goldtoken.parentChange(_to,balances[_to]);\r\n  }\r\n  function parentFees(address _to) internal {\r\n    require(address(goldtoken) != 0x0);\r\n    goldtoken.parentFees(_to);\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success){\r\n    parentFees(_from);\r\n    parentFees(_to);\r\n    success = super.transferFrom(_from,_to,_value);\r\n    parentChange(_from);\r\n    parentChange(_to);\r\n    return;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) whenNotPaused returns (bool success)  {\r\n    parentFees(msg.sender);\r\n    parentFees(_to);\r\n    success = super.transfer(_to,_value);\r\n    parentChange(msg.sender);\r\n    parentChange(_to);\r\n    return;\r\n  }\r\n\r\n  function approve(address _spender, uint _value) whenNotPaused returns (bool success)  {\r\n    return super.approve(_spender,_value);\r\n  }\r\n}\r\n\r\n\/\/********* GOLDFEES ************************\r\n\r\ncontract GoldFees is SafeMath,Ownable {\r\n    \/\/ e.g. if rate = 0.0054\r\n    \/\/uint rateN = 9999452055;\r\n    uint rateN = 9999452054794520548;\r\n    uint rateD = 19;\r\n    uint public maxDays;\r\n    uint public maxRate;\r\n\r\n    \r\n    function GoldFees() {\r\n        calcMax();\r\n    }\r\n\r\n    function calcMax() {\r\n        maxDays = 1;\r\n        maxRate = rateN;\r\n        \r\n        \r\n        uint pow = 2;\r\n        do {\r\n            uint newN = rateN ** pow;\r\n            if (newN \/ maxRate != maxRate) {\r\n                maxDays = pow \/ 2;\r\n                break;\r\n            }\r\n            maxRate = newN;\r\n            pow *= 2;\r\n        } while (pow < 2000);\r\n        \r\n    }\r\n\r\n    function updateRate(uint256 _n, uint256 _d) onlyOwner{\r\n        rateN = _n;\r\n        rateD = _d;\r\n        calcMax();\r\n    }\r\n    \r\n    function rateForDays(uint256 numDays) constant returns (uint256 rate) {\r\n        if (numDays <= maxDays) {\r\n            uint r = rateN ** numDays;\r\n            uint d = rateD * numDays;\r\n            if (d > 18) {\r\n                uint div =  10 ** (d-18);\r\n                rate = r \/ div;\r\n            } else {\r\n                div = 10 ** (18 - d);\r\n                rate = r * div;\r\n            }\r\n        } else {\r\n            uint256 md1 = numDays \/ 2;\r\n            uint256 md2 = numDays - md1;\r\n             uint256 r2;\r\n\r\n            uint256 r1 = rateForDays(md1);\r\n            if (md1 == md2) {\r\n                r2 = r1;\r\n            } else {\r\n                r2 = rateForDays(md2);\r\n            }\r\n           \r\n\r\n            \/\/uint256 r1 = rateForDays(maxDays);\r\n            \/\/uint256 r2 = rateForDays(numDays-maxDays);\r\n            rate  = safeMul( r1 , r2)  \/ 10 ** 18;\r\n        }\r\n        return; \r\n        \r\n    }\r\n\r\n    uint256 constant public UTC2MYT = 1483200000;\r\n\r\n    function wotDay(uint256 time) returns (uint256) {\r\n        return (time - UTC2MYT) \/ (1 days);\r\n    }\r\n\r\n    \/\/ minimum fee is 1 unless same day\r\n    function calcFees(uint256 start, uint256 end, uint256 startAmount) constant returns (uint256 amount, uint256 fee) {\r\n        if (startAmount == 0) return;\r\n        uint256 numberOfDays = wotDay(end) - wotDay(start);\r\n        if (numberOfDays == 0) {\r\n            amount = startAmount;\r\n            return;\r\n        }\r\n        amount = (rateForDays(numberOfDays) * startAmount) \/ (1 ether);\r\n        if ((fee == 0) && (amount !=  0)) amount--;\r\n        fee = safeSub(startAmount,amount);\r\n    }\r\n}\r\n\r\n\/\/******************** GoldBackedToken\r\n\r\ncontract GoldBackedToken is Ownable, SafeMath, ERC20, Pausable {\r\n\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n  event DeductFees(address indexed owner,uint256 amount);\r\n\r\n  event TokenMinted(address destination, uint256 amount);\r\n  event TokenBurned(address source, uint256 amount);\r\n  \r\n\tstring public name = \"HelloGold Gold Backed Token\";\r\n\tstring public symbol = \"GBT\";\r\n\tuint256 constant public  decimals = 18;  \/\/ same as ETH\r\n\tuint256 constant public  hgtDecimals = 8;\r\n\t\t\r\n\tuint256 constant public allocationPool = 1 *  10**9 * 10**hgtDecimals;      \/\/ total HGT holdings\r\n\tuint256\tconstant public\tmaxAllocation  = 38 * 10**5 * 10**decimals;\t\t\t\/\/ max GBT that can ever ever be given out\r\n\tuint256\t         public\ttotAllocation;\t\t\t\/\/ amount of GBT so far\r\n\t\r\n\taddress\t\t\t public feeCalculator;\r\n\taddress\t\t     public HGT;\t\t\t\t\t\/\/ HGT contract address\r\n\r\n\r\n\r\n\tfunction setFeeCalculator(address newFC) onlyOwner {\r\n\t\tfeeCalculator = newFC;\r\n\t}\r\n\r\n\r\n\tfunction calcFees(uint256 from, uint256 to, uint256 amount) returns (uint256 val, uint256 fee) {\r\n\t\treturn GoldFees(feeCalculator).calcFees(from,to,amount);\r\n\t}\r\n\r\n\tfunction GoldBackedToken(address feeCalc) {\r\n\t\tfeeCalculator = feeCalc;\r\n\t}\r\n\r\n    struct allocation { \r\n        uint256     amount;\r\n        uint256     date;\r\n    }\r\n\t\r\n\tallocation[]   public allocationsOverTime;\r\n\tallocation[]   public currentAllocations;\r\n\r\n\tfunction currentAllocationLength() constant returns (uint256) {\r\n\t\treturn currentAllocations.length;\r\n\t}\r\n\r\n\tfunction aotLength() constant returns (uint256) {\r\n\t\treturn allocationsOverTime.length;\r\n\t}\r\n\r\n\t\r\n    struct Balance {\r\n        uint256 amount;                 \/\/ amount through update or transfer\r\n        uint256 lastUpdated;            \/\/ DATE last updated\r\n        uint256 nextAllocationIndex;    \/\/ which allocationsOverTime record contains next update\r\n        uint256 allocationShare;        \/\/ the share of allocationPool that this holder gets (means they hold HGT)\r\n    }\r\n\r\n\t\/*Creates an array with all balances*\/\r\n\tmapping (address => Balance) public balances;\r\n\tmapping (address => mapping (address => uint)) allowed;\r\n\t\r\n\tfunction update(address where) internal {\r\n        uint256 pos;\r\n\t\tuint256 fees;\r\n\t\tuint256 val;\r\n        (val,fees,pos) = updatedBalance(where);\r\n\t    balances[where].nextAllocationIndex = pos;\r\n\t    balances[where].amount = val;\r\n        balances[where].lastUpdated = now;\r\n\t}\r\n\t\r\n\tfunction updatedBalance(address where) constant public returns (uint val, uint fees, uint pos) {\r\n\t\tuint256 c_val;\r\n\t\tuint256 c_fees;\r\n\t\tuint256 c_amount;\r\n\r\n\t\t(val, fees) = calcFees(balances[where].lastUpdated,now,balances[where].amount);\r\n\r\n\t    pos = balances[where].nextAllocationIndex;\r\n\t\tif ((pos < currentAllocations.length) &&  (balances[where].allocationShare != 0)) {\r\n\r\n\t\t\tc_amount = currentAllocations[balances[where].nextAllocationIndex].amount * balances[where].allocationShare \/ allocationPool;\r\n\r\n\t\t\t(c_val,c_fees)   = calcFees(currentAllocations[balances[where].nextAllocationIndex].date,now,c_amount);\r\n\r\n\t\t} \r\n\r\n\t    val  += c_val;\r\n\t\tfees += c_fees;\r\n\t\tpos   = currentAllocations.length;\r\n\t}\r\n\r\n    function balanceOf(address where) constant returns (uint256 val) {\r\n        uint256 fees;\r\n\t\tuint256 pos;\r\n        (val,fees,pos) = updatedBalance(where);\r\n        return ;\r\n    }\r\n\r\n\tevent Allocation(uint256 amount, uint256 date);\r\n\tevent FeeOnAllocation(uint256 fees, uint256 date);\r\n\r\n\tevent PartComplete();\r\n\tevent StillToGo(uint numLeft);\r\n\tuint256 public partPos;\r\n\tuint256 public partFees;\r\n\tuint256 partL;\r\n\tallocation[]   public partAllocations;\r\n\r\n\tfunction partAllocationLength() constant returns (uint) {\r\n\t\treturn partAllocations.length;\r\n\t}\r\n\r\n\tfunction addAllocationPartOne(uint newAllocation,uint numSteps) onlyOwner{\r\n\t\tuint256 thisAllocation = newAllocation;\r\n\r\n\t\trequire(totAllocation < maxAllocation);\t\t\/\/ cannot allocate more than this;\r\n\r\n\t\tif (currentAllocations.length > partAllocations.length) {\r\n\t\t\tpartAllocations = currentAllocations;\r\n\t\t}\r\n\r\n\t\tif (totAllocation + thisAllocation > maxAllocation) {\r\n\t\t\tthisAllocation = maxAllocation - totAllocation;\r\n\t\t\tlog0(\"max alloc reached\");\r\n\t\t}\r\n\t\ttotAllocation += thisAllocation;\r\n\r\n\t\tAllocation(thisAllocation,now);\r\n\r\n        allocation memory newDiv;\r\n        newDiv.amount = thisAllocation;\r\n        newDiv.date = now;\r\n\t\t\/\/ store into history\r\n\t    allocationsOverTime.push(newDiv);\r\n\t\t\/\/ add this record to the end of currentAllocations\r\n\t\tpartL = partAllocations.push(newDiv);\r\n\t\t\/\/ update all other records with calcs from last record\r\n\t\tif (partAllocations.length < 2) { \/\/ no fees to consider\r\n\t\t\tPartComplete();\r\n\t\t\tcurrentAllocations = partAllocations;\r\n\t\t\tFeeOnAllocation(0,now);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\/\/\r\n\t\t\/\/ The only fees that need to be collected are the fees on location zero.\r\n\t\t\/\/ Since they are the last calculated = they come out with the break\r\n\t\t\/\/\r\n\t\tfor (partPos = partAllocations.length - 2; partPos >= 0; partPos-- ){\r\n\t\t\t(partAllocations[partPos].amount,partFees) = calcFees(partAllocations[partPos].date,now,partAllocations[partPos].amount);\r\n\r\n\t\t\tpartAllocations[partPos].amount += partAllocations[partL - 1].amount;\r\n\t\t\tpartAllocations[partPos].date    = now;\r\n\t\t\tif ((partPos == 0) || (partPos == partAllocations.length-numSteps)){\r\n\t\t\t\tbreak; \r\n\t\t\t}\r\n\t\t}\r\n\t\tif (partPos != 0) {\r\n\t\t\tStillToGo(partPos);\r\n\t\t\treturn; \/\/ not done yet\r\n\t\t}\r\n\t\tPartComplete();\r\n\t\tFeeOnAllocation(partFees,now);\r\n\t\tcurrentAllocations = partAllocations;\r\n\t}\r\n\r\n\tfunction addAllocationPartTwo(uint numSteps) onlyOwner {\r\n\t\trequire(numSteps > 0);\r\n\t\trequire(partPos > 0);\r\n\t\tfor (uint i = 0; i < numSteps; i++ ){\r\n\t\t\tpartPos--;\r\n\t\t\t(partAllocations[partPos].amount,partFees) = calcFees(partAllocations[partPos].date,now,partAllocations[partPos].amount);\r\n\r\n\t\t\tpartAllocations[partPos].amount += partAllocations[partL - 1].amount;\r\n\t\t\tpartAllocations[partPos].date    = now;\r\n\t\t\tif (partPos == 0) {\r\n\t\t\t\tbreak; \r\n\t\t\t}\r\n\t\t}\r\n\t\tif (partPos != 0) {\r\n\t\t\tStillToGo(partPos);\r\n\t\t\treturn; \/\/ not done yet\r\n\t\t}\r\n\t\tPartComplete();\r\n\t\tFeeOnAllocation(partFees,now);\r\n\t\tcurrentAllocations = partAllocations;\r\n\t}\r\n\r\n\r\n\tfunction setHGT(address _hgt) onlyOwner {\r\n\t\tHGT = _hgt;\r\n\t}\r\n\r\n\tfunction parentFees(address where) whenNotPaused {\r\n\t\trequire(msg.sender == HGT);\r\n\t    update(where);\t\t\r\n\t}\r\n\t\r\n\tfunction parentChange(address where, uint newValue) whenNotPaused { \/\/ called when HGT balance changes\r\n\t\trequire(msg.sender == HGT);\r\n\t    balances[where].allocationShare = newValue;\r\n\t}\r\n\t\r\n\t\/* send GBT *\/\r\n\tfunction transfer(address _to, uint256 _value) whenNotPaused returns (bool ok) {\r\n\t    update(msg.sender);              \/\/ Do this to ensure sender has enough funds.\r\n\t\tupdate(_to); \r\n\r\n        balances[msg.sender].amount = safeSub(balances[msg.sender].amount, _value);\r\n        balances[_to].amount = safeAdd(balances[_to].amount, _value);\r\n\r\n\t\tTransfer(msg.sender, _to, _value); \/\/Notify anyone listening that this transfer took place\r\n        return true;\r\n\t}\r\n\r\n\tfunction transferFrom(address _from, address _to, uint _value) whenNotPaused returns (bool success) {\r\n\t\tvar _allowance = allowed[_from][msg.sender];\r\n\r\n\t    update(_from);              \/\/ Do this to ensure sender has enough funds.\r\n\t\tupdate(_to); \r\n\r\n\t\tbalances[_to].amount = safeAdd(balances[_to].amount, _value);\r\n\t\tbalances[_from].amount = safeSub(balances[_from].amount, _value);\r\n\t\tallowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n\t\tTransfer(_from, _to, _value);\r\n\t\treturn true;\r\n\t}\r\n\r\n  \tfunction approve(address _spender, uint _value) whenNotPaused returns (bool success) {\r\n\t\trequire((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n    \tallowed[msg.sender][_spender] = _value;\r\n    \tApproval(msg.sender, _spender, _value);\r\n    \treturn true;\r\n  \t}\r\n\r\n  \tfunction allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    \treturn allowed[_owner][_spender];\r\n  \t}\r\n\r\n\t\/\/ Minting Functions \r\n\taddress public authorisedMinter;\r\n\r\n\tfunction setMinter(address minter) onlyOwner {\r\n\t\tauthorisedMinter = minter;\r\n\t}\r\n\t\r\n\tfunction mintTokens(address destination, uint256 amount) {\r\n\t\trequire(msg.sender == authorisedMinter);\r\n\t\tupdate(destination);\r\n\t\tbalances[destination].amount = safeAdd(balances[destination].amount, amount);\r\n\t\tbalances[destination].lastUpdated = now;\r\n\t\tbalances[destination].nextAllocationIndex = currentAllocations.length;\r\n\t\tTokenMinted(destination,amount);\r\n\t}\r\n\r\n\tfunction burnTokens(address source, uint256 amount) {\r\n\t\trequire(msg.sender == authorisedMinter);\r\n\t\tupdate(source);\r\n\t\tbalances[source].amount = safeSub(balances[source].amount,amount);\r\n\t\tbalances[source].lastUpdated = now;\r\n\t\tbalances[source].nextAllocationIndex = currentAllocations.length;\r\n\t\tTokenBurned(source,amount);\r\n\t}\r\n}\r\n\r\n\/\/**************** HelloGoldSale\r\n\r\ncontract HelloGoldSale is Pausable, SafeMath {\r\n\r\n  uint256 public decimals = 8;\r\n\r\n  uint256 public startDate = 1503892800;      \/\/ Monday, August 28, 2017 12:00:00 PM GMT+08:00\r\n  uint256 public endDate   = 1504497600;      \/\/ Monday, September 4, 2017 12:00:00 PM GMT+08:00\r\n\r\n  uint256 tranchePeriod = 1 weeks;\r\n\r\n  \/\/ address of HGT Token. HGT must Approve this contract to disburse 300M tokens\r\n  HelloGoldToken          token;\r\n\r\n  uint256 constant MaxCoinsR1      = 180 * 10**6 * 10**8;   \/\/ 180M HGT\r\n  uint256 public coinsRemaining    = 180 * 10**6 * 10**8; \r\n  uint256 coinsPerTier             =  20 * 10**6 * 10**8;   \/\/ 20M HGT\r\n  uint256 public coinsLeftInTier   =  20 * 10**6 * 10**8;\r\n\r\n  uint256 public minimumCap        =  0;   \/\/ 40M HGT\r\n\r\n  uint256 numTiers                  = 5;\r\n  uint16  public tierNo;\r\n  uint256 public preallocCoins;   \/\/ used for testing against cap (inc placement)\r\n  uint256 public purchasedCoins;  \/\/ used for testing against tier pricing\r\n  uint256 public ethRaised;\r\n  uint256 public personalMax        = 10 * 1 ether;     \/\/ max ether per person during public sale\r\n  uint256 public contributors;\r\n\r\n  address public cs;\r\n  address public multiSig;\r\n  address public HGT_Reserve;\r\n  \r\n  struct csAction  {\r\n      bool        passedKYC;\r\n      bool        blocked;\r\n  }\r\n\r\n  \/* This creates an array with all balances *\/\r\n  mapping (address => csAction) public permissions;\r\n  mapping (address => uint256)  public deposits;\r\n\r\n  modifier MustBeEnabled(address x) {\r\n      require (!permissions[x].blocked) ;\r\n      require (permissions[x].passedKYC) ;\r\n      \r\n      _;\r\n  }\r\n\r\n  function HelloGoldSale(address _cs, address _hgt, address _multiSig, address _reserve) {\r\n    cs          = _cs;\r\n    token       = HelloGoldToken(_hgt);\r\n    multiSig    = _multiSig;\r\n    HGT_Reserve = _reserve;\r\n  }\r\n\r\n  \/\/ We only expect to use this to set\/reset the start of the contract under exceptional circumstances\r\n  function setStart(uint256 when_) onlyOwner {\r\n      startDate = when_;\r\n      endDate = when_ + tranchePeriod;\r\n  }\r\n\r\n  modifier MustBeCs() {\r\n      require (msg.sender == cs) ;\r\n      \r\n      _;\r\n  }\r\n\r\n\r\n  \/\/ 1 ether = N HGT tokens \r\n  uint256[5] public hgtRates = [1248900000000,1196900000000,1144800000000,1092800000000,1040700000000];\r\n                      \r\n\r\n    \/* Approve the account for operation *\/\r\n    function approve(address user) MustBeCs {\r\n        permissions[user].passedKYC = true;\r\n    }\r\n    \r\n    function block(address user) MustBeCs {\r\n        permissions[user].blocked = true;\r\n    }\r\n\r\n    function unblock(address user) MustBeCs {\r\n         permissions[user].blocked = false;\r\n    }\r\n\r\n    function newCs(address newCs) onlyOwner {\r\n        cs = newCs;\r\n    }\r\n\r\n    function setPeriod(uint256 period_) onlyOwner {\r\n        require (!funding()) ;\r\n        tranchePeriod = period_;\r\n        endDate = startDate + tranchePeriod;\r\n        if (endDate < now + tranchePeriod) {\r\n            endDate = now + tranchePeriod;\r\n        }\r\n    }\r\n\r\n    function when()  constant returns (uint256) {\r\n        return now;\r\n    }\r\n\r\n  function funding() constant returns (bool) {     \r\n    if (paused) return false;               \/\/ frozen\r\n    if (now < startDate) return false;      \/\/ too early\r\n    if (now > endDate) return false;        \/\/ too late\r\n    if (coinsRemaining == 0) return false;  \/\/ no more coins\r\n    if (tierNo >= numTiers ) return false;  \/\/ passed end of top tier. Tiers start at zero\r\n    return true;\r\n  }\r\n\r\n  function success() constant returns (bool succeeded) {\r\n    if (coinsRemaining == 0) return true;\r\n    bool complete = (now > endDate) ;\r\n    bool didOK = (coinsRemaining <= (MaxCoinsR1 - minimumCap)); \/\/ not even 40M Gone?? Aargh.\r\n    succeeded = (complete && didOK)  ;  \/\/ (out of steam but enough sold) \r\n    return ;\r\n  }\r\n\r\n  function failed() constant returns (bool didNotSucceed) {\r\n    bool complete = (now > endDate  );\r\n    bool didBad = (coinsRemaining > (MaxCoinsR1 - minimumCap));\r\n    didNotSucceed = (complete && didBad);\r\n    return;\r\n  }\r\n\r\n  \r\n  function () payable MustBeEnabled(msg.sender) whenNotPaused {    \r\n    createTokens(msg.sender,msg.value);\r\n  }\r\n\r\n  function linkCoin(address coin) onlyOwner {\r\n    token = HelloGoldToken(coin);\r\n  }\r\n\r\n  function coinAddress() constant returns (address) {\r\n      return address(token);\r\n  }\r\n\r\n  \/\/ hgtRates in whole tokens per ETH\r\n  \/\/ max individual contribution in whole ETH\r\n  function setHgtRates(uint256 p0,uint256 p1,uint256 p2,uint256 p3,uint256 p4, uint256 _max ) onlyOwner {\r\n              require (now < startDate) ;\r\n              hgtRates[0]   = p0 * 10**8;\r\n              hgtRates[1]   = p1 * 10**8;\r\n              hgtRates[2]   = p2 * 10**8;\r\n              hgtRates[3]   = p3 * 10**8;\r\n              hgtRates[4]   = p4 * 10**8;\r\n              personalMax = _max * 1 ether;           \/\/ max ETH per person\r\n  }\r\n\r\n  \r\n  event Purchase(address indexed buyer, uint256 level,uint256 value, uint256 tokens);\r\n  event Reduction(string msg, address indexed buyer, uint256 wanted, uint256 allocated);\r\n  \r\n  function createTokens(address recipient, uint256 value) private {\r\n    uint256 totalTokens;\r\n    uint256 hgtRate;\r\n    require (funding()) ;\r\n    require (value > 1 finney) ;\r\n    require (deposits[recipient] < personalMax);\r\n\r\n    uint256 maxRefund = 0;\r\n    if ((deposits[msg.sender] + value) > personalMax) {\r\n        maxRefund = deposits[msg.sender] + value - personalMax;\r\n        value -= maxRefund;\r\n        log0(\"maximum funds exceeded\");\r\n    }  \r\n\r\n    uint256 val = value;\r\n\r\n    ethRaised = safeAdd(ethRaised,value);\r\n    if (deposits[recipient] == 0) contributors++;\r\n    \r\n    \r\n    do {\r\n      hgtRate = hgtRates[tierNo];                 \/\/ hgtRate must include the 10^8\r\n      uint tokens = safeMul(val, hgtRate);      \/\/ (val in eth * 10^18) * #tokens per eth\r\n      tokens = safeDiv(tokens, 1 ether);      \/\/ val is in ether, msg.value is in wei\r\n   \r\n      if (tokens <= coinsLeftInTier) {\r\n        uint256 actualTokens = tokens;\r\n        uint refund = 0;\r\n        if (tokens > coinsRemaining) { \/\/can't sell desired # tokens\r\n            Reduction(\"in tier\",recipient,tokens,coinsRemaining);\r\n            actualTokens = coinsRemaining;\r\n            refund = safeSub(tokens, coinsRemaining ); \/\/ refund amount in tokens\r\n            refund = safeDiv(refund*1 ether,hgtRate );  \/\/ refund amount in ETH\r\n            \/\/ need a refund mechanism here too\r\n            coinsRemaining = 0;\r\n            val = safeSub( val,refund);\r\n        } else {\r\n            coinsRemaining  = safeSub(coinsRemaining,  actualTokens);\r\n        }\r\n        purchasedCoins  = safeAdd(purchasedCoins, actualTokens);\r\n\r\n        totalTokens = safeAdd(totalTokens,actualTokens);\r\n\r\n        require (token.transferFrom(HGT_Reserve, recipient,totalTokens)) ;\r\n\r\n        Purchase(recipient,tierNo,val,actualTokens); \/\/ event\r\n\r\n        deposits[recipient] = safeAdd(deposits[recipient],val); \/\/ in case of refund - could pull off etherscan\r\n        refund += maxRefund;\r\n        if (refund > 0) {\r\n            ethRaised = safeSub(ethRaised,refund);\r\n            recipient.transfer(refund);\r\n        }\r\n        if (coinsRemaining <= (MaxCoinsR1 - minimumCap)){ \/\/ has passed success criteria\r\n            if (!multiSig.send(this.balance)) {                \/\/ send funds to HGF\r\n                log0(\"cannot forward funds to owner\");\r\n            }\r\n        }\r\n        coinsLeftInTier = safeSub(coinsLeftInTier,actualTokens);\r\n        if ((coinsLeftInTier == 0) && (coinsRemaining != 0)) { \/\/ exact sell out of non final tier\r\n            coinsLeftInTier = coinsPerTier;\r\n            tierNo++;\r\n            endDate = now + tranchePeriod;\r\n        }\r\n        return;\r\n      }\r\n      \/\/ check that coinsLeftInTier >= coinsRemaining\r\n\r\n      uint256 coins2buy = min256(coinsLeftInTier , coinsRemaining); \r\n\r\n      endDate = safeAdd( now, tranchePeriod);\r\n      \/\/ Have bumped levels - need to modify end date here\r\n      purchasedCoins = safeAdd(purchasedCoins, coins2buy);  \/\/ give all coins remaining in this tier\r\n      totalTokens    = safeAdd(totalTokens,coins2buy);\r\n      coinsRemaining = safeSub(coinsRemaining,coins2buy);\r\n\r\n      uint weiCoinsLeftInThisTier = safeMul(coins2buy,1 ether);\r\n      uint costOfTheseCoins = safeDiv(weiCoinsLeftInThisTier, hgtRate);  \/\/ how much did that cost?\r\n\r\n      Purchase(recipient, tierNo,costOfTheseCoins,coins2buy); \/\/ event\r\n\r\n      deposits[recipient] = safeAdd(deposits[recipient],costOfTheseCoins);\r\n      val    = safeSub(val,costOfTheseCoins);\r\n      tierNo = tierNo + 1;\r\n      coinsLeftInTier = coinsPerTier;\r\n    } while ((val > 0) && funding());\r\n\r\n    \/\/ escaped because we passed the end of the universe.....\r\n    \/\/ so give them their tokens\r\n    require (token.transferFrom(HGT_Reserve, recipient,totalTokens)) ;\r\n\r\n    if ((val > 0) || (maxRefund > 0)){\r\n        Reduction(\"finished crowdsale, returning \",recipient,value,totalTokens);\r\n        \/\/ return the remainder !\r\n        recipient.transfer(val+maxRefund); \/\/ if you can't return the balance, abort whole process\r\n    }\r\n    if (!multiSig.send(this.balance)) {\r\n        ethRaised = safeSub(ethRaised,this.balance);\r\n        log0(\"cannot send at tier jump\");\r\n    }\r\n  }\r\n  \r\n  function allocatedTokens(address grantee, uint256 numTokens) onlyOwner {\r\n    require (now < startDate) ;\r\n    if (numTokens < coinsRemaining) {\r\n        coinsRemaining = safeSub(coinsRemaining, numTokens);\r\n       \r\n    } else {\r\n        numTokens = coinsRemaining;\r\n        coinsRemaining = 0;\r\n    }\r\n    preallocCoins = safeAdd(preallocCoins,numTokens);\r\n    require (token.transferFrom(HGT_Reserve,grantee,numTokens));\r\n  }\r\n\r\n  function withdraw() { \/\/ it failed. Come and get your ether.\r\n      if (failed()) {\r\n          if (deposits[msg.sender] > 0) {\r\n              uint256 val = deposits[msg.sender];\r\n              deposits[msg.sender] = 0;\r\n              msg.sender.transfer(val);\r\n          }\r\n      }\r\n  }\r\n\r\n  function complete() onlyOwner {  \/\/ this should not have to be called. Extreme measures.\r\n      if (success()) {\r\n          uint256 val = this.balance;\r\n          if (val > 0) {\r\n            if (!multiSig.send(val)) {\r\n                log0(\"cannot withdraw\");\r\n            } else {\r\n                log0(\"funds withdrawn\");\r\n            }\r\n          } else {\r\n              log0(\"nothing to withdraw\");\r\n          }\r\n      }\r\n  }\r\n\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/HelloGold\/",
        "Telegram": "",
        "Website": "https:\/\/www.hellogold.org\/",
        "Email": "mailto:foundation@hellogold.org",
        "Twitter": ""
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xba2184520a1cc49a6159c57e61e1844e085615b6#code"
    }, {
      "contractId": 49,
      "title": "Pluton",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Pluton",
      "code": "\/*\r\nThe Pluton Contract implements the standard token functionality (https:\/\/github.com\/ethereum\/EIPs\/issues\/20) as well as the following OPTIONAL extras intended for use by humans.\r\n\r\nPluton contract extends HumanStandardToken, https:\/\/github.com\/consensys\/tokens\r\n\r\n.*\/\r\ncontract Token {\r\n\r\n    \/\/\/ @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    \/\/\/ @param _owner The address from which the balance will be retrieved\r\n    \/\/\/ @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    \/\/\/ @notice send `_value` token to `_to` from `msg.sender`\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _value The amount of token to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    \/\/\/ @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    \/\/\/ @param _from The address of the sender\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _value The amount of token to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    \/\/\/ @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @param _value The amount of wei to be approved for transfer\r\n    \/\/\/ @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    \/\/\/ @param _owner The address of the account owning tokens\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        \/\/Default assumes totalSupply can't be over max (2^256 - 1).\r\n        \/\/If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        \/\/Replace the if with this one instead.\r\n        \/\/if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        \/\/same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        \/\/if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\ncontract HumanStandardToken is StandardToken {\r\n\r\n    function () {\r\n        \/\/if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    \/* Public variables of the token *\/\r\n\r\n    \/*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets\/interfaces might not even bother to look at this information.\r\n    *\/\r\n    string public name;                   \/\/fancy name: eg Simon Bucks\r\n    uint8 public decimals;                \/\/How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 \/\/An identifier: eg SBX\r\n    string public version = 'H0.1';       \/\/human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n    function HumanStandardToken(\r\n        uint256 _initialAmount,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol\r\n        ) {\r\n        balances[msg.sender] = _initialAmount;               \/\/ Give the creator all initial tokens\r\n        totalSupply = _initialAmount;                        \/\/ Update total supply\r\n        name = _tokenName;                                   \/\/ Set the name for display purposes\r\n        decimals = _decimalUnits;                            \/\/ Amount of decimals for display purposes\r\n        symbol = _tokenSymbol;                               \/\/ Set the symbol for display purposes\r\n    }\r\n\r\n    \/* Approves and then calls the receiving contract *\/\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        \/\/call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        \/\/receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        \/\/it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\r\n\r\n\/\/ Creates 20,000,000.000000000000000000 Pluton (PLU) Tokens\r\ncontract Pluton is HumanStandardToken(20000000000000000000000000, \"Pluton\", 18, \"PLU\") {}",
      "officialLinks": {
        "Reddit": "",
        "Telegram": "",
        "Website": "https:\/\/plutus.it\/",
        "Email": "mailto:info@plutus.it",
        "Twitter": "https:\/\/twitter.com\/PlutusIT"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xD8912C10681D8B21Fd3742244f44658dBA12264E#code"
    }, {
      "contractId": 50,
      "title": "FYN Token",
      "category": "ERC20",
      "tag": "ERC20",
      "author": " FundYourselfNow",
      "code": "pragma solidity ^0.4.11;\r\n\/*\r\nThis FYN token contract is derived from the vSlice ICO contract, based on the ERC20 token contract. \r\nAdditional functionality has been integrated:\r\n* the function mintTokens() only callable from wallet, which makes use of the currentSwapRate() and safeToAdd() helpers\r\n* the function mintReserve() only callable from wallet, which at the end of the crowdsale will allow the owners to claim the unsold tokens\r\n* the function stopToken() only callable from wallet, which in an emergency, will trigger a complete and irrecoverable shutdown of the token\r\n* Contract tokens are locked when created, and no tokens including pre-mine can be moved until the crowdsale is over.\r\n*\/\r\n\r\n\r\n\/\/ ERC20 Token Standard Interface\r\n\/\/ https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\ncontract ERC20 {\r\n    function totalSupply() constant returns (uint);\r\n    function balanceOf(address who) constant returns (uint);\r\n    function allowance(address owner, address spender) constant returns (uint);\r\n\r\n    function transfer(address to, uint value) returns (bool ok);\r\n    function transferFrom(address from, address to, uint value) returns (bool ok);\r\n    function approve(address spender, uint value) returns (bool ok);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Token is ERC20 {\r\n\r\n  string public constant name = \"FundYourselfNow Token\";\r\n  string public constant symbol = \"FYN\";\r\n  uint8 public constant decimals = 18;  \/\/ 18 is the most common number of decimal places\r\n  uint256 public tokenCap = 12500000e18; \/\/ 12.5 million FYN cap \r\n\r\n  address public walletAddress;\r\n  uint256 public creationTime;\r\n  bool public transferStop;\r\n \r\n  mapping( address => uint ) _balances;\r\n  mapping( address => mapping( address => uint ) ) _approvals;\r\n  uint _supply;\r\n\r\n  event TokenMint(address newTokenHolder, uint amountOfTokens);\r\n  event TokenSwapOver();\r\n  event EmergencyStopActivated();\r\n\r\n  modifier onlyFromWallet {\r\n      if (msg.sender != walletAddress) throw;\r\n      _;\r\n  }\r\n\r\n  \/\/ Check if transfer should stop\r\n  modifier checkTransferStop {\r\n      if (transferStop == true) throw;\r\n      _;\r\n  }\r\n \r\n\r\n  \/**\r\n   *\r\n   * Fix for the ERC20 short address attack\r\n   *\r\n   * http:\/\/vessenes.com\/the-erc20-short-address-attack-explained\/\r\n   *\/\r\n\r\n  modifier onlyPayloadSize(uint size) {\r\n     if (!(msg.data.length == size + 4)) throw;\r\n     _;\r\n   } \r\n \r\n  function Token( uint initial_balance, address wallet, uint256 crowdsaleTime) {\r\n    _balances[msg.sender] = initial_balance;\r\n    _supply = initial_balance;\r\n    walletAddress = wallet;\r\n    creationTime = crowdsaleTime;\r\n    transferStop = true;\r\n  }\r\n\r\n  function totalSupply() constant returns (uint supply) {\r\n    return _supply;\r\n  }\r\n\r\n  function balanceOf( address who ) constant returns (uint value) {\r\n    return _balances[who];\r\n  }\r\n\r\n  function allowance(address owner, address spender) constant returns (uint _allowance) {\r\n    return _approvals[owner][spender];\r\n  }\r\n\r\n  \/\/ A helper to notify if overflow occurs\r\n  function safeToAdd(uint a, uint b) private constant returns (bool) {\r\n    return (a + b >= a && a + b >= b);\r\n  }\r\n  \r\n  \/\/ A helper to notify if overflow occurs for multiplication\r\n  function safeToMultiply(uint _a, uint _b) private constant returns (bool) {\r\n    return (_b == 0 || ((_a * _b) \/ _b) == _a);\r\n  }\r\n\r\n  \/\/ A helper to notify if underflow occurs for subtraction\r\n  function safeToSub(uint a, uint b) private constant returns (bool) {\r\n    return (a >= b);\r\n  }\r\n\r\n\r\n  function transfer( address to, uint value)\r\n    checkTransferStop\r\n    onlyPayloadSize(2 * 32)\r\n    returns (bool ok) {\r\n\r\n    if (to == walletAddress) throw; \/\/ Reject transfers to wallet (wallet cannot interact with token contract)\r\n    if( _balances[msg.sender] < value ) {\r\n        throw;\r\n    }\r\n    if( !safeToAdd(_balances[to], value) ) {\r\n        throw;\r\n    }\r\n\r\n    _balances[msg.sender] -= value;\r\n    _balances[to] += value;\r\n    Transfer( msg.sender, to, value );\r\n    return true;\r\n  }\r\n\r\n  function transferFrom( address from, address to, uint value)\r\n    checkTransferStop\r\n    returns (bool ok) {\r\n\r\n    if (to == walletAddress) throw; \/\/ Reject transfers to wallet (wallet cannot interact with token contract)\r\n\r\n    \/\/ if you don't have enough balance, throw\r\n    if( _balances[from] < value ) {\r\n        throw;\r\n    }\r\n    \/\/ if you don't have approval, throw\r\n    if( _approvals[from][msg.sender] < value ) {\r\n        throw;\r\n    }\r\n    if( !safeToAdd(_balances[to], value) ) {\r\n        throw;\r\n    }\r\n    \/\/ transfer and return true\r\n    _approvals[from][msg.sender] -= value;\r\n    _balances[from] -= value;\r\n    _balances[to] += value;\r\n    Transfer( from, to, value );\r\n    return true;\r\n  }\r\n\r\n  function approve(address spender, uint value)\r\n    checkTransferStop\r\n    returns (bool ok) {\r\n\r\n    \/\/ To change the approve amount you first have to reduce the addresses`\r\n    \/\/  allowance to zero by calling `approve(_spender,0)` if it is not\r\n    \/\/  already 0 to mitigate the race condition described here:\r\n    \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\n    \/\/\r\n    \/\/ Note that this doesn't prevent attacks; the user will have to personally\r\n    \/\/  check to ensure that the token count has not changed, before issuing\r\n    \/\/  a new approval. Increment\/decrement is not commonly spec-ed, and \r\n    \/\/  changing to a check-my-approvals-before-changing would require user\r\n    \/\/  to find out his current approval for spender and change expected\r\n    \/\/  behaviour for ERC20.\r\n\r\n\r\n    if ((value!=0) && (_approvals[msg.sender][spender] !=0)) throw;\r\n\r\n    _approvals[msg.sender][spender] = value;\r\n    Approval( msg.sender, spender, value );\r\n    return true;\r\n  }\r\n\r\n  \/\/ The function currentSwapRate() returns the current exchange rate\r\n  \/\/ between FYN tokens and Ether during the token swap period\r\n  function currentSwapRate() constant returns(uint) {\r\n      uint presalePeriod = 3 days;\r\n      uint presaleTransitionWindow = 3 hours;\r\n      if (creationTime + presalePeriod > now) {  \/\/ 2017-06-10 11am GMT+8\r\n          return 140; \/\/ Presale Window is triggered by both time and \"Start Token Swap \/ End Token Swap\". Restricted to announement range and basic testing.\r\n      } \r\n      else if (creationTime + presalePeriod + 3 weeks > now) { \/\/ 2017-06-13 11am GMT+8, but we will only Start Token Swap at 2pm\r\n          return 120;\r\n      }\r\n      else if (creationTime + presalePeriod + 6 weeks + 6 days + 3 hours + presaleTransitionWindow + 1 days > now) { \/\/ 2017-07-31 5pm GMT+8 (+1 day window  )\r\n          \/\/ 1 day buffer to allow one final transaction from anyone to close everything\r\n          \/\/ otherwise wallet will receive ether but send 0 tokens\r\n          \/\/ we cannot throw as we will lose the state change to start swappability of tokens \r\n          \/\/ This is actually just a price guide, actual closing is done at the Wallet level\r\n          return 100;\r\n      }\r\n      else {\r\n          return 0;\r\n      }\r\n  }\r\n\r\n  \/\/ The function mintTokens is only usable by the chosen wallet\r\n  \/\/ contract to mint a number of tokens proportional to the\r\n  \/\/ amount of ether sent to the wallet contract. The function\r\n  \/\/ can only be called during the tokenswap period\r\n  function mintTokens(address newTokenHolder, uint etherAmount)\r\n    external\r\n    onlyFromWallet {\r\n        if (!safeToMultiply(currentSwapRate(), etherAmount)) throw;\r\n        uint tokensAmount = currentSwapRate() * etherAmount;\r\n\r\n        if(!safeToAdd(_balances[newTokenHolder],tokensAmount )) throw;\r\n        if(!safeToAdd(_supply,tokensAmount)) throw;\r\n\r\n        if ((_supply + tokensAmount) > tokenCap) throw;\r\n\r\n        _balances[newTokenHolder] += tokensAmount;\r\n        _supply += tokensAmount;\r\n\r\n        TokenMint(newTokenHolder, tokensAmount);\r\n  }\r\n\r\n  function mintReserve(address beneficiary) \r\n    external\r\n    onlyFromWallet {\r\n        if (tokenCap <= _supply) throw;\r\n        if(!safeToSub(tokenCap,_supply)) throw;\r\n        uint tokensAmount = tokenCap - _supply;\r\n\r\n        if(!safeToAdd(_balances[beneficiary], tokensAmount )) throw;\r\n        if(!safeToAdd(_supply,tokensAmount)) throw;\r\n\r\n        _balances[beneficiary] += tokensAmount;\r\n        _supply += tokensAmount;\r\n        \r\n        TokenMint(beneficiary, tokensAmount);\r\n  }\r\n\r\n  \/\/ The function disableTokenSwapLock() is called by the wallet\r\n  \/\/ contract once the token swap has reached its end conditions\r\n  function disableTokenSwapLock()\r\n    external\r\n    onlyFromWallet {\r\n        transferStop = false;\r\n        TokenSwapOver();\r\n  }\r\n\r\n  \/\/ Once activated, a new token contract will need to be created, mirroring the current token holdings. \r\n  function stopToken() onlyFromWallet {\r\n    transferStop = true;\r\n    EmergencyStopActivated();\r\n  }\r\n}\r\n\r\n\r\n\/*\r\nThe standard Wallet contract, retrievable at\r\nhttps:\/\/github.com\/ethereum\/dapp-bin\/blob\/master\/wallet\/wallet.sol has been\r\nmodified to include additional functionality, in particular:\r\n* An additional parent of wallet contract called tokenswap, implementing almost\r\nall the changes:\r\n    - Functions for starting and stopping the tokenswap\r\n    - A set-only-once function for the token contract\r\n    - buyTokens(), which calls mintTokens() in the token contract\r\n    - Modifiers for enforcing tokenswap time limits, max ether cap, and max token cap\r\n    - withdrawEther(), for withdrawing unsold tokens after time cap\r\n* the wallet fallback function calls the buyTokens function\r\n* the wallet contract cannot selfdestruct during the tokenswap\r\n*\/\r\n\r\ncontract multiowned {\r\n\r\n\t\/\/ TYPES\r\n\r\n    \/\/ struct for the status of a pending operation.\r\n    struct PendingState {\r\n        uint yetNeeded;\r\n        uint ownersDone;\r\n        uint index;\r\n    }\r\n\r\n\t\/\/ EVENTS\r\n\r\n    \/\/ this contract only has six types of events: it can accept a confirmation, in which case\r\n    \/\/ we record owner and operation (hash) alongside it.\r\n    event Confirmation(address owner, bytes32 operation);\r\n    event Revoke(address owner, bytes32 operation);\r\n    \/\/ some others are in the case of an owner changing.\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n    \/\/ the last one is emitted if the required signatures change\r\n    event RequirementChanged(uint newRequirement);\r\n\r\n\t\/\/ MODIFIERS\r\n\r\n    \/\/ simple single-sig function modifier.\r\n    modifier onlyowner {\r\n        if (isOwner(msg.sender))\r\n            _;\r\n    }\r\n    \/\/ multi-sig function modifier: the operation must have an intrinsic hash in order\r\n    \/\/ that later attempts can be realised as the same underlying operation and\r\n    \/\/ thus count as confirmations.\r\n    modifier onlymanyowners(bytes32 _operation) {\r\n        if (confirmAndCheck(_operation))\r\n            _;\r\n    }\r\n\r\n\t\/\/ METHODS\r\n\r\n    \/\/ constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\r\n    \/\/ as well as the selection of addresses capable of confirming them.\r\n    function multiowned(address[] _owners, uint _required) {\r\n        m_numOwners = _owners.length + 1;\r\n        m_owners[1] = uint(msg.sender);\r\n        m_ownerIndex[uint(msg.sender)] = 1;\r\n        for (uint i = 0; i < _owners.length; ++i)\r\n        {\r\n            m_owners[2 + i] = uint(_owners[i]);\r\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\r\n        }\r\n        m_required = _required;\r\n    }\r\n\r\n    \/\/ Revokes a prior confirmation of the given operation\r\n    function revoke(bytes32 _operation) external {\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        \/\/ make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        var pending = m_pending[_operation];\r\n        if (pending.ownersDone & ownerIndexBit > 0) {\r\n            pending.yetNeeded++;\r\n            pending.ownersDone -= ownerIndexBit;\r\n            Revoke(msg.sender, _operation);\r\n        }\r\n    }\r\n\r\n    \/\/ Replaces an owner `_from` with another `_to`.\r\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {\r\n        if (isOwner(_to)) return;\r\n        uint ownerIndex = m_ownerIndex[uint(_from)];\r\n        if (ownerIndex == 0) return;\r\n\r\n        clearPending();\r\n        m_owners[ownerIndex] = uint(_to);\r\n        m_ownerIndex[uint(_from)] = 0;\r\n        m_ownerIndex[uint(_to)] = ownerIndex;\r\n        OwnerChanged(_from, _to);\r\n    }\r\n\r\n    function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\r\n        if (isOwner(_owner)) return;\r\n\r\n        clearPending();\r\n        if (m_numOwners >= c_maxOwners)\r\n            reorganizeOwners();\r\n        if (m_numOwners >= c_maxOwners)\r\n            return;\r\n        m_numOwners++;\r\n        m_owners[m_numOwners] = uint(_owner);\r\n        m_ownerIndex[uint(_owner)] = m_numOwners;\r\n        OwnerAdded(_owner);\r\n    }\r\n\r\n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n        if (ownerIndex == 0) return;\r\n        if (m_required > m_numOwners - 1) return;\r\n\r\n        m_owners[ownerIndex] = 0;\r\n        m_ownerIndex[uint(_owner)] = 0;\r\n        clearPending();\r\n        reorganizeOwners(); \/\/make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\r\n        OwnerRemoved(_owner);\r\n    }\r\n\r\n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {\r\n        if (_newRequired > m_numOwners) return;\r\n        m_required = _newRequired;\r\n        clearPending();\r\n        RequirementChanged(_newRequired);\r\n    }\r\n\r\n    \/\/ Gets an owner by 0-indexed position (using numOwners as the count)\r\n    function getOwner(uint ownerIndex) external constant returns (address) {\r\n        return address(m_owners[ownerIndex + 1]);\r\n    }\r\n\r\n    function isOwner(address _addr) returns (bool) {\r\n        return m_ownerIndex[uint(_addr)] > 0;\r\n    }\r\n\r\n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\r\n        var pending = m_pending[_operation];\r\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\r\n\r\n        \/\/ make sure they're an owner\r\n        if (ownerIndex == 0) return false;\r\n\r\n        \/\/ determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        return !(pending.ownersDone & ownerIndexBit == 0);\r\n    }\r\n\r\n    \/\/ INTERNAL METHODS\r\n\r\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\r\n        \/\/ determine what index the present sender is:\r\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\r\n        \/\/ make sure they're an owner\r\n        if (ownerIndex == 0) return;\r\n\r\n        var pending = m_pending[_operation];\r\n        \/\/ if we're not yet working on this operation, switch over and reset the confirmation status.\r\n        if (pending.yetNeeded == 0) {\r\n            \/\/ reset count of confirmations needed.\r\n            pending.yetNeeded = m_required;\r\n            \/\/ reset which owners have confirmed (none) - set our bitmap to 0.\r\n            pending.ownersDone = 0;\r\n            pending.index = m_pendingIndex.length++;\r\n            m_pendingIndex[pending.index] = _operation;\r\n        }\r\n        \/\/ determine the bit to set for this owner.\r\n        uint ownerIndexBit = 2**ownerIndex;\r\n        \/\/ make sure we (the message sender) haven't confirmed this operation previously.\r\n        if (pending.ownersDone & ownerIndexBit == 0) {\r\n            Confirmation(msg.sender, _operation);\r\n            \/\/ ok - check if count is enough to go ahead.\r\n            if (pending.yetNeeded <= 1) {\r\n                \/\/ enough confirmations: reset and run interior.\r\n                delete m_pendingIndex[m_pending[_operation].index];\r\n                delete m_pending[_operation];\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                \/\/ not enough: record that this owner in particular confirmed.\r\n                pending.yetNeeded--;\r\n                pending.ownersDone |= ownerIndexBit;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reorganizeOwners() private {\r\n        uint free = 1;\r\n        while (free < m_numOwners)\r\n        {\r\n            while (free < m_numOwners && m_owners[free] != 0) free++;\r\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\r\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\r\n            {\r\n                m_owners[free] = m_owners[m_numOwners];\r\n                m_ownerIndex[m_owners[free]] = free;\r\n                m_owners[m_numOwners] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            if (m_pendingIndex[i] != 0)\r\n                delete m_pending[m_pendingIndex[i]];\r\n        delete m_pendingIndex;\r\n    }\r\n\r\n   \t\/\/ FIELDS\r\n\r\n    \/\/ the number of owners that must confirm the same operation before it is run.\r\n    uint public m_required;\r\n    \/\/ pointer used to find a free slot in m_owners\r\n    uint public m_numOwners;\r\n\r\n    \/\/ list of owners\r\n    uint[256] m_owners;\r\n    uint constant c_maxOwners = 250;\r\n    \/\/ index on the list of owners to allow reverse lookup\r\n    mapping(uint => uint) m_ownerIndex;\r\n    \/\/ the ongoing operations.\r\n    mapping(bytes32 => PendingState) m_pending;\r\n    bytes32[] m_pendingIndex;\r\n}\r\n\r\n\/\/ inheritable \"property\" contract that enables methods to be protected by placing a linear limit (specifiable)\r\n\/\/ on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\r\n\/\/ uses is specified in the modifier.\r\ncontract daylimit is multiowned {\r\n\r\n\t\/\/ MODIFIERS\r\n\r\n    \/\/ simple modifier for daily limit.\r\n    modifier limitedDaily(uint _value) {\r\n        if (underLimit(_value))\r\n            _;\r\n    }\r\n\r\n\t\/\/ METHODS\r\n\r\n    \/\/ constructor - stores initial daily limit and records the present day's index.\r\n    function daylimit(uint _limit) {\r\n        m_dailyLimit = _limit;\r\n        m_lastDay = today();\r\n    }\r\n    \/\/ (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\r\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {\r\n        m_dailyLimit = _newLimit;\r\n    }\r\n    \/\/ resets the amount already spent today. needs many of the owners to confirm.\r\n    function resetSpentToday() onlymanyowners(sha3(msg.data)) external {\r\n        m_spentToday = 0;\r\n    }\r\n\r\n    \/\/ INTERNAL METHODS\r\n\r\n    \/\/ checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\r\n    \/\/ returns true. otherwise just returns false.\r\n    function underLimit(uint _value) internal onlyowner returns (bool) {\r\n        \/\/ reset the spend limit if we're on a different day to last time.\r\n        if (today() > m_lastDay) {\r\n            m_spentToday = 0;\r\n            m_lastDay = today();\r\n        }\r\n        \/\/ check if it's sending nothing (with or without data). This needs Multitransact\r\n        if (_value == 0) return false;\r\n\r\n        \/\/ check to see if there's enough left - if so, subtract and return true.\r\n        \/\/ overflow protection                    \/\/ dailyLimit check\r\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\r\n            m_spentToday += _value;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \/\/ determines today's index.\r\n    function today() private constant returns (uint) { return now \/ 1 days; }\r\n\r\n\t\/\/ FIELDS\r\n\r\n    uint public m_dailyLimit;\r\n    uint public m_spentToday;\r\n    uint public m_lastDay;\r\n}\r\n\r\n\/\/ interface contract for multisig proxy contracts; see below for docs.\r\ncontract multisig {\r\n\r\n\t\/\/ EVENTS\r\n\r\n    \/\/ logged events:\r\n    \/\/ Funds has arrived into the wallet (record how much).\r\n    event Deposit(address _from, uint value);\r\n    \/\/ Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\r\n    event SingleTransact(address owner, uint value, address to, bytes data);\r\n    \/\/ Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\r\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\r\n    \/\/ Confirmation still needed for a transaction.\r\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\r\n\r\n    \/\/ FUNCTIONS\r\n\r\n    \/\/ TODO: document\r\n    function changeOwner(address _from, address _to) external;\r\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\r\n    function confirm(bytes32 _h) returns (bool);\r\n}\r\n\r\ncontract tokenswap is multisig, multiowned {\r\n    Token public tokenCtr;\r\n    bool public tokenSwap;\r\n    uint public constant PRESALE_LENGTH = 3 days;\r\n    uint public constant TRANSITION_WINDOW = 3 hours; \/\/ We will turn on tokenSwap in this period and it will 120 FYN \/ ETH\r\n    uint public constant SWAP_LENGTH = PRESALE_LENGTH + TRANSITION_WINDOW + 6 weeks + 6 days + 3 hours;\r\n    uint public constant MAX_ETH = 75000 ether; \/\/ Hard cap, capped otherwise by total tokens sold (max 7.5M FYN)\r\n    uint public amountRaised;\r\n\r\n    modifier isUnderPresaleMinimum {\r\n        if (tokenCtr.creationTime() + PRESALE_LENGTH > now) {\r\n            if (msg.value < 20 ether) throw;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier isZeroValue {\r\n        if (msg.value == 0) throw;\r\n        _;\r\n    }\r\n\r\n    modifier isOverCap {\r\n    \tif (amountRaised + msg.value > MAX_ETH) throw;\r\n        _;\r\n    }\r\n\r\n    modifier isOverTokenCap {\r\n        if (!safeToMultiply(tokenCtr.currentSwapRate(), msg.value)) throw;\r\n        uint tokensAmount = tokenCtr.currentSwapRate() * msg.value;\r\n        if(!safeToAdd(tokenCtr.totalSupply(),tokensAmount)) throw;\r\n        if (tokenCtr.totalSupply() + tokensAmount > tokenCtr.tokenCap()) throw;\r\n        _;\r\n\r\n    }\r\n\r\n    modifier isSwapStopped {\r\n        if (!tokenSwap) throw;\r\n        _;\r\n    }\r\n\r\n    modifier areConditionsSatisfied {\r\n        _;\r\n        \/\/ End token swap if sale period ended\r\n        \/\/ We can't throw to reverse the amount sent in or we will lose state\r\n        \/\/ , so we will accept it even though if it is after crowdsale\r\n        if (tokenCtr.creationTime() + SWAP_LENGTH < now) {\r\n            tokenCtr.disableTokenSwapLock();\r\n            tokenSwap = false;\r\n        }\r\n        \/\/ Check if cap has been reached in this tx\r\n        if (amountRaised == MAX_ETH) {\r\n            tokenCtr.disableTokenSwapLock();\r\n            tokenSwap = false;\r\n        }\r\n\r\n        \/\/ Check if token cap has been reach in this tx\r\n        if (tokenCtr.totalSupply() == tokenCtr.tokenCap()) {\r\n            tokenCtr.disableTokenSwapLock();\r\n            tokenSwap = false;\r\n        }\r\n    }\r\n\r\n    \/\/ A helper to notify if overflow occurs for addition\r\n    function safeToAdd(uint a, uint b) private constant returns (bool) {\r\n      return (a + b >= a && a + b >= b);\r\n    }\r\n  \r\n    \/\/ A helper to notify if overflow occurs for multiplication\r\n    function safeToMultiply(uint _a, uint _b) private constant returns (bool) {\r\n      return (_b == 0 || ((_a * _b) \/ _b) == _a);\r\n    }\r\n\r\n\r\n    function startTokenSwap() onlyowner {\r\n        tokenSwap = true;\r\n    }\r\n\r\n    function stopTokenSwap() onlyowner {\r\n        tokenSwap = false;\r\n    }\r\n\r\n    function setTokenContract(address newTokenContractAddr) onlyowner {\r\n        if (newTokenContractAddr == address(0x0)) throw;\r\n        \/\/ Allow setting only once\r\n        if (tokenCtr != address(0x0)) throw;\r\n\r\n        tokenCtr = Token(newTokenContractAddr);\r\n    }\r\n\r\n    function buyTokens(address _beneficiary)\r\n    payable\r\n    isUnderPresaleMinimum\r\n    isZeroValue\r\n    isOverCap\r\n    isOverTokenCap\r\n    isSwapStopped\r\n    areConditionsSatisfied {\r\n        Deposit(msg.sender, msg.value);\r\n        tokenCtr.mintTokens(_beneficiary, msg.value);\r\n        if (!safeToAdd(amountRaised, msg.value)) throw;\r\n        amountRaised += msg.value;\r\n    }\r\n\r\n    function withdrawReserve(address _beneficiary) onlyowner {\r\n\t    if (tokenCtr.creationTime() + SWAP_LENGTH < now) {\r\n            tokenCtr.mintReserve(_beneficiary);\r\n        }\r\n    } \r\n}\r\n\r\n\/\/ usage:\r\n\/\/ bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\r\n\/\/ Wallet(w).from(anotherOwner).confirm(h);\r\ncontract Wallet is multisig, multiowned, daylimit, tokenswap {\r\n\r\n\t\/\/ TYPES\r\n\r\n    \/\/ Transaction structure to remember details of transaction lest it need be saved for a later call.\r\n    struct Transaction {\r\n        address to;\r\n        uint value;\r\n        bytes data;\r\n    }\r\n\r\n    \/\/ METHODS\r\n\r\n    \/\/ constructor - just pass on the owner array to the multiowned and\r\n    \/\/ the limit to daylimit\r\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\r\n            multiowned(_owners, _required) daylimit(_daylimit) {\r\n    }\r\n\r\n    \/\/ kills the contract sending everything to `_to`.\r\n    function kill(address _to) onlymanyowners(sha3(msg.data)) external {\r\n        \/\/ ensure owners can't prematurely stop token sale\r\n        if (tokenSwap) throw;\r\n        \/\/ ensure owners can't kill wallet without stopping token\r\n        \/\/  otherwise token can never be stopped\r\n        if (tokenCtr.transferStop() == false) throw;\r\n        suicide(_to);\r\n    }\r\n\r\n    \/\/ Activates Emergency Stop for Token\r\n    function stopToken() onlymanyowners(sha3(msg.data)) external {\r\n       tokenCtr.stopToken();\r\n    }\r\n\r\n    \/\/ gets called when no other function matches\r\n    function()\r\n    payable {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    \/\/ Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.\r\n    \/\/ If not, goes into multisig process. We provide a hash on return to allow the sender to provide\r\n    \/\/ shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\r\n    \/\/ and _data arguments). They still get the option of using them if they want, anyways.\r\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\r\n        \/\/ Disallow the wallet contract from calling token contract once it's set\r\n        \/\/ so tokens can't be minted arbitrarily once the sale starts.\r\n        \/\/ Tokens can be minted for premine before the sale opens and tokenCtr is set.\r\n        if (_to == address(tokenCtr)) throw;\r\n\r\n        \/\/ first, take the opportunity to check that we're under the daily limit.\r\n        if (underLimit(_value)) {\r\n            SingleTransact(msg.sender, _value, _to, _data);\r\n            \/\/ yes - just execute the call.\r\n            if(!_to.call.value(_value)(_data))\r\n            return 0;\r\n        }\r\n\r\n        \/\/ determine our operation hash.\r\n        _r = sha3(msg.data, block.number);\r\n        if (!confirm(_r) && m_txs[_r].to == 0) {\r\n            m_txs[_r].to = _to;\r\n            m_txs[_r].value = _value;\r\n            m_txs[_r].data = _data;\r\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\r\n        }\r\n    }\r\n\r\n    \/\/ confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\r\n    \/\/ to determine the body of the transaction from the hash provided.\r\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\r\n        if (m_txs[_h].to != 0) {\r\n            if (!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))   \/\/ Bugfix: If successful, MultiTransact event should fire; if unsuccessful, we should throw\r\n                throw;\r\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\r\n            delete m_txs[_h];\r\n            return true;\r\n        }\r\n    }\r\n\r\n    \/\/ INTERNAL METHODS\r\n\r\n    function clearPending() internal {\r\n        uint length = m_pendingIndex.length;\r\n        for (uint i = 0; i < length; ++i)\r\n            delete m_txs[m_pendingIndex[i]];\r\n        super.clearPending();\r\n    }\r\n\r\n\t\/\/ FIELDS\r\n\r\n    \/\/ pending transactions we have at present.\r\n    mapping (bytes32 => Transaction) m_txs;\r\n}",
      "officialLinks": {
        "Reddit": "",
        "Telegram": "https:\/\/telegram.me\/fundyourselfnow",
        "Website": "https:\/\/www.fundyourselfnow.com\/",
        "Email": "mailto:contact@fundyourselfnow.com",
        "Twitter": "https:\/\/twitter.com\/fundyourselfnow"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x88fcfbc22c6d3dbaa25af478c578978339bde77a#code"
    }, {
      "contractId": 51,
      "title": "BCAPToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "BCAP",
      "code": "\/*\r\n * Blockchain Capital Token Smart Contract.  Copyright \u00a9 2017 by ABDK\r\n * Consulting.  \r\n *\/\r\n\r\n\/*\r\n * ERC-20 Standard Token Smart Contract Interface.\r\n * Copyright \u00a9 2016 by ABDK Consulting.\r\n *\/\r\npragma solidity ^0.4.1;\r\n\r\n\/**\r\n * ERC-20 standard token interface, as defined\r\n * <a href=\"http:\/\/github.com\/ethereum\/EIPs\/issues\/20\">here<\/a>.\r\n *\/\r\ncontract Token {\r\n  \/**\r\n   * Get total number of tokens in circulation.\r\n   *\r\n   * @return total number of tokens in circulation\r\n   *\/\r\n  function totalSupply () constant returns (uint256 supply);\r\n\r\n  \/**\r\n   * Get number of tokens currently belonging to given owner.\r\n   *\r\n   * @param _owner address to get number of tokens currently belonging to the\r\n            owner of\r\n   * @return number of tokens currently belonging to the owner of given address\r\n   *\/\r\n  function balanceOf (address _owner) constant returns (uint256 balance);\r\n\r\n  \/**\r\n   * Transfer given number of tokens from message sender to given recipient.\r\n   *\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer to the owner of given address\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   *\/\r\n  function transfer (address _to, uint256 _value) returns (bool success);\r\n\r\n  \/**\r\n   * Transfer given number of tokens from given owner to given recipient.\r\n   *\r\n   * @param _from address to transfer tokens from the owner of\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer from given owner to given\r\n            recipient\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   *\/\r\n  function transferFrom (address _from, address _to, uint256 _value)\r\n  returns (bool success);\r\n\r\n  \/**\r\n   * Allow given spender to transfer given number of tokens from message sender.\r\n   *\r\n   * @param _spender address to allow the owner of to transfer tokens from\r\n            message sender\r\n   * @param _value number of tokens to allow to transfer\r\n   * @return true if token transfer was successfully approved, false otherwise\r\n   *\/\r\n  function approve (address _spender, uint256 _value) returns (bool success);\r\n\r\n  \/**\r\n   * Tell how many tokens given spender is currently allowed to transfer from\r\n   * given owner.\r\n   *\r\n   * @param _owner address to get number of tokens allowed to be transferred\r\n   *        from the owner of\r\n   * @param _spender address to get number of tokens allowed to be transferred\r\n   *        by the owner of\r\n   * @return number of tokens given spender is currently allowed to transfer\r\n   *         from given owner\r\n   *\/\r\n  function allowance (address _owner, address _spender) constant\r\n  returns (uint256 remaining);\r\n\r\n  \/**\r\n   * Logged when tokens were transferred from one owner to another.\r\n   *\r\n   * @param _from address of the owner, tokens were transferred from\r\n   * @param _to address of the owner, tokens were transferred to\r\n   * @param _value number of tokens transferred\r\n   *\/\r\n  event Transfer (address indexed _from, address indexed _to, uint256 _value);\r\n\r\n  \/**\r\n   * Logged when owner approved his tokens to be transferred by some spender.\r\n   *\r\n   * @param _owner owner who approved his tokens to be transferred\r\n   * @param _spender spender who were allowed to transfer the tokens belonging\r\n   *        to the owner\r\n   * @param _value number of tokens belonging to the owner, approved to be\r\n   *        transferred by the spender\r\n   *\/\r\n  event Approval (\r\n    address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\/*\r\n * Safe Math Smart Contract.  Copyright \u00a9 2016 by ABDK Consulting.\r\n *\/\r\n\/**\r\n * Provides methods to safely add, subtract and multiply uint256 numbers.\r\n *\/\r\ncontract SafeMath {\r\n  uint256 constant private MAX_UINT256 =\r\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  \/**\r\n   * Add two uint256 values, throw in case of overflow.\r\n   *\r\n   * @param x first value to add\r\n   * @param y second value to add\r\n   * @return x + y\r\n   *\/\r\n  function safeAdd (uint256 x, uint256 y)\r\n  constant internal\r\n  returns (uint256 z) {\r\n    if (x > MAX_UINT256 - y) throw;\r\n    return x + y;\r\n  }\r\n\r\n  \/**\r\n   * Subtract one uint256 value from another, throw in case of underflow.\r\n   *\r\n   * @param x value to subtract from\r\n   * @param y value to subtract\r\n   * @return x - y\r\n   *\/\r\n  function safeSub (uint256 x, uint256 y)\r\n  constant internal\r\n  returns (uint256 z) {\r\n    if (x < y) throw;\r\n    return x - y;\r\n  }\r\n\r\n  \/**\r\n   * Multiply two uint256 values, throw in case of overflow.\r\n   *\r\n   * @param x first value to multiply\r\n   * @param y second value to multiply\r\n   * @return x * y\r\n   *\/\r\n  function safeMul (uint256 x, uint256 y)\r\n  constant internal\r\n  returns (uint256 z) {\r\n    if (y == 0) return 0; \/\/ Prevent division by zero at the next line\r\n    if (x > MAX_UINT256 \/ y) throw;\r\n    return x * y;\r\n  }\r\n}\r\n\r\n\/*\r\n * Abstract Token Smart Contract.  Copyright \u00a9 2017 by ABDK Consulting.\r\n *\/\r\n\r\n\/**\r\n * Abstract Token Smart Contract that could be used as a base contract for\r\n * ERC-20 token contracts.\r\n *\/\r\ncontract AbstractToken is Token, SafeMath {\r\n  \/**\r\n   * Create new Abstract Token contract.\r\n   *\/\r\n  function AbstractToken () {\r\n    \/\/ Do nothing\r\n  }\r\n\r\n  \/**\r\n   * Get number of tokens currently belonging to given owner.\r\n   *\r\n   * @param _owner address to get number of tokens currently belonging to the\r\n            owner of\r\n   * @return number of tokens currently belonging to the owner of given address\r\n   *\/\r\n  function balanceOf (address _owner) constant returns (uint256 balance) {\r\n    return accounts [_owner];\r\n  }\r\n\r\n  \/**\r\n   * Transfer given number of tokens from message sender to given recipient.\r\n   *\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer to the owner of given address\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   *\/\r\n  function transfer (address _to, uint256 _value) returns (bool success) {\r\n    if (accounts [msg.sender] < _value) return false;\r\n    if (_value > 0 && msg.sender != _to) {\r\n      accounts [msg.sender] = safeSub (accounts [msg.sender], _value);\r\n      accounts [_to] = safeAdd (accounts [_to], _value);\r\n      Transfer (msg.sender, _to, _value);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   * Transfer given number of tokens from given owner to given recipient.\r\n   *\r\n   * @param _from address to transfer tokens from the owner of\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer from given owner to given\r\n            recipient\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   *\/\r\n  function transferFrom (address _from, address _to, uint256 _value)\r\n  returns (bool success) {\r\n    if (allowances [_from][msg.sender] < _value) return false;\r\n    if (accounts [_from] < _value) return false;\r\n\r\n    allowances [_from][msg.sender] =\r\n      safeSub (allowances [_from][msg.sender], _value);\r\n\r\n    if (_value > 0 && _from != _to) {\r\n      accounts [_from] = safeSub (accounts [_from], _value);\r\n      accounts [_to] = safeAdd (accounts [_to], _value);\r\n      Transfer (_from, _to, _value);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   * Allow given spender to transfer given number of tokens from message sender.\r\n   *\r\n   * @param _spender address to allow the owner of to transfer tokens from\r\n            message sender\r\n   * @param _value number of tokens to allow to transfer\r\n   * @return true if token transfer was successfully approved, false otherwise\r\n   *\/\r\n  function approve (address _spender, uint256 _value) returns (bool success) {\r\n    allowances [msg.sender][_spender] = _value;\r\n    Approval (msg.sender, _spender, _value);\r\n\r\n    return true;\r\n  }\r\n\r\n  \/**\r\n   * Tell how many tokens given spender is currently allowed to transfer from\r\n   * given owner.\r\n   *\r\n   * @param _owner address to get number of tokens allowed to be transferred\r\n   *        from the owner of\r\n   * @param _spender address to get number of tokens allowed to be transferred\r\n   *        by the owner of\r\n   * @return number of tokens given spender is currently allowed to transfer\r\n   *         from given owner\r\n   *\/\r\n  function allowance (address _owner, address _spender) constant\r\n  returns (uint256 remaining) {\r\n    return allowances [_owner][_spender];\r\n  }\r\n\r\n  \/**\r\n   * Mapping from addresses of token holders to the numbers of tokens belonging\r\n   * to these token holders.\r\n   *\/\r\n  mapping (address => uint256) accounts;\r\n\r\n  \/**\r\n   * Mapping from addresses of token holders to the mapping of addresses of\r\n   * spenders to the allowances set by these token holders to these spenders.\r\n   *\/\r\n  mapping (address => mapping (address => uint256)) private allowances;\r\n}\r\n\r\n\r\n\/*\r\n * Standard Token Smart Contract.  Copyright \u00a9 2016 by ABDK Consulting.\r\n *\/\r\n\r\n\r\n\/**\r\n * Standard Token Smart Contract that implements ERC-20 token with special\r\n * unlimited supply \"token issuer\" account.\r\n *\/\r\ncontract StandardToken is AbstractToken {\r\n  uint256 constant private MAX_UINT256 =\r\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  \/**\r\n   * Create new Standard Token contract with given \"token issuer\" account.\r\n   *\r\n   * @param _tokenIssuer address of \"token issuer\" account\r\n   *\/\r\n  function StandardToken (address _tokenIssuer) AbstractToken () {\r\n    tokenIssuer = _tokenIssuer;\r\n    accounts [_tokenIssuer] = MAX_UINT256;\r\n  }\r\n\r\n  \/**\r\n   * Get total number of tokens in circulation.\r\n   *\r\n   * @return total number of tokens in circulation\r\n   *\/\r\n  function totalSupply () constant returns (uint256 supply) {\r\n    return safeSub (MAX_UINT256, accounts [tokenIssuer]);\r\n  }\r\n\r\n  \/**\r\n   * Get number of tokens currently belonging to given owner.\r\n   *\r\n   * @param _owner address to get number of tokens currently belonging to the\r\n            owner of\r\n   * @return number of tokens currently belonging to the owner of given address\r\n   *\/\r\n  function balanceOf (address _owner) constant returns (uint256 balance) {\r\n    return _owner == tokenIssuer ? 0 : AbstractToken.balanceOf (_owner);\r\n  }\r\n\r\n  \/**\r\n   * Address of \"token issuer\" account.\r\n   *\/\r\n  address private tokenIssuer;\r\n}\r\n\r\n\/**\r\n * Blockchain Capital Token Smart Contract.\r\n *\/\r\ncontract BCAPToken is StandardToken {\r\n  \/**\r\n   * Create new Blockchain Capital Token contract with given token issuer\r\n   * address.\r\n   *\r\n   * @param _tokenIssuer address of token issuer\r\n   *\/\r\n  function BCAPToken (address _tokenIssuer)\r\n    StandardToken (_tokenIssuer) {\r\n    owner = _tokenIssuer;\r\n  }\r\n\r\n  \/**\r\n   * Freeze token transfers.\r\n   *\/\r\n  function freezeTransfers () {\r\n    if (msg.sender != owner) throw;\r\n\r\n    if (!transfersFrozen) {\r\n      transfersFrozen = true;\r\n      Freeze ();\r\n    }\r\n  }\r\n\r\n  \/**\r\n   * Unfreeze token transfers.\r\n   *\/\r\n  function unfreezeTransfers () {\r\n    if (msg.sender != owner) throw;\r\n\r\n    if (transfersFrozen) {\r\n      transfersFrozen = false;\r\n      Unfreeze ();\r\n    }\r\n  }\r\n\r\n  \/**\r\n   * Transfer given number of tokens from message sender to given recipient.\r\n   *\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer to the owner of given address\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   *\/\r\n  function transfer (address _to, uint256 _value) returns (bool success) {\r\n    if (transfersFrozen) return false;\r\n    else return AbstractToken.transfer (_to, _value);\r\n  }\r\n\r\n  \/**\r\n   * Transfer given number of tokens from given owner to given recipient.\r\n   *\r\n   * @param _from address to transfer tokens from the owner of\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer from given owner to given\r\n            recipient\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   *\/\r\n  function transferFrom (address _from, address _to, uint256 _value)\r\n  returns (bool success) {\r\n    if (transfersFrozen) return false;\r\n    else return AbstractToken.transferFrom (_from, _to, _value);\r\n  }\r\n\r\n  \/**\r\n   * Logged when transfers were frozen.\r\n   *\/\r\n  event Freeze ();\r\n\r\n  \/**\r\n   * Logged when transfers were unfrozen.\r\n   *\/\r\n  event Unfreeze ();\r\n\r\n  \/**\r\n   * Address of the owner of smart contract.  Only owner is allowed to\r\n   * freeze\/unfreeze transfers.\r\n   *\/\r\n  address owner;\r\n\r\n  \/**\r\n   * Whether transfers are currently frozen or not.\r\n   *\/\r\n  bool transfersFrozen = false;\r\n}",
      "officialLinks": {
        "Reddit": "",
        "Telegram": "",
        "Website": "http:\/\/blockchain.capital\/",
        "Email": "http:\/\/blockchain.capital\/contact\/",
        "Twitter": "https:\/\/twitter.com\/blockchaincap"
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xff3519eeeea3e76f1f699ccce5e23ee0bdda41ac#code"
    }, {
      "contractId": 52,
      "title": "MKR Token",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Maker",
      "code": "\/\/ MKR Token\r\n\r\n\/\/ hevm: flattened sources of src\/mkr-499.sol\r\npragma solidity ^0.4.15;\r\n\r\n\/\/\/\/\/\/ lib\/ds-roles\/lib\/ds-auth\/src\/auth.sol\r\n\/\/ This program is free software: you can redistribute it and\/or modify\r\n\/\/ it under the terms of the GNU General Public License as published by\r\n\/\/ the Free Software Foundation, either version 3 of the License, or\r\n\/\/ (at your option) any later version.\r\n\r\n\/\/ This program is distributed in the hope that it will be useful,\r\n\/\/ but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\/\/ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\/\/ GNU General Public License for more details.\r\n\r\n\/\/ You should have received a copy of the GNU General Public License\r\n\/\/ along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\r\n\r\n\/* pragma solidity ^0.4.13; *\/\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    function DSAuth() public {\r\n        owner = msg.sender;\r\n        LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n\r\n\/\/\/\/\/\/ lib\/ds-thing\/lib\/ds-math\/src\/math.sol\r\n\/\/\/ math.sol -- mixin for inline numerical wizardry\r\n\r\n\/\/ This program is free software: you can redistribute it and\/or modify\r\n\/\/ it under the terms of the GNU General Public License as published by\r\n\/\/ the Free Software Foundation, either version 3 of the License, or\r\n\/\/ (at your option) any later version.\r\n\r\n\/\/ This program is distributed in the hope that it will be useful,\r\n\/\/ but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\/\/ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\/\/ GNU General Public License for more details.\r\n\r\n\/\/ You should have received a copy of the GNU General Public License\r\n\/\/ along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\r\n\r\n\/* pragma solidity ^0.4.13; *\/\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) \/ y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD \/ 2) \/ WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY \/ 2) \/ RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y \/ 2) \/ y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y \/ 2) \/ y;\r\n    }\r\n\r\n    \/\/ This famous algorithm is called \"exponentiation by squaring\"\r\n    \/\/ and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    \/\/\r\n    \/\/ It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    \/\/\r\n    \/\/ These facts are why it works:\r\n    \/\/\r\n    \/\/  If n is even, then x^n = (x^2)^(n\/2).\r\n    \/\/  If n is odd,  then x^n = x * x^(n-1),\r\n    \/\/   and applying the equation for even x gives\r\n    \/\/    x^n = x * (x^2)^((n-1) \/ 2).\r\n    \/\/\r\n    \/\/  Also, EVM division is flooring and\r\n    \/\/    floor[(n-1) \/ 2] = floor[n \/ 2].\r\n    \/\/\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n \/= 2; n != 0; n \/= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\/\/\/\/\/\/ lib\/ds-thing\/lib\/ds-note\/src\/note.sol\r\n\/\/\/ note.sol -- the `note' modifier, for logging calls as events\r\n\r\n\/\/ This program is free software: you can redistribute it and\/or modify\r\n\/\/ it under the terms of the GNU General Public License as published by\r\n\/\/ the Free Software Foundation, either version 3 of the License, or\r\n\/\/ (at your option) any later version.\r\n\r\n\/\/ This program is distributed in the hope that it will be useful,\r\n\/\/ but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\/\/ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\/\/ GNU General Public License for more details.\r\n\r\n\/\/ You should have received a copy of the GNU General Public License\r\n\/\/ along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\r\n\r\n\/* pragma solidity ^0.4.13; *\/\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint              wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n        }\r\n\r\n        LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\r\n\r\n        _;\r\n    }\r\n}\r\n\r\n\/\/\/\/\/\/ lib\/ds-thing\/src\/thing.sol\r\n\/\/ thing.sol - `auth` with handy mixins. your things should be DSThings\r\n\r\n\/\/ Copyright (C) 2017  DappHub, LLC\r\n\r\n\/\/ This program is free software: you can redistribute it and\/or modify\r\n\/\/ it under the terms of the GNU General Public License as published by\r\n\/\/ the Free Software Foundation, either version 3 of the License, or\r\n\/\/ (at your option) any later version.\r\n\r\n\/\/ This program is distributed in the hope that it will be useful,\r\n\/\/ but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\/\/ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\/\/ GNU General Public License for more details.\r\n\r\n\/\/ You should have received a copy of the GNU General Public License\r\n\/\/ along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\r\n\r\n\/* pragma solidity ^0.4.13; *\/\r\n\r\n\/* import 'ds-auth\/auth.sol'; *\/\r\n\/* import 'ds-note\/note.sol'; *\/\r\n\/* import 'ds-math\/math.sol'; *\/\r\n\r\ncontract DSThing is DSAuth, DSNote, DSMath {\r\n}\r\n\r\n\/\/\/\/\/\/ lib\/ds-token\/lib\/ds-stop\/src\/stop.sol\r\n\/\/\/ stop.sol -- mixin for enable\/disable functionality\r\n\r\n\/\/ Copyright (C) 2017  DappHub, LLC\r\n\r\n\/\/ This program is free software: you can redistribute it and\/or modify\r\n\/\/ it under the terms of the GNU General Public License as published by\r\n\/\/ the Free Software Foundation, either version 3 of the License, or\r\n\/\/ (at your option) any later version.\r\n\r\n\/\/ This program is distributed in the hope that it will be useful,\r\n\/\/ but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\/\/ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\/\/ GNU General Public License for more details.\r\n\r\n\/\/ You should have received a copy of the GNU General Public License\r\n\/\/ along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\r\n\r\n\/* pragma solidity ^0.4.13; *\/\r\n\r\n\/* import \"ds-auth\/auth.sol\"; *\/\r\n\/* import \"ds-note\/note.sol\"; *\/\r\n\r\ncontract DSStop is DSNote, DSAuth {\r\n\r\n    bool public stopped;\r\n\r\n    modifier stoppable {\r\n        require(!stopped);\r\n        _;\r\n    }\r\n    function stop() public auth note {\r\n        stopped = true;\r\n    }\r\n    function start() public auth note {\r\n        stopped = false;\r\n    }\r\n\r\n}\r\n\r\n\/\/\/\/\/\/ lib\/ds-token\/lib\/erc20\/src\/erc20.sol\r\n\/\/ This program is free software: you can redistribute it and\/or modify\r\n\/\/ it under the terms of the GNU General Public License as published by\r\n\/\/ the Free Software Foundation, either version 3 of the License, or\r\n\/\/ (at your option) any later version.\r\n\r\n\/\/ This program is distributed in the hope that it will be useful,\r\n\/\/ but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\/\/ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\/\/ GNU General Public License for more details.\r\n\r\n\/\/ You should have received a copy of the GNU General Public License\r\n\/\/ along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\r\n\r\n\/* pragma solidity ^0.4.8; *\/\r\n\r\n\/\/ Token standard API\r\n\/\/ https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf( address who ) public view returns (uint value);\r\n    function allowance( address owner, address spender ) public view returns (uint _allowance);\r\n\r\n    function transfer( address to, uint value) public returns (bool ok);\r\n    function transferFrom( address from, address to, uint value) public returns (bool ok);\r\n    function approve( address spender, uint value ) public returns (bool ok);\r\n\r\n    event Transfer( address indexed from, address indexed to, uint value);\r\n    event Approval( address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\/\/\/\/\/\/ lib\/ds-token\/src\/base.sol\r\n\/\/\/ base.sol -- basic ERC20 implementation\r\n\r\n\/\/ Copyright (C) 2015, 2016, 2017  DappHub, LLC\r\n\r\n\/\/ This program is free software: you can redistribute it and\/or modify\r\n\/\/ it under the terms of the GNU General Public License as published by\r\n\/\/ the Free Software Foundation, either version 3 of the License, or\r\n\/\/ (at your option) any later version.\r\n\r\n\/\/ This program is distributed in the hope that it will be useful,\r\n\/\/ but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\/\/ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\/\/ GNU General Public License for more details.\r\n\r\n\/\/ You should have received a copy of the GNU General Public License\r\n\/\/ along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\r\n\r\n\/* pragma solidity ^0.4.13; *\/\r\n\r\n\/* import \"erc20\/erc20.sol\"; *\/\r\n\/* import \"ds-math\/math.sol\"; *\/\r\n\r\ncontract DSTokenBase is ERC20, DSMath {\r\n    uint256                                            _supply;\r\n    mapping (address => uint256)                       _balances;\r\n    mapping (address => mapping (address => uint256))  _approvals;\r\n\r\n    function DSTokenBase(uint supply) public {\r\n        _balances[msg.sender] = supply;\r\n        _supply = supply;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return _supply;\r\n    }\r\n    function balanceOf(address src) public view returns (uint) {\r\n        return _balances[src];\r\n    }\r\n    function allowance(address src, address guy) public view returns (uint) {\r\n        return _approvals[src][guy];\r\n    }\r\n\r\n    function transfer(address dst, uint wad) public returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        returns (bool)\r\n    {\r\n        if (src != msg.sender) {\r\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\r\n        }\r\n\r\n        _balances[src] = sub(_balances[src], wad);\r\n        _balances[dst] = add(_balances[dst], wad);\r\n\r\n        Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n\r\n    function approve(address guy, uint wad) public returns (bool) {\r\n        _approvals[msg.sender][guy] = wad;\r\n\r\n        Approval(msg.sender, guy, wad);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n\/\/\/\/\/\/ lib\/ds-token\/src\/token.sol\r\n\/\/\/ token.sol -- ERC20 implementation with minting and burning\r\n\r\n\/\/ Copyright (C) 2015, 2016, 2017  DappHub, LLC\r\n\r\n\/\/ This program is free software: you can redistribute it and\/or modify\r\n\/\/ it under the terms of the GNU General Public License as published by\r\n\/\/ the Free Software Foundation, either version 3 of the License, or\r\n\/\/ (at your option) any later version.\r\n\r\n\/\/ This program is distributed in the hope that it will be useful,\r\n\/\/ but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n\/\/ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n\/\/ GNU General Public License for more details.\r\n\r\n\/\/ You should have received a copy of the GNU General Public License\r\n\/\/ along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\r\n\r\n\/* pragma solidity ^0.4.13; *\/\r\n\r\n\/* import \"ds-stop\/stop.sol\"; *\/\r\n\r\n\/* import \".\/base.sol\"; *\/\r\n\r\ncontract DSToken is DSTokenBase(0), DSStop {\r\n\r\n    bytes32  public  symbol;\r\n    uint256  public  decimals = 18; \/\/ standard token precision. override to customize\r\n\r\n    function DSToken(bytes32 symbol_) public {\r\n        symbol = symbol_;\r\n    }\r\n\r\n    event Mint(address indexed guy, uint wad);\r\n    event Burn(address indexed guy, uint wad);\r\n\r\n    function approve(address guy) public stoppable returns (bool) {\r\n        return super.approve(guy, uint(-1));\r\n    }\r\n\r\n    function approve(address guy, uint wad) public stoppable returns (bool) {\r\n        return super.approve(guy, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        stoppable\r\n        returns (bool)\r\n    {\r\n        if (src != msg.sender && _approvals[src][msg.sender] != uint(-1)) {\r\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\r\n        }\r\n\r\n        _balances[src] = sub(_balances[src], wad);\r\n        _balances[dst] = add(_balances[dst], wad);\r\n\r\n        Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n\r\n    function push(address dst, uint wad) public {\r\n        transferFrom(msg.sender, dst, wad);\r\n    }\r\n    function pull(address src, uint wad) public {\r\n        transferFrom(src, msg.sender, wad);\r\n    }\r\n    function move(address src, address dst, uint wad) public {\r\n        transferFrom(src, dst, wad);\r\n    }\r\n\r\n    function mint(uint wad) public {\r\n        mint(msg.sender, wad);\r\n    }\r\n    function burn(uint wad) public {\r\n        burn(msg.sender, wad);\r\n    }\r\n    function mint(address guy, uint wad) public auth stoppable {\r\n        _balances[guy] = add(_balances[guy], wad);\r\n        _supply = add(_supply, wad);\r\n        Mint(guy, wad);\r\n    }\r\n    function burn(address guy, uint wad) public auth stoppable {\r\n        if (guy != msg.sender && _approvals[guy][msg.sender] != uint(-1)) {\r\n            _approvals[guy][msg.sender] = sub(_approvals[guy][msg.sender], wad);\r\n        }\r\n\r\n        _balances[guy] = sub(_balances[guy], wad);\r\n        _supply = sub(_supply, wad);\r\n        Burn(guy, wad);\r\n    }\r\n\r\n    \/\/ Optional token name\r\n    bytes32   public  name = \"\";\r\n\r\n    function setName(bytes32 name_) public auth {\r\n        name = name_;\r\n    }\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/r\/MakerDAO\/",
        "Telegram": "",
        "Website": "https:\/\/makerdao.com\/",
        "Email": "",
        "Twitter": ""
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2#code"
    }, {
      "contractId": 53,
      "title": "Unicorns Token",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "Unicorns",
      "code": "contract owned {\r\n        address public owner;\r\n\r\n        function owned() {\r\n                owner = msg.sender;\r\n        }\r\n\r\n        modifier onlyOwner {\r\n                if (msg.sender != owner) throw;\r\n                _\r\n        }\r\n\r\n        function transferOwnership(address newOwner) onlyOwner {\r\n                owner = newOwner;\r\n        }\r\n}\r\n\r\n\/* The token is used as a voting shares *\/\r\ncontract token {\r\n        function mintToken(address target, uint256 mintedAmount);\r\n}\r\n\r\ncontract Congress is owned {\r\n\r\n        \/* Contract Variables and events *\/\r\n        uint public minimumQuorum;\r\n        uint public debatingPeriodInMinutes;\r\n        int public majorityMargin;\r\n        Proposal[] public proposals;\r\n        uint public numProposals;\r\n        mapping(address => uint) public memberId;\r\n        Member[] public members;\r\n\r\n        address public unicornAddress;\r\n        uint public priceOfAUnicornInFinney;\r\n\r\n        event ProposalAdded(uint proposalID, address recipient, uint amount, string description);\r\n        event Voted(uint proposalID, bool position, address voter, string justification);\r\n        event ProposalTallied(uint proposalID, int result, uint quorum, bool active);\r\n        event MembershipChanged(address member);\r\n        event ChangeOfRules(uint minimumQuorum, uint debatingPeriodInMinutes, int majorityMargin);\r\n\r\n        struct Proposal {\r\n                address recipient;\r\n                uint amount;\r\n                string description;\r\n                uint votingDeadline;\r\n                bool executed;\r\n                bool proposalPassed;\r\n                uint numberOfVotes;\r\n                int currentResult;\r\n                bytes32 proposalHash;\r\n                Vote[] votes;\r\n                mapping(address => bool) voted;\r\n        }\r\n\r\n        struct Member {\r\n                address member;\r\n                uint voteWeight;\r\n                bool canAddProposals;\r\n                string name;\r\n                uint memberSince;\r\n        }\r\n\r\n        struct Vote {\r\n                bool inSupport;\r\n                address voter;\r\n                string justification;\r\n        }\r\n\r\n\r\n        \/* First time setup *\/\r\n        function Congress(uint minimumQuorumForProposals, uint minutesForDebate, int marginOfVotesForMajority, address congressLeader) {\r\n                minimumQuorum = minimumQuorumForProposals;\r\n                debatingPeriodInMinutes = minutesForDebate;\r\n                majorityMargin = marginOfVotesForMajority;\r\n                members.length++;\r\n                members[0] = Member({\r\n                        member: 0,\r\n                        voteWeight: 0,\r\n                        canAddProposals: false,\r\n                        memberSince: now,\r\n                        name: ''\r\n                });\r\n                if (congressLeader != 0) owner = congressLeader;\r\n\r\n        }\r\n\r\n        \/*make member*\/\r\n        function changeMembership(address targetMember, uint voteWeight, bool canAddProposals, string memberName) onlyOwner {\r\n                uint id;\r\n                if (memberId[targetMember] == 0) {\r\n                        memberId[targetMember] = members.length;\r\n                        id = members.length++;\r\n                        members[id] = Member({\r\n                                member: targetMember,\r\n                                voteWeight: voteWeight,\r\n                                canAddProposals: canAddProposals,\r\n                                memberSince: now,\r\n                                name: memberName\r\n                        });\r\n                } else {\r\n                        id = memberId[targetMember];\r\n                        Member m = members[id];\r\n                        m.voteWeight = voteWeight;\r\n                        m.canAddProposals = canAddProposals;\r\n                        m.name = memberName;\r\n                }\r\n\r\n                MembershipChanged(targetMember);\r\n\r\n        }\r\n\r\n        \/*change rules*\/\r\n        function changeVotingRules(uint minimumQuorumForProposals, uint minutesForDebate, int marginOfVotesForMajority) onlyOwner {\r\n                minimumQuorum = minimumQuorumForProposals;\r\n                debatingPeriodInMinutes = minutesForDebate;\r\n                majorityMargin = marginOfVotesForMajority;\r\n\r\n                ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, majorityMargin);\r\n        }\r\n\r\n        \/\/ ribbonPriceInEther\r\n        function changeUnicorn(uint newUnicornPriceInFinney, address newUnicornAddress) onlyOwner {\r\n                unicornAddress = newUnicornAddress;\r\n                priceOfAUnicornInFinney = newUnicornPriceInFinney;\r\n        }\r\n\r\n        \/* Function to create a new proposal *\/\r\n        function newProposalInWei(address beneficiary, uint weiAmount, string JobDescription, bytes transactionBytecode) returns(uint proposalID) {\r\n                if (memberId[msg.sender] == 0 || !members[memberId[msg.sender]].canAddProposals) throw;\r\n\r\n                proposalID = proposals.length++;\r\n                Proposal p = proposals[proposalID];\r\n                p.recipient = beneficiary;\r\n                p.amount = weiAmount;\r\n                p.description = JobDescription;\r\n                p.proposalHash = sha3(beneficiary, weiAmount, transactionBytecode);\r\n                p.votingDeadline = now + debatingPeriodInMinutes * 1 minutes;\r\n                p.executed = false;\r\n                p.proposalPassed = false;\r\n                p.numberOfVotes = 0;\r\n                ProposalAdded(proposalID, beneficiary, weiAmount, JobDescription);\r\n                numProposals = proposalID + 1;\r\n        }\r\n\r\n        \/* Function to create a new proposal *\/\r\n        function newProposalInEther(address beneficiary, uint etherAmount, string JobDescription, bytes transactionBytecode) returns(uint proposalID) {\r\n                if (memberId[msg.sender] == 0 || !members[memberId[msg.sender]].canAddProposals) throw;\r\n\r\n                proposalID = proposals.length++;\r\n                Proposal p = proposals[proposalID];\r\n                p.recipient = beneficiary;\r\n                p.amount = etherAmount * 1 ether;\r\n                p.description = JobDescription;\r\n                p.proposalHash = sha3(beneficiary, etherAmount * 1 ether, transactionBytecode);\r\n                p.votingDeadline = now + debatingPeriodInMinutes * 1 minutes;\r\n                p.executed = false;\r\n                p.proposalPassed = false;\r\n                p.numberOfVotes = 0;\r\n                ProposalAdded(proposalID, beneficiary, etherAmount, JobDescription);\r\n                numProposals = proposalID + 1;\r\n        }\r\n\r\n        \/* function to check if a proposal code matches *\/\r\n        function checkProposalCode(uint proposalNumber, address beneficiary, uint amount, bytes transactionBytecode) constant returns(bool codeChecksOut) {\r\n                Proposal p = proposals[proposalNumber];\r\n                return p.proposalHash == sha3(beneficiary, amount, transactionBytecode);\r\n        }\r\n\r\n        function vote(uint proposalNumber, bool supportsProposal, string justificationText) returns(uint voteID) {\r\n                if (memberId[msg.sender] == 0) throw;\r\n\r\n                uint voteWeight = members[memberId[msg.sender]].voteWeight;\r\n\r\n                Proposal p = proposals[proposalNumber]; \/\/ Get the proposal\r\n                if (p.voted[msg.sender] == true) throw; \/\/ If has already voted, cancel\r\n                p.voted[msg.sender] = true; \/\/ Set this voter as having voted\r\n                p.numberOfVotes += voteWeight; \/\/ Increase the number of votes\r\n                if (supportsProposal) { \/\/ If they support the proposal\r\n                        p.currentResult += int(voteWeight); \/\/ Increase score\r\n                } else { \/\/ If they don't\r\n                        p.currentResult -= int(voteWeight); \/\/ Decrease the score\r\n                }\r\n                \/\/ Create a log of this event\r\n                Voted(proposalNumber, supportsProposal, msg.sender, justificationText);\r\n        }\r\n\r\n        function executeProposal(uint proposalNumber, bytes transactionBytecode) returns(int result) {\r\n                Proposal p = proposals[proposalNumber];\r\n                \/* Check if the proposal can be executed *\/\r\n                if (now < p.votingDeadline \/\/ has the voting deadline arrived?  \r\n                        || p.executed \/\/ has it been already executed? \r\n                        || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) \/\/ Does the transaction code match the proposal? \r\n                        || p.numberOfVotes < minimumQuorum) \/\/ has minimum quorum?\r\n                        throw;\r\n\r\n                \/* execute result *\/\r\n                if (p.currentResult > majorityMargin) {\r\n                        \/* If difference between support and opposition is larger than margin *\/\r\n                        p.recipient.call.value(p.amount)(transactionBytecode);\r\n                        p.executed = true;\r\n                        p.proposalPassed = true;\r\n                } else {\r\n                        p.executed = true;\r\n                        p.proposalPassed = false;\r\n                }\r\n                \/\/ Fire Events\r\n                ProposalTallied(proposalNumber, p.currentResult, p.numberOfVotes, p.proposalPassed);\r\n        }\r\n\r\n        function() {\r\n                if (msg.value > priceOfAUnicornInFinney) {\r\n                        token unicorn = token(unicornAddress);\r\n                        unicorn.mintToken(msg.sender, msg.value \/ (priceOfAUnicornInFinney * 1 finney));\r\n                }\r\n\r\n        }\r\n}\r\n\r\n\r\ncontract MyToken is owned {\r\n        \/* Public variables of the token *\/\r\n        string public name;\r\n        string public symbol;\r\n        uint8 public decimals;\r\n        uint256 public totalSupply;\r\n\r\n        \/* This creates an array with all balances *\/\r\n        mapping(address => uint256) public balanceOf;\r\n        mapping(address => bool) public frozenAccount;\r\n        mapping(address => mapping(address => uint)) public allowance;\r\n        mapping(address => mapping(address => uint)) public spentAllowance;\r\n\r\n\r\n        \/* This generates a public event on the blockchain that will notify clients *\/\r\n        event Transfer(address indexed from, address indexed to, uint256 value);\r\n        event FrozenFunds(address target, bool frozen);\r\n\r\n        \/* Initializes contract with initial supply tokens to the creator of the contract *\/\r\n        function MyToken(uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol, address centralMinter) {\r\n                if (centralMinter != 0) owner = centralMinter; \/\/ Sets the minter\r\n                balanceOf[msg.sender] = initialSupply; \/\/ Give the creator all initial tokens                    \r\n                name = tokenName; \/\/ Set the name for display purposes     \r\n                symbol = tokenSymbol; \/\/ Set the symbol for display purposes    \r\n                decimals = decimalUnits; \/\/ Amount of decimals for display purposes        \r\n                totalSupply = initialSupply;\r\n        }\r\n\r\n        \/* Send coins *\/\r\n        function transfer(address _to, uint256 _value) {\r\n                if (balanceOf[msg.sender] < _value) throw; \/\/ Check if the sender has enough   \r\n                if (balanceOf[_to] + _value < balanceOf[_to]) throw; \/\/ Check for overflows\r\n                if (frozenAccount[msg.sender]) throw; \/\/ Check if frozen\r\n                balanceOf[msg.sender] -= _value; \/\/ Subtract from the sender\r\n                balanceOf[_to] += _value; \/\/ Add the same to the recipient            \r\n                Transfer(msg.sender, _to, _value); \/\/ Notify anyone listening that this transfer took place\r\n        }\r\n\r\n        function mintToken(address target, uint256 mintedAmount) onlyOwner {\r\n                balanceOf[target] += mintedAmount;\r\n                totalSupply += mintedAmount;\r\n                Transfer(owner, target, mintedAmount);\r\n        }\r\n\r\n        function freezeAccount(address target, bool freeze) onlyOwner {\r\n                frozenAccount[target] = freeze;\r\n                FrozenFunds(target, freeze);\r\n        }\r\n\r\n        function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\r\n                if (balanceOf[_from] < _value) throw; \/\/ Check if the sender has enough   \r\n                if (balanceOf[_to] + _value < balanceOf[_to]) throw; \/\/ Check for overflows\r\n                if (frozenAccount[_from]) throw; \/\/ Check if frozen\r\n                if (spentAllowance[_from][msg.sender] + _value > allowance[_from][msg.sender]) throw; \/\/ Check allowance\r\n                balanceOf[_from] -= _value; \/\/ Subtract from the sender\r\n                balanceOf[_to] += _value; \/\/ Add the same to the recipient            \r\n                spentAllowance[_from][msg.sender] += _value;\r\n                Transfer(msg.sender, _to, _value);\r\n        }\r\n\r\n        function approve(address _spender, uint256 _value) returns(bool success) {\r\n                allowance[msg.sender][_spender] = _value;\r\n        }\r\n\r\n        function() {\r\n                \/\/owner.send(msg.value);\r\n                throw;\r\n        }\r\n}",
      "officialLinks": {
        "Reddit": "",
        "Telegram": "",
        "Website": "https:\/\/www.ethereum.org\/donate",
        "Email": "mailto:donate@ethereum.org",
        "Twitter": ""
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0x89205a3a3b2a69de6dbf7f01ed13b2108b2c43e7#code"
    }, {
      "contractId": 54,
      "title": "MiniMeToken",
      "category": "ERC20",
      "tag": "ERC20",
      "author": "White Hat Donation Token",
      "code": "pragma solidity ^0.4.13;\r\n\r\n\/*\r\n    Copyright 2016, Jordi Baylina\r\n\r\n    This program is free software: you can redistribute it and\/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\r\n *\/\r\n\r\n\/\/ Abstract contract for the full ERC 20 Token standard\r\n\/\/ https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n\r\ncontract ERC20Token {\r\n    \/* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    *\/\r\n    \/\/\/ total amount of tokens\r\n    uint256 public totalSupply;\r\n\r\n    \/\/\/ @param _owner The address from which the balance will be retrieved\r\n    \/\/\/ @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    \/\/\/ @notice send `_value` token to `_to` from `msg.sender`\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _value The amount of token to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    \/\/\/ @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    \/\/\/ @param _from The address of the sender\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _value The amount of token to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n\r\n    \/\/\/ @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @param _value The amount of tokens to be approved for transfer\r\n    \/\/\/ @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    \/\/\/ @param _owner The address of the account owning tokens\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n\r\n\/\/\/ @title MiniMeToken Contract\r\n\/\/\/ @author Jordi Baylina\r\n\/\/\/ @dev This token contract's goal is to make it easy for anyone to clone this\r\n\/\/\/  token using the token distribution at a given block, this will allow DAO's\r\n\/\/\/  and DApps to upgrade their features in a decentralized manner without\r\n\/\/\/  affecting the original token\r\n\/\/\/ @dev It is ERC20 compliant, but still needs to under go further testing.\r\n\r\n\r\n\/\/\/ @dev The token controller contract must implement these functions\r\ncontract TokenController {\r\n    \/\/\/ @notice Called when `_owner` sends ether to the MiniMe Token contract\r\n    \/\/\/ @param _owner The address that sent the ether to create tokens\r\n    \/\/\/ @return True if the ether is accepted, false if it throws\r\n    function proxyPayment(address _owner) payable returns(bool);\r\n\r\n    \/\/\/ @notice Notifies the controller about a token transfer allowing the\r\n    \/\/\/  controller to react if desired\r\n    \/\/\/ @param _from The origin of the transfer\r\n    \/\/\/ @param _to The destination of the transfer\r\n    \/\/\/ @param _amount The amount of the transfer\r\n    \/\/\/ @return False if the controller does not authorize the transfer\r\n    function onTransfer(address _from, address _to, uint _amount) returns(bool);\r\n\r\n    \/\/\/ @notice Notifies the controller about an approval allowing the\r\n    \/\/\/  controller to react if desired\r\n    \/\/\/ @param _owner The address that calls `approve()`\r\n    \/\/\/ @param _spender The spender in the `approve()` call\r\n    \/\/\/ @param _amount The amount in the `approve()` call\r\n    \/\/\/ @return False if the controller does not authorize the approval\r\n    function onApprove(address _owner, address _spender, uint _amount)\r\n        returns(bool);\r\n}\r\n\r\ncontract Controlled {\r\n    \/\/\/ @notice The address of the controller is the only address that can call\r\n    \/\/\/  a function with this modifier\r\n    modifier onlyController { if (msg.sender != controller) throw; _; }\r\n\r\n    address public controller;\r\n\r\n    function Controlled() { controller = msg.sender;}\r\n\r\n    \/\/\/ @notice Changes the controller of the contract\r\n    \/\/\/ @param _newController The new controller of the contract\r\n    function changeController(address _newController) onlyController {\r\n        controller = _newController;\r\n    }\r\n}\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 _amount, address _token, bytes _data);\r\n}\r\n\r\n\/\/\/ @dev The actual token contract, the default controller is the msg.sender\r\n\/\/\/  that deploys the contract, so usually this token will be deployed by a\r\n\/\/\/  token controller contract, which Giveth will call a \"Campaign\"\r\ncontract MiniMeToken is Controlled {\r\n\r\n    string public name;                \/\/The Token's name: e.g. DigixDAO Tokens\r\n    uint8 public decimals;             \/\/Number of decimals of the smallest unit\r\n    string public symbol;              \/\/An identifier: e.g. REP\r\n    string public version = 'MMT_0.1'; \/\/An arbitrary versioning scheme\r\n\r\n\r\n    \/\/\/ @dev `Checkpoint` is the structure that attaches a block number to a\r\n    \/\/\/  given value, the block number attached is the one that last changed the\r\n    \/\/\/  value\r\n    struct  Checkpoint {\r\n\r\n        \/\/ `fromBlock` is the block number that the value was generated from\r\n        uint128 fromBlock;\r\n\r\n        \/\/ `value` is the amount of tokens at a specific block number\r\n        uint128 value;\r\n    }\r\n\r\n    \/\/ `parentToken` is the Token address that was cloned to produce this token;\r\n    \/\/  it will be 0x0 for a token that was not cloned\r\n    MiniMeToken public parentToken;\r\n\r\n    \/\/ `parentSnapShotBlock` is the block number from the Parent Token that was\r\n    \/\/  used to determine the initial distribution of the Clone Token\r\n    uint public parentSnapShotBlock;\r\n\r\n    \/\/ `creationBlock` is the block number that the Clone Token was created\r\n    uint public creationBlock;\r\n\r\n    \/\/ `balances` is the map that tracks the balance of each address, in this\r\n    \/\/  contract when the balance changes the block number that the change\r\n    \/\/  occurred is also included in the map\r\n    mapping (address => Checkpoint[]) balances;\r\n\r\n    \/\/ `allowed` tracks any extra transfer rights as in all ERC20 tokens\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    \/\/ Tracks the history of the `totalSupply` of the token\r\n    Checkpoint[] totalSupplyHistory;\r\n\r\n    \/\/ Flag that determines if the token is transferable or not.\r\n    bool public transfersEnabled;\r\n\r\n    \/\/ The factory used to create new clone tokens\r\n    MiniMeTokenFactory public tokenFactory;\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Constructor\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice Constructor to create a MiniMeToken\r\n    \/\/\/ @param _tokenFactory The address of the MiniMeTokenFactory contract that\r\n    \/\/\/  will create the Clone token contracts, the token factory needs to be\r\n    \/\/\/  deployed first\r\n    \/\/\/ @param _parentToken Address of the parent token, set to 0x0 if it is a\r\n    \/\/\/  new token\r\n    \/\/\/ @param _parentSnapShotBlock Block of the parent token that will\r\n    \/\/\/  determine the initial distribution of the clone token, set to 0 if it\r\n    \/\/\/  is a new token\r\n    \/\/\/ @param _tokenName Name of the new token\r\n    \/\/\/ @param _decimalUnits Number of decimals of the new token\r\n    \/\/\/ @param _tokenSymbol Token Symbol for the new token\r\n    \/\/\/ @param _transfersEnabled If true, tokens will be able to be transferred\r\n    function MiniMeToken(\r\n        address _tokenFactory,\r\n        address _parentToken,\r\n        uint _parentSnapShotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    ) {\r\n        tokenFactory = MiniMeTokenFactory(_tokenFactory);\r\n        name = _tokenName;                                 \/\/ Set the name\r\n        decimals = _decimalUnits;                          \/\/ Set the decimals\r\n        symbol = _tokenSymbol;                             \/\/ Set the symbol\r\n        parentToken = MiniMeToken(_parentToken);\r\n        parentSnapShotBlock = _parentSnapShotBlock;\r\n        transfersEnabled = _transfersEnabled;\r\n        creationBlock = block.number;\r\n    }\r\n\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ ERC20 Methods\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice Send `_amount` tokens to `_to` from `msg.sender`\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _amount The amount of tokens to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _amount) returns (bool success) {\r\n        if (!transfersEnabled) throw;\r\n        return doTransfer(msg.sender, _to, _amount);\r\n    }\r\n\r\n    \/\/\/ @notice Send `_amount` tokens to `_to` from `_from` on the condition it\r\n    \/\/\/  is approved by `_from`\r\n    \/\/\/ @param _from The address holding the tokens being transferred\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _amount The amount of tokens to be transferred\r\n    \/\/\/ @return True if the transfer was successful\r\n    function transferFrom(address _from, address _to, uint256 _amount\r\n    ) returns (bool success) {\r\n\r\n        \/\/ The controller of this contract can move tokens around at will,\r\n        \/\/  this is important to recognize! Confirm that you trust the\r\n        \/\/  controller of this contract, which in most situations should be\r\n        \/\/  another open source smart contract or 0x0\r\n        if (msg.sender != controller) {\r\n            if (!transfersEnabled) throw;\r\n\r\n            \/\/ The standard ERC 20 transferFrom functionality\r\n            if (allowed[_from][msg.sender] < _amount) return false;\r\n            allowed[_from][msg.sender] -= _amount;\r\n        }\r\n        return doTransfer(_from, _to, _amount);\r\n    }\r\n\r\n    \/\/\/ @dev This is the actual transfer function in the token contract, it can\r\n    \/\/\/  only be called by other functions in this contract.\r\n    \/\/\/ @param _from The address holding the tokens being transferred\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _amount The amount of tokens to be transferred\r\n    \/\/\/ @return True if the transfer was successful\r\n    function doTransfer(address _from, address _to, uint _amount\r\n    ) internal returns(bool) {\r\n\r\n           if (_amount == 0) {\r\n               return true;\r\n           }\r\n\r\n           if (parentSnapShotBlock >= block.number) throw;\r\n\r\n           \/\/ Do not allow transfer to 0x0 or the token contract itself\r\n           if ((_to == 0) || (_to == address(this))) throw;\r\n\r\n           \/\/ If the amount being transfered is more than the balance of the\r\n           \/\/  account the transfer returns false\r\n           var previousBalanceFrom = balanceOfAt(_from, block.number);\r\n           if (previousBalanceFrom < _amount) {\r\n               return false;\r\n           }\r\n\r\n           \/\/ Alerts the token controller of the transfer\r\n           if (isContract(controller)) {\r\n               if (!TokenController(controller).onTransfer(_from, _to, _amount))\r\n               throw;\r\n           }\r\n\r\n           \/\/ First update the balance array with the new value for the address\r\n           \/\/  sending the tokens\r\n           updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\r\n\r\n           \/\/ Then update the balance array with the new value for the address\r\n           \/\/  receiving the tokens\r\n           var previousBalanceTo = balanceOfAt(_to, block.number);\r\n           if (previousBalanceTo + _amount < previousBalanceTo) throw; \/\/ Check for overflow\r\n           updateValueAtNow(balances[_to], previousBalanceTo + _amount);\r\n\r\n           \/\/ An event to make the transfer easy to find on the blockchain\r\n           Transfer(_from, _to, _amount);\r\n\r\n           return true;\r\n    }\r\n\r\n    \/\/\/ @param _owner The address that's balance is being requested\r\n    \/\/\/ @return The balance of `_owner` at the current block\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balanceOfAt(_owner, block.number);\r\n    }\r\n\r\n    \/\/\/ @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\r\n    \/\/\/  its behalf. This is a modified version of the ERC20 approve function\r\n    \/\/\/  to be a little bit safer\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @param _amount The amount of tokens to be approved for transfer\r\n    \/\/\/ @return True if the approval was successful\r\n    function approve(address _spender, uint256 _amount) returns (bool success) {\r\n        if (!transfersEnabled) throw;\r\n\r\n        \/\/ To change the approve amount you first have to reduce the addresses`\r\n        \/\/  allowance to zero by calling `approve(_spender,0)` if it is not\r\n        \/\/  already 0 to mitigate the race condition described here:\r\n        \/\/  https:\/\/github.com\/ethereum\/EIPs\/issues\/20#issuecomment-263524729\r\n        if ((_amount!=0) && (allowed[msg.sender][_spender] !=0)) throw;\r\n\r\n        \/\/ Alerts the token controller of the approve function call\r\n        if (isContract(controller)) {\r\n            if (!TokenController(controller).onApprove(msg.sender, _spender, _amount))\r\n                throw;\r\n        }\r\n\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    \/\/\/ @dev This function makes it easy to read the `allowed[]` map\r\n    \/\/\/ @param _owner The address of the account that owns the token\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @return Amount of remaining tokens of _owner that _spender is allowed\r\n    \/\/\/  to spend\r\n    function allowance(address _owner, address _spender\r\n    ) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    \/\/\/ @notice `msg.sender` approves `_spender` to send `_amount` tokens on\r\n    \/\/\/  its behalf, and then a function is triggered in the contract that is\r\n    \/\/\/  being approved, `_spender`. This allows users to use their tokens to\r\n    \/\/\/  interact with contracts in one function call instead of two\r\n    \/\/\/ @param _spender The address of the contract able to transfer the tokens\r\n    \/\/\/ @param _amount The amount of tokens to be approved for transfer\r\n    \/\/\/ @return True if the function call was successful\r\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\r\n    ) returns (bool success) {\r\n        if (!approve(_spender, _amount)) throw;\r\n\r\n        ApproveAndCallFallBack(_spender).receiveApproval(\r\n            msg.sender,\r\n            _amount,\r\n            this,\r\n            _extraData\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    \/\/\/ @dev This function makes it easy to get the total number of tokens\r\n    \/\/\/ @return The total number of tokens\r\n    function totalSupply() constant returns (uint) {\r\n        return totalSupplyAt(block.number);\r\n    }\r\n\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Query balance and totalSupply in History\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @dev Queries the balance of `_owner` at a specific `_blockNumber`\r\n    \/\/\/ @param _owner The address from which the balance will be retrieved\r\n    \/\/\/ @param _blockNumber The block number when the balance is queried\r\n    \/\/\/ @return The balance at `_blockNumber`\r\n    function balanceOfAt(address _owner, uint _blockNumber) constant\r\n        returns (uint) {\r\n\r\n        \/\/ These next few lines are used when the balance of the token is\r\n        \/\/  requested before a check point was ever created for this token, it\r\n        \/\/  requires that the `parentToken.balanceOfAt` be queried at the\r\n        \/\/  genesis block for that token as this contains initial balance of\r\n        \/\/  this token\r\n        if ((balances[_owner].length == 0)\r\n            || (balances[_owner][0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                \/\/ Has no parent\r\n                return 0;\r\n            }\r\n\r\n        \/\/ This will return the expected balance during normal situations\r\n        } else {\r\n            return getValueAt(balances[_owner], _blockNumber);\r\n        }\r\n    }\r\n\r\n    \/\/\/ @notice Total amount of tokens at a specific `_blockNumber`.\r\n    \/\/\/ @param _blockNumber The block number when the totalSupply is queried\r\n    \/\/\/ @return The total amount of tokens at `_blockNumber`\r\n    function totalSupplyAt(uint _blockNumber) constant returns(uint) {\r\n\r\n        \/\/ These next few lines are used when the totalSupply of the token is\r\n        \/\/  requested before a check point was ever created for this token, it\r\n        \/\/  requires that the `parentToken.totalSupplyAt` be queried at the\r\n        \/\/  genesis block for this token as that contains totalSupply of this\r\n        \/\/  token at this block number.\r\n        if ((totalSupplyHistory.length == 0)\r\n            || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                return 0;\r\n            }\r\n\r\n        \/\/ This will return the expected totalSupply during normal situations\r\n        } else {\r\n            return getValueAt(totalSupplyHistory, _blockNumber);\r\n        }\r\n    }\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Clone Token Method\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice Creates a new clone token with the initial distribution being\r\n    \/\/\/  this token at `_snapshotBlock`\r\n    \/\/\/ @param _cloneTokenName Name of the clone token\r\n    \/\/\/ @param _cloneDecimalUnits Number of decimals of the smallest unit\r\n    \/\/\/ @param _cloneTokenSymbol Symbol of the clone token\r\n    \/\/\/ @param _snapshotBlock Block when the distribution of the parent token is\r\n    \/\/\/  copied to set the initial distribution of the new clone token;\r\n    \/\/\/  if the block is zero than the actual block, the current block is used\r\n    \/\/\/ @param _transfersEnabled True if transfers are allowed in the clone\r\n    \/\/\/ @return The address of the new MiniMeToken Contract\r\n    function createCloneToken(\r\n        string _cloneTokenName,\r\n        uint8 _cloneDecimalUnits,\r\n        string _cloneTokenSymbol,\r\n        uint _snapshotBlock,\r\n        bool _transfersEnabled\r\n        ) returns(address) {\r\n        if (_snapshotBlock == 0) _snapshotBlock = block.number;\r\n        MiniMeToken cloneToken = tokenFactory.createCloneToken(\r\n            this,\r\n            _snapshotBlock,\r\n            _cloneTokenName,\r\n            _cloneDecimalUnits,\r\n            _cloneTokenSymbol,\r\n            _transfersEnabled\r\n            );\r\n\r\n        cloneToken.changeController(msg.sender);\r\n\r\n        \/\/ An event to make the token easy to find on the blockchain\r\n        NewCloneToken(address(cloneToken), _snapshotBlock);\r\n        return address(cloneToken);\r\n    }\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Generate and destroy tokens\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice Generates `_amount` tokens that are assigned to `_owner`\r\n    \/\/\/ @param _owner The address that will be assigned the new tokens\r\n    \/\/\/ @param _amount The quantity of tokens generated\r\n    \/\/\/ @return True if the tokens are generated correctly\r\n    function generateTokens(address _owner, uint _amount\r\n    ) onlyController returns (bool) {\r\n        uint curTotalSupply = getValueAt(totalSupplyHistory, block.number);\r\n        if (curTotalSupply + _amount < curTotalSupply) throw; \/\/ Check for overflow\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\r\n        var previousBalanceTo = balanceOf(_owner);\r\n        if (previousBalanceTo + _amount < previousBalanceTo) throw; \/\/ Check for overflow\r\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\r\n        Transfer(0, _owner, _amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    \/\/\/ @notice Burns `_amount` tokens from `_owner`\r\n    \/\/\/ @param _owner The address that will lose the tokens\r\n    \/\/\/ @param _amount The quantity of tokens to burn\r\n    \/\/\/ @return True if the tokens are burned correctly\r\n    function destroyTokens(address _owner, uint _amount\r\n    ) onlyController returns (bool) {\r\n        uint curTotalSupply = getValueAt(totalSupplyHistory, block.number);\r\n        if (curTotalSupply < _amount) throw;\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\r\n        var previousBalanceFrom = balanceOf(_owner);\r\n        if (previousBalanceFrom < _amount) throw;\r\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\r\n        Transfer(_owner, 0, _amount);\r\n        return true;\r\n    }\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Enable tokens transfers\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n\r\n    \/\/\/ @notice Enables token holders to transfer their tokens freely if true\r\n    \/\/\/ @param _transfersEnabled True if transfers are allowed in the clone\r\n    function enableTransfers(bool _transfersEnabled) onlyController {\r\n        transfersEnabled = _transfersEnabled;\r\n    }\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Internal helper functions to query and set a value in a snapshot array\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @dev `getValueAt` retrieves the number of tokens at a given block number\r\n    \/\/\/ @param checkpoints The history of values being queried\r\n    \/\/\/ @param _block The block number to retrieve the value at\r\n    \/\/\/ @return The number of tokens being queried\r\n    function getValueAt(Checkpoint[] storage checkpoints, uint _block\r\n    ) constant internal returns (uint) {\r\n        if (checkpoints.length == 0) return 0;\r\n\r\n        \/\/ Shortcut for the actual value\r\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\r\n            return checkpoints[checkpoints.length-1].value;\r\n        if (_block < checkpoints[0].fromBlock) return 0;\r\n\r\n        \/\/ Binary search of the value in the array\r\n        uint min = 0;\r\n        uint max = checkpoints.length-1;\r\n        while (max > min) {\r\n            uint mid = (max + min + 1)\/ 2;\r\n            if (checkpoints[mid].fromBlock<=_block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }\r\n        }\r\n        return checkpoints[min].value;\r\n    }\r\n\r\n    \/\/\/ @dev `updateValueAtNow` used to update the `balances` map and the\r\n    \/\/\/  `totalSupplyHistory`\r\n    \/\/\/ @param checkpoints The history of data being updated\r\n    \/\/\/ @param _value The new number of tokens\r\n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\r\n    ) internal  {\r\n        if ((checkpoints.length == 0)\r\n        || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\r\n               Checkpoint newCheckPoint = checkpoints[ checkpoints.length++ ];\r\n               newCheckPoint.fromBlock =  uint128(block.number);\r\n               newCheckPoint.value = uint128(_value);\r\n           } else {\r\n               Checkpoint oldCheckPoint = checkpoints[checkpoints.length-1];\r\n               oldCheckPoint.value = uint128(_value);\r\n           }\r\n    }\r\n\r\n    \/\/\/ @dev Internal function to determine if an address is a contract\r\n    \/\/\/ @param _addr The address being queried\r\n    \/\/\/ @return True if `_addr` is a contract\r\n    function isContract(address _addr) constant internal returns(bool) {\r\n        uint size;\r\n        if (_addr == 0) return false;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size>0;\r\n    }\r\n\r\n    \/\/\/ @dev Helper function to return a min betwen the two uints\r\n    function min(uint a, uint b) internal returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    \/\/\/ @notice The fallback function: If the contract's controller has not been\r\n    \/\/\/  set to 0, then the `proxyPayment` method is called which relays the\r\n    \/\/\/  ether and creates tokens as described in the token controller contract\r\n    function ()  payable {\r\n        if (isContract(controller)) {\r\n            if (! TokenController(controller).proxyPayment.value(msg.value)(msg.sender))\r\n                throw;\r\n        } else {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    \/\/\/ @notice This method can be used by the controller to extract mistakenly\r\n    \/\/\/  sent tokens to this contract.\r\n    \/\/\/ @param _token The address of the token contract that you want to recover\r\n    \/\/\/  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token) onlyController {\r\n        if (_token == 0x0) {\r\n            controller.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        ERC20Token token = ERC20Token(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(controller, balance);\r\n        ClaimedTokens(_token, controller, balance);\r\n    }\r\n\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ Events\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _amount\r\n        );\r\n\r\n}\r\n\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ MiniMeTokenFactory\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n\/\/\/ @dev This contract is used to generate clone contracts from a contract.\r\n\/\/\/  In solidity this is the way to create a contract from a contract of the\r\n\/\/\/  same class\r\ncontract MiniMeTokenFactory {\r\n\r\n    \/\/\/ @notice Update the DApp by creating a new token with new functionalities\r\n    \/\/\/  the msg.sender becomes the controller of this clone token\r\n    \/\/\/ @param _parentToken Address of the token being cloned\r\n    \/\/\/ @param _snapshotBlock Block of the parent token that will\r\n    \/\/\/  determine the initial distribution of the clone token\r\n    \/\/\/ @param _tokenName Name of the new token\r\n    \/\/\/ @param _decimalUnits Number of decimals of the new token\r\n    \/\/\/ @param _tokenSymbol Token Symbol for the new token\r\n    \/\/\/ @param _transfersEnabled If true, tokens will be able to be transferred\r\n    \/\/\/ @return The address of the new token contract\r\n    function createCloneToken(\r\n        address _parentToken,\r\n        uint _snapshotBlock,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        bool _transfersEnabled\r\n    ) returns (MiniMeToken) {\r\n        MiniMeToken newToken = new MiniMeToken(\r\n            this,\r\n            _parentToken,\r\n            _snapshotBlock,\r\n            _tokenName,\r\n            _decimalUnits,\r\n            _tokenSymbol,\r\n            _transfersEnabled\r\n            );\r\n\r\n        newToken.changeController(msg.sender);\r\n        return newToken;\r\n    }\r\n}\r\n\r\n\r\n\/\/\/ @dev `Owned` is a base level contract that assigns an `owner` that can be\r\n\/\/\/  later changed\r\ncontract Owned {\r\n    \/\/\/ @dev `owner` is the only address that can call a function with this\r\n    \/\/\/ modifier\r\n    modifier onlyOwner { if (msg.sender != owner) throw; _; }\r\n\r\n    address public owner;\r\n\r\n    \/\/\/ @notice The Constructor assigns the message sender to be `owner`\r\n    function Owned() { owner = msg.sender;}\r\n\r\n    \/\/\/ @notice `owner` can step down and assign some other address to this role\r\n    \/\/\/ @param _newOwner The address of the new owner. 0x0 can be used to create\r\n    \/\/\/  an unowned neutral vault, however that cannot be undone\r\n    function changeOwner(address _newOwner) onlyOwner {\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n\r\n\/\/\/ @dev This is designed to control the issuance of a MiniMe Token for a\r\n\/\/\/  non-profit Campaign. This contract effectively dictates the terms of the\r\n\/\/\/  funding round.\r\n\r\ncontract GivethCampaign is TokenController, Owned {\r\n\r\n    uint public startFundingTime;       \/\/ In UNIX Time Format\r\n    uint public endFundingTime;         \/\/ In UNIX Time Format\r\n    uint public maximumFunding;         \/\/ In wei\r\n    uint public totalCollected;         \/\/ In wei\r\n    MiniMeToken public tokenContract;   \/\/ The new token for this Campaign\r\n    address public vaultAddress;        \/\/ The address to hold the funds donated\r\n\r\n\/\/\/ @notice 'GivethCampaign()' initiates the Campaign by setting its funding\r\n\/\/\/ parameters\r\n\/\/\/ @dev There are several checks to make sure the parameters are acceptable\r\n\/\/\/ @param _startFundingTime The UNIX time that the Campaign will be able to\r\n\/\/\/ start receiving funds\r\n\/\/\/ @param _endFundingTime The UNIX time that the Campaign will stop being able\r\n\/\/\/ to receive funds\r\n\/\/\/ @param _maximumFunding In wei, the Maximum amount that the Campaign can\r\n\/\/\/ receive (currently the max is set at 10,000 ETH for the beta)\r\n\/\/\/ @param _vaultAddress The address that will store the donated funds\r\n\/\/\/ @param _tokenAddress Address of the token contract this contract controls\r\n\r\n    function GivethCampaign(\r\n        uint _startFundingTime,\r\n        uint _endFundingTime,\r\n        uint _maximumFunding,\r\n        address _vaultAddress,\r\n        address _tokenAddress\r\n\r\n    ) {\r\n        if ((_endFundingTime < now) ||                \/\/ Cannot end in the past\r\n            (_endFundingTime <= _startFundingTime) ||\r\n            (_maximumFunding > 10000 ether) ||        \/\/ The Beta is limited\r\n            (_vaultAddress == 0))                     \/\/ To prevent burning ETH\r\n            {\r\n            throw;\r\n            }\r\n        startFundingTime = _startFundingTime;\r\n        endFundingTime = _endFundingTime;\r\n        maximumFunding = _maximumFunding;\r\n        tokenContract = MiniMeToken(_tokenAddress);\/\/ The Deployed Token Contract\r\n        vaultAddress = _vaultAddress;\r\n    }\r\n\r\n\/\/\/ @dev The fallback function is called when ether is sent to the contract, it\r\n\/\/\/ simply calls `doPayment()` with the address that sent the ether as the\r\n\/\/\/ `_owner`. Payable is a required solidity modifier for functions to receive\r\n\/\/\/ ether, without this modifier functions will throw if ether is sent to them\r\n\r\n    function ()  payable {\r\n        doPayment(msg.sender);\r\n    }\r\n\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\/\/ TokenController interface\r\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\r\n\r\n\/\/\/ @notice `proxyPayment()` allows the caller to send ether to the Campaign and\r\n\/\/\/ have the tokens created in an address of their choosing\r\n\/\/\/ @param _owner The address that will hold the newly created tokens\r\n\r\n    function proxyPayment(address _owner) payable returns(bool) {\r\n        doPayment(_owner);\r\n        return true;\r\n    }\r\n\r\n\/\/\/ @notice Notifies the controller about a transfer, for this Campaign all\r\n\/\/\/  transfers are allowed by default and no extra notifications are needed\r\n\/\/\/ @param _from The origin of the transfer\r\n\/\/\/ @param _to The destination of the transfer\r\n\/\/\/ @param _amount The amount of the transfer\r\n\/\/\/ @return False if the controller does not authorize the transfer\r\n    function onTransfer(address _from, address _to, uint _amount) returns(bool) {\r\n        return true;\r\n    }\r\n\r\n\/\/\/ @notice Notifies the controller about an approval, for this Campaign all\r\n\/\/\/  approvals are allowed by default and no extra notifications are needed\r\n\/\/\/ @param _owner The address that calls `approve()`\r\n\/\/\/ @param _spender The spender in the `approve()` call\r\n\/\/\/ @param _amount The amount in the `approve()` call\r\n\/\/\/ @return False if the controller does not authorize the approval\r\n    function onApprove(address _owner, address _spender, uint _amount)\r\n        returns(bool)\r\n    {\r\n        return true;\r\n    }\r\n\r\n\r\n\/\/\/ @dev `doPayment()` is an internal function that sends the ether that this\r\n\/\/\/  contract receives to the `vault` and creates tokens in the address of the\r\n\/\/\/  `_owner` assuming the Campaign is still accepting funds\r\n\/\/\/ @param _owner The address that will hold the newly created tokens\r\n\r\n    function doPayment(address _owner) internal {\r\n\r\n\/\/ First check that the Campaign is allowed to receive this donation\r\n        if ((now<startFundingTime) ||\r\n            (now>endFundingTime) ||\r\n            (tokenContract.controller() == 0) ||           \/\/ Extra check\r\n            (msg.value == 0) ||\r\n            (totalCollected + msg.value > maximumFunding))\r\n        {\r\n            throw;\r\n        }\r\n\r\n\/\/Track how much the Campaign has collected\r\n        totalCollected += msg.value;\r\n\r\n\/\/Send the ether to the vault\r\n        if (!vaultAddress.send(msg.value)) {\r\n            throw;\r\n        }\r\n\r\n\/\/ Creates an equal amount of tokens as ether sent. The new tokens are created\r\n\/\/  in the `_owner` address\r\n        if (!tokenContract.generateTokens(_owner, msg.value)) {\r\n            throw;\r\n        }\r\n\r\n        return;\r\n    }\r\n\r\n\/\/\/ @notice `finalizeFunding()` ends the Campaign by calling setting the\r\n\/\/\/  controller to 0, thereby ending the issuance of new tokens and stopping the\r\n\/\/\/  Campaign from receiving more ether\r\n\/\/\/ @dev `finalizeFunding()` can only be called after the end of the funding period.\r\n\r\n    function finalizeFunding() {\r\n        if (now < endFundingTime) throw;\r\n        tokenContract.changeController(0);\r\n    }\r\n\r\n\r\n\/\/\/ @notice `onlyOwner` changes the location that ether is sent\r\n\/\/\/ @param _newVaultAddress The address that will receive the ether sent to this\r\n\/\/\/  Campaign\r\n    function setVault(address _newVaultAddress) onlyOwner {\r\n        vaultAddress = _newVaultAddress;\r\n    }\r\n\r\n    \/\/\/\/\/\/\/\/\/\/\r\n    \/\/ Safety Methods\r\n    \/\/\/\/\/\/\/\/\/\/\r\n\r\n    \/\/\/ @notice This method can be used by the controller to extract mistakenly\r\n    \/\/\/  sent tokens to this contract.\r\n    \/\/\/ @param _token The address of the token contract that you want to recover\r\n    \/\/\/  set to 0 in case you want to extract ether.\r\n    function claimTokens(address _token) public onlyOwner {\r\n        if (tokenContract.controller() == address(this)) {\r\n            tokenContract.claimTokens(_token);\r\n        }\r\n        if (_token == 0x0) {\r\n            owner.transfer(this.balance);\r\n            return;\r\n        }\r\n\r\n        ERC20Token token = ERC20Token(_token);\r\n        uint256 balance = token.balanceOf(this);\r\n        token.transfer(owner, balance);\r\n        ClaimedTokens(_token, owner, balance);\r\n    }\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\r\n\r\n}",
      "officialLinks": {
        "Reddit": "https:\/\/www.reddit.com\/user\/jbaylina",
        "Telegram": "",
        "Website": "http:\/\/www.giveth.io\/",
        "Email": "",
        "Twitter": ""
      },
      "EtherscanLink": "https:\/\/etherscan.io\/address\/0xd556caf704e39fc728058557a113b226207d2212#code"
    }
  ];
}
